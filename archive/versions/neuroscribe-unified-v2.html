<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroScribe Unified - Professional Clinical Documentation with Industrial-Grade Validation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #E8F4F8 0%, #F5F8FA 100%);
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        h1 {
            color: #4A90E2;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.2rem;
        }

        .version {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .grid {
            display: grid;
            grid-template-columns: 350px 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1400px) {
            .grid {
                grid-template-columns: 1fr 1fr;
            }
            .briefing-panel {
                grid-column: 1 / -1;
            }
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: #FAFBFC;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #E1E4E8;
        }

        .panel h2 {
            color: #333;
            margin-bottom: 12px;
            font-size: 1.3rem;
        }

        textarea {
            width: 100%;
            min-height: 300px;
            padding: 12px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.95rem;
            resize: vertical;
            margin-bottom: 10px;
        }

        textarea:focus {
            outline: none;
            border-color: #4A90E2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        button {
            padding: 8px 16px;
            background: #4A90E2;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            margin: 3px;
            transition: all 0.2s;
        }

        button:hover {
            background: #5BA3F5;
            box-shadow: 0 2px 8px rgba(74, 144, 226, 0.25);
        }

        button:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
        }

        button.success {
            background: #10b981;
        }

        button.success:hover {
            background: #059669;
        }

        button.danger {
            background: #ef4444;
        }

        button.danger:hover {
            background: #dc2626;
        }

        button.warning {
            background: #f59e0b;
        }

        button.warning:hover {
            background: #d97706;
        }

        .status {
            text-align: center;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .status.connected {
            background: #d1fae5;
            color: #065f46;
        }

        .status.disconnected {
            background: #fee2e2;
            color: #991b1b;
        }

        .status.recording {
            background: #fef3c7;
            color: #92400e;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .buttons button {
            flex: 1;
            min-width: 100px;
        }

        .info {
            background: #EBF5FB;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 0.85rem;
            border-left: 3px solid #4A90E2;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: white;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #E1E4E8;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 600;
            color: #4A90E2;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 4px;
        }

        .recording-controls {
            margin-bottom: 15px;
        }

        /* Pathology Button Styles */
        .pathology-btn {
            padding: 6px 10px;
            background: white;
            color: #6b7280;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0;
        }

        .pathology-btn:hover {
            background: #f9fafb;
            border-color: #4A90E2;
            box-shadow: 0 1px 4px rgba(74, 144, 226, 0.15);
        }

        .pathology-btn.active {
            background: #4A90E2;
            color: white;
            border-color: #4A90E2;
        }

        /* Tab Navigation Styles */
        .tab-buttons {
            display: flex;
            gap: 3px;
            margin-bottom: 12px;
            border-bottom: 1px solid #E1E4E8;
        }

        .tab-button {
            flex: 1;
            padding: 8px 16px;
            background: transparent;
            color: #6b7280;
            border: none;
            border-bottom: 2px solid transparent;
            border-radius: 0;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            margin: 0;
        }

        .tab-button:hover {
            background: #f9fafb;
            color: #4A90E2;
            transform: none;
            box-shadow: none;
        }

        .tab-button.active {
            color: #4A90E2;
            border-bottom-color: #4A90E2;
            background: transparent;
            font-weight: 500;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .formatted-output {
            background: white;
            padding: 15px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            min-height: 300px;
            max-height: 700px;
            overflow-y: auto;
            font-family: 'Georgia', serif;
            line-height: 1.6;
        }

        .formatted-output h1 {
            color: #333;
            font-size: 1.4rem;
            margin-bottom: 12px;
            border-bottom: 2px solid #4A90E2;
            padding-bottom: 8px;
        }

        .formatted-output h2 {
            color: #4A90E2;
            font-size: 1.15rem;
            margin-top: 16px;
            margin-bottom: 8px;
        }

        .formatted-output h3 {
            color: #374151;
            font-size: 0.95rem;
            margin-top: 12px;
            margin-bottom: 6px;
        }

        .formatted-output ul {
            margin-left: 20px;
        }

        .formatted-output p {
            margin: 10px 0;
        }

        .export-options {
            display: grid;
            gap: 15px;
        }

        .export-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .export-row label {
            min-width: 120px;
            font-weight: 600;
        }

        .export-row select {
            flex: 1;
            padding: 8px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        /* Collapsible Panel Styles */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .panel-header h2 {
            margin: 0;
        }

        .collapse-icon {
            font-size: 1.2rem;
            color: #4A90E2;
            transition: transform 0.3s;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .panel-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
            pointer-events: auto;
        }

        .panel-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            pointer-events: none;
        }

        /* SOAP Quick-Entry Panel Styles */
        .soap-panel {
            grid-column: 1 / -1;  /* Span full width on all screen sizes */
        }

        .soap-section {
            margin-bottom: 15px;
        }

        .soap-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .soap-textarea:focus {
            outline: none;
            border-color: #4A90E2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .soap-textarea::placeholder {
            color: #9ca3af;
            font-style: italic;
        }

        /* Enhancement Toggle Disabled State */
        input[type="checkbox"]:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        label:has(input[type="checkbox"]:disabled) {
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h1 style="margin: 0;">üß† NeuroScribe V7 - Professional Clinical Intelligence</h1>
            <div style="display: flex; align-items: center; gap: 15px;">
                <div id="apiKeyStatus" style="font-size: 0.85rem; color: #6b7280;"></div>
                <button onclick="openSettings()" style="padding: 8px 16px; background: #4A90E2; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                    ‚öôÔ∏è Settings
                </button>
            </div>
        </div>
        <div class="version">Enhanced Diagnostic Reasoning + Evidence-Based Medicine + Industrial-Grade 6-Layer Validation | Unified Edition</div>

        <div id="status" class="status disconnected">
            üîë Checking API key...
        </div>

        <!-- Settings Modal -->
        <div id="settingsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 10000; justify-content: center; align-items: center;">
            <div style="background: white; border-radius: 12px; padding: 30px; max-width: 600px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.2);">
                <h2 style="color: #4A90E2; margin-bottom: 15px; font-size: 1.4rem;">‚öôÔ∏è API Key Settings</h2>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 500; margin-bottom: 8px; color: #333; font-size: 0.9rem;">
                        Google Gemini API Key:
                    </label>
                    <input
                        type="password"
                        id="apiKeyInput"
                        placeholder="AIzaSy... (paste your API key here)"
                        style="width: 100%; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: monospace;"
                    />
                    <div style="margin-top: 6px; font-size: 0.8rem; color: #6b7280;">
                        Your API key is encrypted and stored locally in your browser. It never leaves your device.
                    </div>
                </div>

                <div style="background: #EBF5FB; padding: 12px; border-radius: 6px; margin-bottom: 15px; border-left: 3px solid #4A90E2;">
                    <strong style="font-size: 0.9rem;">üìå Don't have an API key?</strong><br>
                    <div style="margin-top: 6px; font-size: 0.85rem; line-height: 1.6;">
                        1. Visit <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: #4A90E2; text-decoration: underline;">Google AI Studio</a><br>
                        2. Sign in with your Google account<br>
                        3. Click "Create API Key"<br>
                        4. Copy the key and paste it above<br>
                        5. It's FREE with generous limits!
                    </div>
                </div>

                <div id="apiKeyStatusModal" style="margin-bottom: 15px; padding: 10px; border-radius: 6px; display: none; font-size: 0.9rem;"></div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                    <button onclick="saveAPIKey()" style="padding: 10px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        üíæ Save & Test
                    </button>
                    <button onclick="testAPIKey()" style="padding: 10px; background: #4A90E2; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        üß™ Test Key
                    </button>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <button onclick="clearAPIKey()" style="padding: 10px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        üóëÔ∏è Clear Key
                    </button>
                    <button onclick="closeSettings()" style="padding: 10px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        Cancel
                    </button>
                </div>

                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 0.85rem; color: #666;">
                    <strong>üîí Privacy & Security:</strong><br>
                    ‚Ä¢ API key stored locally in your browser only<br>
                    ‚Ä¢ Encrypted using Base64 + character reversal<br>
                    ‚Ä¢ No server storage - your key never leaves your device<br>
                    ‚Ä¢ Clear browser data to remove the key
                </div>
            </div>
        </div>

        <div class="grid">
            <!-- Briefing Panel: Pre-Consultation Research -->
            <div class="panel briefing-panel">
                <div class="panel-header" onclick="togglePanel('briefing')">
                    <h2>üî¨ Pre-Consultation Briefing</h2>
                    <span class="collapse-icon" id="briefing-icon">‚ñº</span>
                </div>

                <div class="panel-content" id="briefing-content">
                <div class="info" style="margin-bottom: 12px;">
                    <strong>Expert Analysis:</strong> Enter specific pathology or select common category for deep research
                </div>

                <!-- Custom Pathology Input -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">Specific Pathology / Diagnosis:</label>
                    <input
                        type="text"
                        id="customPathology"
                        placeholder="e.g., C5-6 foraminal stenosis with radiculopathy, diffuse low-grade glioma..."
                        style="width: 100%; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; margin-bottom: 8px;"
                        oninput="onCustomPathologyInput()"
                    />
                    <div style="font-size: 0.8rem; color: #666; font-style: italic;">
                        Enter specific pathology for deep search, or select common category below
                    </div>
                </div>

                <!-- Pathology Quick-Select -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">Or select common pathology:</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="selectPathology('spine-degenerative')" class="pathology-btn" data-pathology="spine-degenerative">
                            ü¶¥ Spine Deg
                        </button>
                        <button onclick="selectPathology('spine-trauma')" class="pathology-btn" data-pathology="spine-trauma">
                            ‚ö†Ô∏è Trauma
                        </button>
                        <button onclick="selectPathology('brain-tumor')" class="pathology-btn" data-pathology="brain-tumor">
                            üß† Tumor
                        </button>
                        <button onclick="selectPathology('vascular')" class="pathology-btn" data-pathology="vascular">
                            üíâ Vascular
                        </button>
                        <button onclick="selectPathology('hydrocephalus')" class="pathology-btn" data-pathology="hydrocephalus">
                            üíß Hydro
                        </button>
                        <button onclick="selectPathology('functional')" class="pathology-btn" data-pathology="functional">
                            ‚öôÔ∏è Functional
                        </button>
                        <button onclick="selectPathology('pediatric')" class="pathology-btn" data-pathology="pediatric">
                            üë∂ Pediatric
                        </button>
                        <button onclick="selectPathology('peripheral')" class="pathology-btn" data-pathology="peripheral">
                            üîå Peripheral
                        </button>
                    </div>
                </div>

                <!-- Research Depth -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">Research Depth:</label>
                    <select id="briefingDepth" style="width: 100%; padding: 8px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem;">
                        <option value="quick">Quick Overview (30 sec)</option>
                        <option value="standard" selected>Standard Briefing (1 min)</option>
                        <option value="comprehensive">Comprehensive (2 min)</option>
                    </select>
                </div>

                <!-- Expert Document Upload -->
                <div style="margin-bottom: 12px; border: 2px dashed #E1E4E8; border-radius: 6px; padding: 12px; background: #FAFBFC;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">
                        üìö Upload Expert Documents (Optional):
                    </label>
                    <div style="font-size: 0.8rem; color: #666; margin-bottom: 10px;">
                        Upload research papers, guidelines, or notes to enrich the briefing
                    </div>
                    <input
                        type="file"
                        id="expertDocUpload"
                        accept=".txt,.pdf,.doc,.docx"
                        multiple
                        style="width: 100%; padding: 8px; font-size: 0.85rem;"
                        onchange="handleDocumentUpload(event)"
                    />
                    <div id="uploadedDocs" style="margin-top: 10px; font-size: 0.8rem; color: #333;">
                    </div>
                    <!-- Document Storage Management UI -->
                    <div id="documentStorageUI"></div>
                </div>

                <!-- Generate Button -->
                <button onclick="generateDeepBriefing()" id="briefingBtn" class="success" style="width: 100%; margin-bottom: 15px;" disabled>
                    üéØ Generate Deep Research + Checklist
                </button>

                <!-- Briefing Output -->
                <div id="briefingOutput" style="background: white; border: 1px solid #E1E4E8; border-radius: 6px; padding: 12px; min-height: 200px; max-height: 500px; overflow-y: auto; font-size: 0.85rem; line-height: 1.5;">
                    <p style="color: #9ca3af; text-align: center; padding: 30px 10px;">
                        Select a pathology type to generate pre-consultation briefing
                    </p>
                </div>
                </div>
            </div>

            <!-- Transcript Panel: Input -->
            <div class="panel">
                <div class="panel-header" onclick="togglePanel('transcript')">
                    <h2>üìù Clinical Transcript</h2>
                    <span class="collapse-icon" id="transcript-icon">‚ñº</span>
                </div>

                <div class="panel-content" id="transcript-content">

                <!-- Consultation Type Selector -->
                <div style="margin-bottom: 12px; background: #EBF5FB; padding: 12px; border-radius: 6px; border-left: 3px solid #4A90E2;">
                    <label style="display: block; font-weight: 500; margin-bottom: 8px; color: #333; font-size: 0.9rem;">
                        üìã Consultation Type:
                    </label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="selectConsultType('new')" id="consultTypeNew" class="consult-type-btn" style="padding: 10px; border: 2px solid #4A90E2; border-radius: 6px; background: #4A90E2; color: white; cursor: pointer; font-weight: 500; transition: all 0.2s; font-size: 0.9rem;">
                            üÜï New Consultation
                        </button>
                        <button onclick="selectConsultType('followup')" id="consultTypeFollowup" class="consult-type-btn" style="padding: 10px; border: 2px solid #E1E4E8; border-radius: 6px; background: white; color: #333; cursor: pointer; font-weight: 500; transition: all 0.2s; font-size: 0.9rem;">
                            üîÑ Follow-up Visit
                        </button>
                    </div>
                    <div id="consultTypeDescription" style="margin-top: 8px; font-size: 0.8rem; color: #6b7280;">
                        <strong>New Consultation:</strong> Comprehensive initial assessment with full history, examination, and workup.
                    </div>
                </div>

                <!-- Transcript Enhancement Mode Toggle -->
                <div style="margin-bottom: 15px; background: #E3F2FD; padding: 12px; border-radius: 6px; border-left: 3px solid #2196F3;">
                    <label style="display: flex; align-items: flex-start; cursor: pointer; font-size: 0.9rem;" id="transcriptEnhanceLabel">
                        <input type="checkbox" id="transcriptEnhanceToggle" onchange="toggleTranscriptEnhancement()"
                               style="margin-right: 10px; margin-top: 2px; width: 18px; height: 18px; cursor: pointer; flex-shrink: 0;"
                               disabled>
                        <div>
                            <strong>ü§ñ Enhanced Mode:</strong> Add briefing-based clinical analysis & recommendations<br>
                            <span style="font-size: 0.75rem; color: #666; font-style: italic;">
                                Unchecked = Expand only | Checked = Briefing Integration + Analysis
                            </span>
                        </div>
                    </label>

                    <div id="transcriptEnhanceWarning" style="display: block; margin-top: 8px; padding: 8px; background: #FFF3CD; border-radius: 4px; font-size: 0.75rem;">
                        üí° <strong>Note:</strong> Generate a briefing first to enable Enhanced Mode
                    </div>
                </div>

                <div class="info">
                    <strong>üé§ New:</strong> Use voice recording or type/paste your transcript
                </div>

                <!-- Recording Controls -->
                <div class="recording-controls">
                    <div class="buttons">
                        <button onclick="startRecording()" id="startBtn">
                            üé§ Start Recording
                        </button>
                        <button onclick="stopRecording()" id="stopBtn" disabled>
                            ‚èπÔ∏è Stop
                        </button>
                        <button onclick="pauseRecording()" id="pauseBtn" class="warning" disabled>
                            ‚è∏Ô∏è Pause
                        </button>
                        <button onclick="clearText()">
                            üóëÔ∏è Clear
                        </button>
                    </div>
                </div>

                <textarea
                    id="transcript"
                    placeholder="Click 'Start Recording' to use voice transcription, or type/paste your clinical encounter transcript here..."
                ></textarea>

                <!-- Stats -->
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="wordCount">0</div>
                        <div class="stat-label">Words</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="duration">00:00</div>
                        <div class="stat-label">Duration</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="confidence">--</div>
                        <div class="stat-label">Confidence</div>
                    </div>
                </div>
                </div>
            </div>

            <!-- SOAP Quick-Entry Panel: Structured Input -->
            <div class="panel soap-panel">
                <div class="panel-header" onclick="togglePanel('soap')">
                    <h2>üìã SOAP Quick-Entry</h2>
                    <span class="collapse-icon" id="soap-icon">‚ñº</span>
                </div>

                <div class="panel-content" id="soap-content">
                <div class="info" style="background: #FFF3CD; border-left: 3px solid #FFA500;">
                    <strong>üìã Quick Entry Mode:</strong> Enter brief headnotes or bullet points - AI will expand into professional clinical documentation
                </div>

                <!-- Enhancement Mode Toggle -->
                <div style="margin-bottom: 15px; background: #E8F5E9; padding: 12px; border-radius: 6px; border-left: 3px solid #4CAF50;">
                    <label style="display: flex; align-items: flex-start; cursor: pointer; font-size: 0.9rem;">
                        <input type="checkbox" id="soapEnhanceToggle" onchange="toggleSOAPEnhancement()" style="margin-right: 10px; margin-top: 2px; width: 18px; height: 18px; cursor: pointer; flex-shrink: 0;">
                        <div>
                            <strong>ü§ñ Enhanced Mode:</strong> Add clinical analysis & evidence-based recommendations<br>
                            <span style="font-size: 0.75rem; color: #666; font-style: italic;">
                                Unchecked = Expand only (safer) | Checked = Expand + Clinical Analysis
                            </span>
                        </div>
                    </label>

                    <div id="enhanceWarning" style="display: none; margin-top: 8px; padding: 8px; background: #FFF3CD; border-radius: 4px; font-size: 0.75rem;">
                        üí° <strong>Tip:</strong> Select a pathology and generate briefing for best enhanced analysis
                    </div>
                </div>

                <!-- Input Mode Toggle: Simple (Unified) vs Advanced (4-Box) -->
                <div style="margin-bottom: 15px; background: #E3F2FD; padding: 12px; border-radius: 6px; border-left: 3px solid #2196F3;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                        <strong style="font-size: 0.9rem;">üìù Input Mode:</strong>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <button id="simpleModeBtn" onclick="switchSOAPMode('simple')"
                                    style="padding: 6px 12px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: 600;">
                                Simple (1 Box)
                            </button>
                            <button id="advancedModeBtn" onclick="switchSOAPMode('advanced')"
                                    style="padding: 6px 12px; background: #E0E0E0; color: #666; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: 600;">
                                Advanced (4 Boxes)
                            </button>
                        </div>
                    </div>
                    <div style="font-size: 0.75rem; color: #555;">
                        <span id="modeDescription">
                            <strong>Simple:</strong> Enter all SOAP sections in one textbox (AI will intelligently parse sections)
                        </span>
                    </div>
                </div>

                <!-- SIMPLE MODE: Unified SOAP Input -->
                <div id="soapUnifiedContainer" style="display: block; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #2196F3;">‚úèÔ∏è</span> Clinical Documentation:
                        </label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <span id="parseMethod" style="font-size: 0.7rem; color: #999; padding: 2px 6px; background: #F5F5F5; border-radius: 3px;">Not parsed</span>
                            <span style="font-size: 0.75rem; color: #999;">Format: S: / O: / A: / P: or free text</span>
                        </div>
                    </div>
                    <textarea
                        id="soapUnifiedInput"
                        class="soap-textarea"
                        placeholder="Enter clinical notes in any format:&#10;&#10;LABELED FORMAT (Recommended):&#10;S: 45F neck pain x 3wks, worse w/ extension, denies numbness, failed NSAIDs&#10;O: Spurling+ left, motor 5/5, decreased C6 sensation left&#10;A: C5-6 foraminal stenosis with left C6 radiculopathy&#10;P: MRI cervical spine, continue NSAIDs, PT, F/U 4wks&#10;&#10;FREE TEXT FORMAT (AI will parse):&#10;Patient reports 3 weeks of neck pain that worsens with extension. No numbness. NSAIDs haven't helped. Exam shows positive Spurling test on left, motor strength 5/5, decreased C6 sensation. Impression is C5-6 foraminal stenosis with left C6 radiculopathy. Plan for MRI, NSAIDs, PT, follow-up in 4 weeks."
                        oninput="updateUnifiedStats()"
                        style="width: 100%; min-height: 200px; padding: 12px; border: 2px solid #2196F3; border-radius: 6px; font-size: 0.9rem; font-family: 'Courier New', monospace; resize: vertical; line-height: 1.6;"
                    ></textarea>

                    <!-- Parse Preview Button -->
                    <div style="margin-top: 10px; display: flex; gap: 10px; align-items: center;">
                        <button onclick="previewSOAPParsing()"
                                style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 600;">
                            üîç Preview Parsing
                        </button>
                        <span id="parseConfidence" style="font-size: 0.8rem; color: #666;"></span>
                    </div>
                </div>

                <!-- ADVANCED MODE: 4 Separate Textareas (Original) -->
                <div id="soapSeparateContainer" style="display: none;">
                <!-- SOAP Section: Subjective -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Subjective (Patient History):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">bullets or brief phrases</span>
                    </div>
                    <textarea
                        id="soapSubjective"
                        class="soap-textarea"
                        placeholder="Enter brief notes, e.g.:&#10;‚Ä¢ Neck pain x 3 weeks&#10;‚Ä¢ Worse with extension&#10;‚Ä¢ Denies numbness&#10;‚Ä¢ Failed NSAIDs"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: vertical;"
                    ></textarea>
                </div>

                <!-- SOAP Section: Objective -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Objective (Examination):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">findings only</span>
                    </div>
                    <textarea
                        id="soapObjective"
                        class="soap-textarea"
                        placeholder="Enter exam findings, e.g.:&#10;‚Ä¢ Spurling test positive left&#10;‚Ä¢ Motor 5/5 throughout&#10;‚Ä¢ Decreased C6 sensation left"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: vertical;"
                    ></textarea>
                </div>

                <!-- SOAP Section: Assessment -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Assessment (Diagnosis):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">your impression</span>
                    </div>
                    <textarea
                        id="soapAssessment"
                        class="soap-textarea"
                        placeholder="Enter diagnosis/impression, e.g.:&#10;‚Ä¢ C5-6 foraminal stenosis with left C6 radiculopathy"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 60px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: vertical;"
                    ></textarea>
                </div>

                <!-- SOAP Section: Plan -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Plan (Management):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">treatment & follow-up</span>
                    </div>
                    <textarea
                        id="soapPlan"
                        class="soap-textarea"
                        placeholder="Enter management plan, e.g.:&#10;‚Ä¢ MRI cervical spine&#10;‚Ä¢ Continue NSAIDs&#10;‚Ä¢ PT for cervical strengthening&#10;‚Ä¢ F/U 4 weeks with MRI"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: vertical;"
                    ></textarea>
                </div>
                </div>
                <!-- End of Advanced Mode Container -->

                <!-- Stats -->
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="soapTotalWords">0</div>
                        <div class="stat-label">Total Words</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="soapSectionCount">0/4</div>
                        <div class="stat-label">Sections</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="soapMode">Expand</div>
                        <div class="stat-label">Mode</div>
                    </div>
                </div>
                </div>
            </div>

            <!-- Right Panel: Output with Tabs -->
            <div class="panel">
                <h2>ü§ñ AI-Generated Documentation</h2>

                <button onclick="generate()" class="success" id="generateBtn" style="width: 100%; margin-bottom: 15px;">
                    ‚ö° Generate Clinical Note
                </button>

                <!-- Tab Navigation -->
                <div class="tab-buttons">
                    <button class="tab-button active" onclick="switchTab('formatted')">
                        üìÑ Formatted Note
                    </button>
                    <button class="tab-button" onclick="switchTab('raw')">
                        üìù Raw Output
                    </button>
                    <button class="tab-button" onclick="switchTab('scales')">
                        üìä Clinical Scales
                    </button>
                    <button class="tab-button" onclick="switchTab('export')">
                        üíæ Export Options
                    </button>
                    <button class="tab-button" onclick="switchTab('review')" id="review-tab-button" style="display: none;">
                        üîç Review Suggestions
                    </button>
                    <button class="tab-button" onclick="switchTab('attending')" id="attending-tab-button" style="display: none;">
                        üìä Attending Summary
                    </button>
                </div>

                <!-- Tab 1: Formatted Note -->
                <div class="tab-content active" id="tab-formatted">
                    <div class="formatted-output" id="formattedOutput">
                        <p style="color: #999; text-align: center; padding: 50px;">
                            Generate documentation to see formatted output here
                        </p>
                    </div>
                    <div class="buttons" style="margin-top: 15px;">
                        <button onclick="copyFormatted()">üìã Copy</button>
                        <button onclick="printFormatted()">üñ®Ô∏è Print</button>
                    </div>
                </div>

                <!-- Tab 2: Raw Output -->
                <div class="tab-content" id="tab-raw">
                    <textarea
                        id="output"
                        placeholder="Raw markdown output will appear here..."
                        readonly
                    ></textarea>
                    <div class="buttons" style="margin-top: 15px;">
                        <button onclick="copyOutput()">üìã Copy</button>
                        <button onclick="downloadOutput()">üíæ Download TXT</button>
                    </div>
                </div>

                <!-- Tab 3: Clinical Scales -->
                <div class="tab-content" id="tab-scales">
                    <div class="scales-container">
                        <div class="scale-selector" style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 10px; font-weight: 600; color: #333;">
                                Select Clinical Scale:
                            </label>
                            <select id="scaleSelect" onchange="loadScaleForm()" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem; margin-bottom: 15px;">
                                <option value="">-- Select a Scale --</option>
                            </select>
                        </div>

                        <div id="scaleFormContainer" style="display: none;">
                            <div id="scaleDescription" style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #0066CC;">
                            </div>

                            <div id="scaleQuestions" style="margin-bottom: 20px;">
                            </div>

                            <button onclick="calculateScale()" class="success" style="width: 100%; margin-bottom: 15px;">
                                üßÆ Calculate Score
                            </button>

                            <div id="scaleResults" style="display: none; background: #f9f9f9; padding: 20px; border-radius: 8px; border: 2px solid #ddd;">
                            </div>
                        </div>

                        <div id="scalesPlaceholder" style="text-align: center; padding: 50px; color: #999;">
                            <p>Select a clinical scale to begin assessment</p>
                            <p style="font-size: 0.9rem; margin-top: 10px;">Scales will be automatically suggested based on selected pathology</p>
                        </div>
                    </div>
                </div>

                <!-- Tab 4: Export Options -->
                <div class="tab-content" id="tab-export">
                    <div class="export-options">
                        <div class="export-row">
                            <label>Format:</label>
                            <select id="exportFormat">
                                <option value="txt">Plain Text (.txt)</option>
                                <option value="docx">Word Document (.docx)</option>
                                <option value="pdf">PDF Document (.pdf)</option>
                                <option value="json">JSON Data (.json)</option>
                                <option value="html">HTML Page (.html)</option>
                            </select>
                        </div>
                        <div class="export-row">
                            <label>Include:</label>
                            <select id="exportIncludes">
                                <option value="full">Full Documentation</option>
                                <option value="summary">Summary Only</option>
                                <option value="plan">Assessment & Plan Only</option>
                            </select>
                        </div>
                        <button onclick="doExport()" class="success" style="width: 100%;">
                            üì• Export Document
                        </button>
                    </div>
                </div>

                <!-- Tab: Review AI Suggestions (V6) -->
                <div class="tab-content" id="tab-review" style="display: none;">
                    <div style="background: #FFF3CD; padding: 14px; border-radius: 6px; margin-bottom: 20px; border-left: 4px solid #FFC107;">
                        <strong>üìã Review AI Suggestions:</strong> Check items to keep in your final note, or uncheck to discard.
                        Linked suggestions have dependencies on other items.
                    </div>

                    <div id="reviewInterface" style="margin-bottom: 20px;">
                        <p style="color: #666; text-align: center; padding: 40px; font-style: italic;">
                            Generate a note with Enhanced Mode to see AI suggestions here.
                        </p>
                    </div>

                    <div style="margin-top: 20px; display: flex; gap: 12px; padding: 15px; background: #f6f8fa; border-radius: 6px;">
                        <button onclick="selectAllSuggestions()" class="success" style="flex: 1; padding: 12px;">
                            ‚úÖ Keep All
                        </button>
                        <button onclick="deselectAllSuggestions()" class="warning" style="flex: 1; padding: 12px;">
                            ‚ùå Discard All
                        </button>
                        <button onclick="generateFinalNote()" class="success" style="flex: 2; padding: 12px; font-weight: 600;">
                            üìÑ Generate Final Note
                        </button>
                    </div>
                </div>

                <!-- Tab: Attending Summary (Ultra Summarizer) -->
                <div class="tab-content" id="tab-attending">
                    <!-- Compression Mode Selector -->
                    <div style="background: #f5f5f5; padding: 16px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #ddd;">
                        <strong style="color: #333; font-size: 1.1rem;">‚ö° Compression Mode:</strong>
                        <div style="display: flex; gap: 15px; margin-top: 12px; flex-wrap: wrap;">
                            <label style="flex: 1; min-width: 200px; cursor: pointer; background: white; padding: 12px; border-radius: 6px; border: 2px solid #4CAF50; transition: all 0.2s;">
                                <input type="radio" name="compressionMode" value="standard" checked onchange="updateCompressionInfo()">
                                <strong style="color: #4CAF50;">üìä Standard DOAP</strong>
                                <span id="status-standard" style="margin-left: 8px; font-size: 0.75rem; padding: 2px 6px; border-radius: 3px; background: #e0e0e0; color: #666;">‚è≥ Pending</span>
                                <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">45 seconds (~120-140 words)</div>
                            </label>
                            <label style="flex: 1; min-width: 200px; cursor: pointer; background: white; padding: 12px; border-radius: 6px; border: 2px solid #FF5722; transition: all 0.2s;">
                                <input type="radio" name="compressionMode" value="ultra" onchange="updateCompressionInfo()">
                                <strong style="color: #FF5722;">‚ö° ULTRATHINK</strong>
                                <span id="status-ultra" style="margin-left: 8px; font-size: 0.75rem; padding: 2px 6px; border-radius: 3px; background: #e0e0e0; color: #666;">‚è≥ Pending</span>
                                <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">15 seconds (~35-50 words)</div>
                            </label>
                            <label style="flex: 1; min-width: 200px; cursor: pointer; background: white; padding: 12px; border-radius: 6px; border: 2px solid #9C27B0; transition: all 0.2s;">
                                <input type="radio" name="compressionMode" value="telegram" onchange="updateCompressionInfo()">
                                <strong style="color: #9C27B0;">üì± Telegram</strong>
                                <span id="status-telegram" style="margin-left: 8px; font-size: 0.75rem; padding: 2px 6px; border-radius: 3px; background: #e0e0e0; color: #666;">‚è≥ Pending</span>
                                <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">5 seconds (~15-25 words)</div>
                            </label>
                        </div>
                    </div>

                    <!-- Framework Info Display (changes based on mode) -->
                    <div id="compressionInfoBox" style="background: #e3f2fd; padding: 14px; border-radius: 6px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                        <strong>üìä DOAP Framework for Attending Presentation:</strong>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                            <li><strong>D</strong> - Diagnosis (5 sec): Age, Sex, PMHx, Primary diagnosis</li>
                            <li><strong>O</strong> - One-liner (10 sec): Exam findings + Imaging results</li>
                            <li><strong>A</strong> - Assessment (10 sec): Severity + Candidacy</li>
                            <li><strong>P</strong> - Plan (20 sec): Intervention + Timing + Main concern</li>
                        </ul>
                        <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 45-second presentation to impress attending staff</p>
                    </div>

                    <textarea id="attendingSummaryText"
                              style="width: 100%; min-height: 300px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 1rem; padding: 15px; border: 2px solid #2196F3; border-radius: 6px; line-height: 1.8; resize: vertical;"
                              placeholder="Attending summary will appear here after note generation..."></textarea>

                    <!-- Stats Display -->
                    <div style="display: flex; justify-content: space-around; margin-top: 12px; padding: 12px; background: #f9f9f9; border-radius: 6px;">
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #2196F3;" id="summaryWordCount">0</div>
                            <div style="font-size: 12px; color: #666;">Words</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #4CAF50;" id="summarySeconds">0</div>
                            <div style="font-size: 12px; color: #666;">Seconds</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #FF9800;" id="compressionRatio">0%</div>
                            <div style="font-size: 12px; color: #666;">Compression</div>
                        </div>
                    </div>

                    <div style="margin-top: 15px; display: flex; gap: 12px;">
                        <button onclick="testAttendingSummary()" style="flex: 1; padding: 12px; background: #FF9800; color: white;">
                            üß™ Test (Use Current Note)
                        </button>
                        <button onclick="copyAttendingSummary()" class="success" style="flex: 1; padding: 12px;">
                            üìã Copy Summary
                        </button>
                        <button onclick="regenerateAttendingSummary()" style="flex: 1; padding: 12px; background: #2196F3; color: white;">
                            üîÑ Regenerate
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Clinical Scales Database -->
    <script src="clinical-scales-database.js"></script>

    <script>
        // ============================================================
        // GLOBAL ERROR HANDLER
        // ============================================================
        window.addEventListener('error', function(e) {
            console.error('üö® JavaScript Error:', e.message, 'at', e.filename, ':', e.lineno);
            console.error('Stack:', e.error?.stack);
        });

        window.addEventListener('unhandledrejection', function(e) {
            console.error('üö® Unhandled Promise Rejection:', e.reason);
        });

        console.log('üöÄ NeuroScribe V7 - Professional Clinical Intelligence');
        console.log('üìÖ Loading at:', new Date().toLocaleString());

        // ============================================================
        // GLOBAL VARIABLES
        // ============================================================

        // Get API key from localStorage
        let API_KEY = null;
        let recognition = null;
        let isRecording = false;
        let isPaused = false;
        let startTime = null;
        let timerInterval = null;
        let confidenceScores = [];
        let selectedPathology = null;
        let activeRedFlags = [];

        // V5 Expert Analysis Variables
        let customPathology = '';
        let generatedBriefing = null;  // Stores full briefing text
        let briefingChecklist = null;  // Stores structured checklist
        let briefingUsed = false;      // Tracks if briefing was integrated

        // Clinical Scales Variables
        let currentScale = null;       // Currently selected scale object
        let scaleResponses = {};       // Stores all scale responses {scaleId: {questionId: value}}
        let calculatedScores = {};     // Stores calculated scores {scaleId: scoreObject}

        // Expert Document Upload Variables
        let uploadedDocuments = [];    // Stores uploaded document content
        let uploadedDocText = '';      // Combined text from all uploaded documents

        // Consultation Type Variable
        let consultationType = 'new';  // 'new' or 'followup'

        // SOAP Quick-Entry Variables
        let soapQuickEntry = {
            subjective: '',
            objective: '',
            assessment: '',
            plan: ''
        };
        let soapEnhanceMode = false;  // false = expand only, true = expand + analysis
        let activeInputPanel = 'transcript';  // 'transcript' or 'soap'

        // Transcript Enhancement Variable
        let transcriptEnhanceMode = false;  // false = expand only, true = enhanced with briefing

        // V6 Interactive Review System Variables
        let currentSuggestions = [];  // Stores parsed AI suggestions for review

        // Attending Summary Variables
        let lastGeneratedNote = '';  // Stores last generated note for attending summary

        // Compression Versions Storage (for auto-generated compressed/ultracompressed notes)
        let currentNoteVersions = {
            full: '',           // Full finalized note
            standard: '',       // Compressed: Standard DOAP (45 sec, ~120-140 words)
            ultra: '',          // Ultracompressed: ULTRATHINK (15 sec, ~35-50 words)
            telegram: '',       // Super-compressed: Telegram (5 sec, ~15-25 words)
            // Status tracking for UI indicators
            status: {
                standard: 'pending',  // 'pending', 'generating', 'ready', 'failed'
                ultra: 'pending',     // 'pending', 'generating', 'ready', 'failed'
                telegram: 'pending'   // 'pending', 'generating', 'ready', 'failed'
            }
        };

        // ============================================================
        // STARTUP VALIDATION
        // ============================================================
        function validateStartup() {
            console.log('üîç Running startup validation...');
            const criticalElements = [
                'settingsModal',
                'apiKeyInput',
                'apiKeyStatus',
                'status',
                'transcript',
                'generateBtn'
            ];

            let missingElements = [];
            for (const id of criticalElements) {
                const el = document.getElementById(id);
                if (!el) {
                    missingElements.push(id);
                    console.error(`‚ùå Missing critical element: #${id}`);
                } else {
                    console.log(`‚úÖ Element found: #${id}`);
                }
            }

            // Check if database loaded
            if (typeof ClinicalScalesDatabase === 'undefined') {
                console.error('‚ùå ClinicalScalesDatabase not loaded!');
                alert('Error: Clinical scales database failed to load. Please refresh the page.');
                return false;
            } else {
                console.log(`‚úÖ ClinicalScalesDatabase loaded (${Object.keys(ClinicalScalesDatabase).length} scales)`);
            }

            if (missingElements.length > 0) {
                console.warn(`‚ö†Ô∏è  ${missingElements.length} elements missing, but continuing...`);
            } else {
                console.log('‚úÖ All critical elements found');
            }

            return true;
        }

        // Pathology-Specific Knowledge Base
        const PathologyDatabase = {
            'spine-degenerative': {
                name: 'Degenerative Spine Disease',
                vocabulary: ['disc herniation', 'stenosis', 'spondylolisthesis', 'facet arthropathy',
                    'ligamentum flavum', 'foramen', 'lateral recess', 'myelopathy', 'radiculopathy',
                    'ACDF', 'TLIF', 'laminectomy', 'foraminotomy', 'corpectomy'],
                redFlags: ['cauda equina syndrome', 'progressive myelopathy', 'bowel/bladder dysfunction',
                    'saddle anesthesia', 'bilateral weakness', 'hyperreflexia', 'clonus',
                    'Hoffman sign positive', 'inverted radial reflex', 'gait instability'],
                examFindings: ['Spurling test', 'straight leg raise', 'crossed straight leg raise',
                    'femoral stretch test', 'Hoffman sign', 'Babinski', 'clonus testing',
                    'tandem gait', 'Romberg test', 'motor strength testing by myotome'],
                differentials: ['Central disc herniation', 'Foraminal stenosis', 'Central canal stenosis',
                    'Spondylolisthesis', 'Facet syndrome', 'SI joint dysfunction',
                    'Piriformis syndrome', 'Peripheral neuropathy', 'Vascular claudication'],
                workup: ['MRI spine without contrast', 'CT myelogram if MRI contraindicated',
                    'Flexion-extension X-rays for instability', 'EMG/NCS for radiculopathy',
                    'DEXA scan if considering fusion'],
                guidelines: ['NASS guidelines for lumbar disc herniation', 'AOSpine classification system',
                    'Meyerding classification for spondylolisthesis', 'Modic changes classification'],
                recommendedScales: ['mjoa', 'nurick', 'ndi', 'odi', 'vas_pain']
            },
            'spine-trauma': {
                name: 'Traumatic Spine Injury',
                vocabulary: ['burst fracture', 'compression fracture', 'chance fracture', 'odontoid fracture',
                    'Jefferson fracture', 'hangman fracture', 'TLICS score', 'SLIC score',
                    'ASIA grade', 'neurogenic shock', 'spinal shock', 'central cord syndrome'],
                redFlags: ['incomplete spinal cord injury', 'neurological deterioration', 'unstable fracture',
                    'epidural hematoma', 'expanding syrinx', 'vascular injury', 'CSF leak', 'autonomic dysreflexia'],
                examFindings: ['ASIA examination', 'rectal tone', 'bulbocavernosus reflex', 'priapism',
                    'diaphragmatic breathing', 'sensory level', 'zone of partial preservation'],
                differentials: ['Complete vs incomplete SCI', 'Central cord syndrome', 'Brown-Sequard syndrome',
                    'Anterior cord syndrome', 'Conus medullaris syndrome', 'Cauda equina syndrome'],
                workup: ['CT spine - urgent', 'MRI for ligamentous injury', 'CT angiogram for vertebral artery',
                    'Upright X-rays when stable', 'Urodynamics if neurogenic bladder'],
                guidelines: ['TLICS scoring system', 'SLIC scoring system', 'AOSpine classification',
                    'NASCIS protocols for steroids', 'ASIA impairment scale'],
                recommendedScales: ['gcs', 'odi', 'vas_pain']
            },
            'brain-tumor': {
                name: 'Brain Tumor',
                vocabulary: ['glioblastoma', 'astrocytoma', 'oligodendroglioma', 'ependymoma', 'meningioma',
                    'schwannoma', 'pituitary adenoma', 'craniopharyngioma', 'medulloblastoma',
                    'IDH mutation', 'MGMT methylation', '1p19q codeletion', 'BRAF mutation',
                    'gross total resection', 'subtotal resection', 'awake craniotomy'],
                redFlags: ['papilledema', 'Cushing triad', 'uncal herniation', 'midline shift',
                    'hydrocephalus', 'seizures', 'rapid neurological decline', 'hemorrhage into tumor'],
                examFindings: ['papilledema', 'visual field defects', 'cranial nerve palsies',
                    'pronator drift', 'aphasia', 'neglect', 'ataxia', 'nystagmus'],
                differentials: ['Primary brain tumor', 'Metastatic disease', 'Abscess', 'Demyelinating disease',
                    'Vascular malformation', 'Radiation necrosis', 'Tumefactive MS'],
                workup: ['MRI brain with and without contrast', 'MR spectroscopy', 'MR perfusion',
                    'PET scan for metastatic workup', 'Lumbar puncture if carcinomatous meningitis',
                    'Neuropsychological testing pre-op', 'fMRI for eloquent area mapping'],
                guidelines: ['WHO 2021 CNS tumor classification', 'RANO criteria', 'Stupp protocol for GBM',
                    'RTOG recursive partitioning analysis', 'Karnofsky performance scale'],
                recommendedScales: ['gcs', 'vas_pain']
            },
            'vascular': {
                name: 'Cerebrovascular Disease',
                vocabulary: ['subarachnoid hemorrhage', 'aneurysm', 'AVM', 'dural AVF', 'cavernoma',
                    'moyamoya', 'vasospasm', 'Hunt-Hess', 'Fisher grade', 'WFNS grade',
                    'coiling', 'clipping', 'flow diverter', 'pipeline', 'WEB device'],
                redFlags: ['thunderclap headache', 'decreased GCS', 'new focal deficit', 'seizure',
                    'vasospasm window day 3-14', 'rebleeding', 'hydrocephalus', 'herniation'],
                examFindings: ['neck stiffness', 'Kernig sign', 'Brudzinski sign', 'cranial nerve palsies',
                    'pupillary changes', 'motor deficits', 'altered mental status'],
                differentials: ['Aneurysmal SAH', 'Perimesencephalic SAH', 'Traumatic SAH', 'AVM rupture',
                    'Reversible cerebral vasoconstriction syndrome', 'Pituitary apoplexy'],
                workup: ['CT head non-contrast - urgent', 'CTA head and neck', 'Lumbar puncture if CT negative',
                    'DSA gold standard', 'Transcranial dopplers for vasospasm', 'EEG if seizure concern'],
                guidelines: ['AHA/ASA guidelines for aneurysmal SAH', 'Hunt-Hess grading', 'Fisher scale',
                    'WFNS grading', 'Spetzler-Martin AVM grading'],
                recommendedScales: ['gcs', 'vas_pain']
            },
            'hydrocephalus': {
                name: 'Hydrocephalus',
                vocabulary: ['communicating', 'non-communicating', 'normal pressure hydrocephalus', 'NPH triad',
                    'ventriculomegaly', 'transependymal flow', 'aqueductal stenosis', 'fourth ventricle outlet obstruction',
                    'VP shunt', 'VA shunt', 'ETV', 'third ventriculostomy', 'programmable valve'],
                redFlags: ['acute mental status change', 'Cushing triad', 'upward gaze palsy', 'papilledema',
                    'bradycardia', 'hypertension', 'irregular respirations', 'seizures'],
                examFindings: ['gait apraxia', 'urinary incontinence', 'cognitive decline', 'papilledema',
                    'sixth nerve palsy', 'Parinaud syndrome', 'setting sun sign'],
                differentials: ['NPH', 'Obstructive hydrocephalus', 'Ex-vacuo changes', 'Cerebral atrophy',
                    'Chronic subdural hematoma', 'Previous SAH', 'Meningitis sequelae'],
                workup: ['MRI brain with CSF flow study', 'High volume lumbar puncture test',
                    'Lumbar drain trial', 'ICP monitoring', 'Neuropsychological testing', 'Gait assessment pre/post LP'],
                guidelines: ['International NPH guidelines', 'ETV success score', 'Evans index',
                    'Callosal angle measurement', 'DESH findings'],
                recommendedScales: ['gcs']
            },
            'functional': {
                name: 'Functional Neurosurgery',
                vocabulary: ['essential tremor', 'Parkinson disease', 'dystonia', 'DBS', 'GPi', 'STN',
                    'VIM nucleus', 'frame-based', 'frameless', 'microelectrode recording',
                    'beta oscillations', 'levodopa response', 'UPDRS score'],
                redFlags: ['atypical parkinsonism', 'cognitive decline', 'psychiatric symptoms',
                    'medication refractory symptoms', 'severe dyskinesias', 'DBS hardware infection'],
                examFindings: ['resting tremor', 'bradykinesia', 'rigidity', 'postural instability',
                    'dystonic posturing', 'action tremor', 'intention tremor', 'pull test'],
                differentials: ['Parkinson disease', 'Essential tremor', 'Multiple system atrophy',
                    'Progressive supranuclear palsy', 'Corticobasal degeneration', 'Dystonia'],
                workup: ['MRI brain for DBS planning', 'DaTscan', 'Neuropsychological evaluation',
                    'Levodopa challenge test', 'UPDRS scoring', 'Video assessment'],
                guidelines: ['MDS clinical diagnostic criteria for PD', 'UPDRS scoring',
                    'Hoehn and Yahr staging', 'CAPSIT-PD protocol'],
                recommendedScales: ['vas_pain']
            },
            'pediatric': {
                name: 'Pediatric Neurosurgery',
                vocabulary: ['myelomeningocele', 'Chiari malformation', 'craniosynostosis', 'tethered cord',
                    'syrinx', 'encephalocele', 'Dandy-Walker', 'arachnoid cyst', 'hypothalamic hamartoma',
                    'cranial vault remodeling', 'duraplasty', 'detethering'],
                redFlags: ['increasing head circumference', 'bulging fontanelle', 'sunset eyes',
                    'developmental delay', 'regression of milestones', 'new onset seizures',
                    'stridor', 'apnea', 'failure to thrive'],
                examFindings: ['head circumference', 'fontanelle assessment', 'cranial sutures', 'primitive reflexes',
                    'developmental milestones', 'cutaneous stigmata', 'scoliosis check'],
                differentials: ['Chiari I vs II', 'Hydrocephalus', 'Benign enlargement of subarachnoid spaces',
                    'Craniosynostosis types', 'Tethered cord syndrome', 'Spinal dysraphism'],
                workup: ['MRI brain and spine', 'Cranial ultrasound if open fontanelle',
                    'CT head for craniosynostosis', 'Urodynamics for tethered cord',
                    'Sleep study for Chiari', 'Genetic testing if syndromic'],
                guidelines: ['Chiari malformation guidelines', 'Craniosynostosis classifications',
                    'Spina bifida management guidelines', 'Pediatric hydrocephalus consensus'],
                recommendedScales: ['gcs']
            },
            'peripheral': {
                name: 'Peripheral Nerve',
                vocabulary: ['carpal tunnel', 'cubital tunnel', 'thoracic outlet syndrome', 'peroneal palsy',
                    'meralgia paresthetica', 'nerve tumor', 'schwannoma', 'neurofibroma',
                    'nerve transfer', 'neurolysis', 'transposition', 'decompression'],
                redFlags: ['rapid progression', 'muscle wasting', 'complete nerve palsy',
                    'multiple nerve involvement', 'associated mass', 'malignant transformation'],
                examFindings: ['Tinel sign', 'Phalen test', 'Froment sign', 'Wartenberg sign',
                    'sensory distribution testing', 'two-point discrimination', 'muscle bulk', 'specific muscle testing'],
                differentials: ['Compression neuropathy', 'Peripheral neuropathy', 'Radiculopathy',
                    'Brachial plexopathy', 'Motor neuron disease', 'Nerve tumor'],
                workup: ['EMG/NCS', 'MRI for nerve visualization', 'Ultrasound for dynamic assessment',
                    'MR neurography', 'Laboratory studies for neuropathy'],
                guidelines: ['AAOS carpal tunnel guidelines', 'Peripheral nerve injury classification',
                    'Seddon and Sunderland classifications'],
                recommendedScales: ['vas_pain']
            }
        };

        // ============================================================
        // API KEY SETTINGS FUNCTIONS
        // ============================================================

        function openSettings() {
            try {
                console.log('üîß Opening settings modal...');
                const modal = document.getElementById('settingsModal');
                const input = document.getElementById('apiKeyInput');
                const statusDiv = document.getElementById('apiKeyStatusModal');

                if (!modal) {
                    console.error('‚ùå Settings modal element not found');
                    alert('Error: Settings modal not found. Please refresh the page.');
                    return;
                }

                if (!input) {
                    console.error('‚ùå API key input element not found');
                    return;
                }

                // Load existing key if available (show masked)
                if (API_KEY) {
                    input.value = API_KEY;
                    input.type = 'password';
                } else {
                    input.value = '';
                }

                if (statusDiv) {
                    statusDiv.style.display = 'none';
                }

                modal.style.display = 'flex';
                console.log('‚úÖ Settings modal opened');
            } catch (error) {
                console.error('‚ùå Error opening settings:', error);
                alert('Error opening settings. Please refresh the page and try again.');
            }
        }

        function closeSettings() {
            try {
                const modal = document.getElementById('settingsModal');
                if (modal) {
                    modal.style.display = 'none';
                    console.log('‚úÖ Settings modal closed');
                } else {
                    console.error('‚ùå Settings modal not found');
                }
            } catch (error) {
                console.error('‚ùå Error closing settings:', error);
            }
        }

        async function saveAPIKey() {
            try {
                console.log('üíæ Attempting to save API key...');
                const input = document.getElementById('apiKeyInput');

                if (!input) {
                    console.error('‚ùå API key input element not found');
                    alert('Error: Could not find API key input field');
                    return;
                }

                const statusDiv = document.getElementById('apiKeyStatusModal');
                const key = input.value.trim();

                // Validate input
                if (!key) {
                    showAPIKeyStatus('error', '‚ùå Please enter an API key');
                    return;
                }

                console.log('üîç Validating API key format...');

                if (!key.startsWith('AIza')) {
                    showAPIKeyStatus('error', '‚ùå Invalid API key format. Key should start with "AIza"');
                    return;
                }

                // Show testing status
                showAPIKeyStatus('info', '‚è≥ Testing API key...');
                console.log('üß™ Testing API key with Gemini API...');

                // Test the API key with a simple request
                const testResponse = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${key}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: 'Test' }]
                            }],
                            generationConfig: {
                                temperature: 0.3,
                                maxOutputTokens: 10
                            }
                        })
                    }
                );

                if (testResponse.ok) {
                    // API key is valid - save it
                    console.log('‚úÖ API key validated successfully');
                    const encrypted = btoa(key.split('').reverse().join(''));
                    localStorage.setItem('neuroscribe_gemini_key', encrypted);
                    localStorage.setItem('neuroscribe_provider', 'gemini');
                    API_KEY = key;

                    showAPIKeyStatus('success', '‚úÖ API key saved and verified! Reloading...');
                    updateAPIKeyStatus(true);

                    // Close modal and reload after 1 second
                    setTimeout(() => {
                        closeSettings();
                        location.reload();
                    }, 1500);

                } else {
                    const errorData = await testResponse.json().catch(() => ({}));
                    const errorMsg = errorData.error?.message || 'Invalid API key';
                    console.error('‚ùå API key test failed:', errorMsg);
                    showAPIKeyStatus('error', `‚ùå API key test failed: ${errorMsg}`);
                }

            } catch (error) {
                console.error('‚ùå Critical error in saveAPIKey:', error);
                showAPIKeyStatus('error', `‚ùå Error testing API key: ${error.message}`);
            }
        }

        function showAPIKeyStatus(type, message) {
            try {
                const statusDiv = document.getElementById('apiKeyStatusModal');

                if (!statusDiv) {
                    console.warn('‚ö†Ô∏è  API key status div not found, using console instead');
                    console.log(`${type.toUpperCase()}: ${message}`);
                    return;
                }

                statusDiv.style.display = 'block';

                const colors = {
                    success: { bg: '#d1fae5', border: '#10b981', color: '#065f46' },
                    error: { bg: '#fee2e2', border: '#dc2626', color: '#991b1b' },
                    info: { bg: '#dbeafe', border: '#4A90E2', color: '#1e40af' }
                };

                const color = colors[type] || colors.info;
                statusDiv.style.background = color.bg;
                statusDiv.style.borderLeft = `3px solid ${color.border}`;
                statusDiv.style.color = color.color;
                statusDiv.textContent = message;
            } catch (error) {
                console.error('‚ùå Error showing API key status:', error);
            }
        }

        function loadAPIKey() {
            try {
                console.log('üîç Checking for API key in localStorage...');
                const encrypted = localStorage.getItem('neuroscribe_gemini_key');
                console.log('Encrypted key:', encrypted ? `Found (${encrypted.length} chars)` : 'NULL');

                const statusEl = document.getElementById('status');

                if (encrypted) {
                    try {
                        API_KEY = atob(encrypted).split('').reverse().join('');
                        if (statusEl) {
                            statusEl.className = 'status connected';
                            statusEl.textContent = '‚úÖ API Key Loaded - Ready to Generate';
                        }
                        console.log('‚úÖ API key loaded:', API_KEY.substring(0, 15) + '...');
                        updateAPIKeyStatus(true);
                        return true;
                    } catch (e) {
                        console.error('‚ùå Failed to decrypt key:', e);
                        if (statusEl) {
                            statusEl.className = 'status disconnected';
                            statusEl.textContent = '‚ùå API Key Error - Click Settings';
                        }
                        updateAPIKeyStatus(false);
                    }
                }

                console.warn('‚ö†Ô∏è  No API key found in localStorage');
                if (statusEl) {
                    statusEl.className = 'status disconnected';
                    statusEl.innerHTML = '‚ùå No API Key - Click <strong>‚öôÔ∏è Settings</strong> to configure';
                }
                updateAPIKeyStatus(false);

                // Auto-open settings modal if no key found
                setTimeout(() => {
                    try {
                        openSettings();
                    } catch (e) {
                        console.error('‚ùå Error opening settings:', e);
                    }
                }, 1500);

                return false;
            } catch (error) {
                console.error('‚ùå Critical error in loadAPIKey:', error);
                return false;
            }
        }

        // Test API Key without saving
        async function testAPIKey() {
            const input = document.getElementById('apiKeyInput');
            const key = input.value.trim();

            if (!key) {
                showAPIKeyStatus('error', '‚ùå Please enter an API key to test');
                return;
            }

            if (!key.startsWith('AIza')) {
                showAPIKeyStatus('error', '‚ùå Invalid API key format');
                return;
            }

            showAPIKeyStatus('info', '‚è≥ Testing API key...');

            try {
                const testResponse = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${key}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: 'Test' }]
                            }],
                            generationConfig: {
                                temperature: 0.3,
                                maxOutputTokens: 10
                            }
                        })
                    }
                );

                if (testResponse.ok) {
                    showAPIKeyStatus('success', '‚úÖ API key is valid!');
                } else {
                    const errorData = await testResponse.json();
                    const errorMsg = errorData.error?.message || 'Invalid API key';
                    showAPIKeyStatus('error', `‚ùå Test failed: ${errorMsg}`);
                }
            } catch (error) {
                showAPIKeyStatus('error', `‚ùå Error: ${error.message}`);
            }
        }

        // Clear API Key from storage
        function clearAPIKey() {
            if (confirm('Are you sure you want to clear the saved API key?')) {
                localStorage.removeItem('neuroscribe_gemini_key');
                localStorage.removeItem('neuroscribe_provider');
                API_KEY = null;
                document.getElementById('apiKeyInput').value = '';
                showAPIKeyStatus('success', 'üóëÔ∏è API key cleared! Please enter a new key.');
                updateAPIKeyStatus(false);
            }
        }

        // Update API Key Status Indicator in Header
        function updateAPIKeyStatus(isValid) {
            const statusDiv = document.getElementById('apiKeyStatus');
            if (!statusDiv) return;

            if (isValid) {
                statusDiv.innerHTML = '‚úÖ <span style="color: #10b981;">API Key Active</span>';
            } else {
                statusDiv.innerHTML = '‚ùå <span style="color: #ef4444;">No API Key</span>';
            }
        }

        // Toggle Panel Collapse
        function togglePanel(panelId) {
            try {
                console.log(`üîÑ Toggling panel: ${panelId}`);
                const content = document.getElementById(`${panelId}-content`);
                const icon = document.getElementById(`${panelId}-icon`);

                if (!content) {
                    console.error(`‚ùå Panel content not found: ${panelId}-content`);
                    return;
                }

                if (!icon) {
                    console.error(`‚ùå Panel icon not found: ${panelId}-icon`);
                    return;
                }

                content.classList.toggle('collapsed');
                icon.classList.toggle('collapsed');

                // Save state to localStorage
                const isCollapsed = content.classList.contains('collapsed');
                localStorage.setItem(`panel_${panelId}_collapsed`, isCollapsed);

                console.log(`‚úÖ Panel ${panelId} is now ${isCollapsed ? 'collapsed' : 'expanded'}`);
            } catch (error) {
                console.error(`‚ùå Error toggling panel ${panelId}:`, error);
            }
        }

        // Restore panel states on load
        function restorePanelStates() {
            try {
                console.log('üîÑ Restoring panel states from localStorage...');
                ['briefing', 'transcript'].forEach(panelId => {
                    try {
                        const isCollapsed = localStorage.getItem(`panel_${panelId}_collapsed`) === 'true';
                        if (isCollapsed) {
                            const content = document.getElementById(`${panelId}-content`);
                            const icon = document.getElementById(`${panelId}-icon`);
                            if (content && icon) {
                                content.classList.add('collapsed');
                                icon.classList.add('collapsed');
                                console.log(`‚úÖ Panel ${panelId} restored as collapsed`);
                            }
                        } else {
                            console.log(`‚ÑπÔ∏è  Panel ${panelId} not collapsed`);
                        }
                    } catch (error) {
                        console.error(`‚ùå Error restoring panel ${panelId}:`, error);
                    }
                });
                console.log('‚úÖ Panel states restored');
            } catch (error) {
                console.error('‚ùå Error in restorePanelStates:', error);
            }
        }

        // Initialize Speech Recognition
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('‚ö†Ô∏è Speech recognition not supported in this browser. Please use Chrome, Edge, or Safari.');
                document.getElementById('startBtn').disabled = true;
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();

            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 3;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                console.log('üé§ Speech recognition started');
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    const confidence = event.results[i][0].confidence;

                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                        if (confidence) {
                            confidenceScores.push(confidence);
                            updateConfidence();
                        }
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (finalTranscript) {
                    const transcriptArea = document.getElementById('transcript');
                    transcriptArea.value += finalTranscript;
                    updateWordCount();

                    // Real-time monitoring
                    checkForRedFlags(finalTranscript);
                    checkForScaleComponents(finalTranscript);
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    alert('‚ùå Microphone access denied. Please allow microphone access in browser settings.');
                } else if (event.error === 'no-speech') {
                    console.log('No speech detected');
                } else {
                    alert(`Speech recognition error: ${event.error}`);
                }
            };

            recognition.onend = () => {
                if (isRecording && !isPaused) {
                    // Restart if still recording
                    recognition.start();
                } else {
                    console.log('üé§ Speech recognition ended');
                }
            };

            console.log('‚úÖ Speech recognition initialized');
        }

        function startRecording() {
            if (!recognition) {
                alert('Speech recognition not initialized');
                return;
            }

            isRecording = true;
            isPaused = false;
            startTime = Date.now();
            confidenceScores = [];

            try {
                recognition.start();
            } catch (e) {
                console.error('Failed to start recognition:', e);
            }

            // Update UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('status').className = 'status recording';
            document.getElementById('status').textContent = 'üî¥ Recording in progress...';

            // Start timer
            timerInterval = setInterval(updateDuration, 1000);
        }

        function stopRecording() {
            isRecording = false;
            isPaused = false;

            if (recognition) {
                recognition.stop();
            }

            // Update UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('status').className = 'status connected';
            document.getElementById('status').textContent = '‚úÖ Recording stopped - Ready to generate';

            // Stop timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function pauseRecording() {
            if (isPaused) {
                // Resume
                isPaused = false;
                recognition.start();
                document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
                document.getElementById('status').textContent = 'üî¥ Recording in progress...';
            } else {
                // Pause
                isPaused = true;
                recognition.stop();
                document.getElementById('pauseBtn').textContent = '‚ñ∂Ô∏è Resume';
                document.getElementById('status').textContent = '‚è∏Ô∏è Recording paused';
            }
        }

        function updateWordCount() {
            const text = document.getElementById('transcript').value;
            const words = text.trim().split(/\s+/).filter(w => w.length > 0);
            document.getElementById('wordCount').textContent = words.length;
        }

        function updateDuration() {
            if (!startTime) return;
            const elapsed = Date.now() - startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('duration').textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateConfidence() {
            if (confidenceScores.length === 0) {
                document.getElementById('confidence').textContent = '--';
                return;
            }
            const avg = confidenceScores.reduce((a, b) => a + b, 0) / confidenceScores.length;
            document.getElementById('confidence').textContent = Math.round(avg * 100) + '%';
        }

        function clearText() {
            if (confirm('Clear transcript?')) {
                document.getElementById('transcript').value = '';
                updateWordCount();
                confidenceScores = [];
                updateConfidence();
            }
        }

        // Pathology Selection
        function selectPathology(pathologyId) {
            selectedPathology = pathologyId;
            customPathology = ''; // Clear custom input when selecting preset
            document.getElementById('customPathology').value = '';

            // Update button states
            document.querySelectorAll('.pathology-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-pathology="${pathologyId}"]`).classList.add('active');

            // Enable briefing button
            document.getElementById('briefingBtn').disabled = false;

            // Update active red flags for monitoring
            if (PathologyDatabase[pathologyId]) {
                activeRedFlags = PathologyDatabase[pathologyId].redFlags;
                console.log(`‚úÖ Selected: ${PathologyDatabase[pathologyId].name}`);
                console.log(`üö® Monitoring ${activeRedFlags.length} red flags`);
            }
        }

        // Custom Pathology Input Handler
        function onCustomPathologyInput() {
            const input = document.getElementById('customPathology');
            customPathology = input.value.trim();

            if (customPathology.length > 3) {
                // Clear preset pathology selection
                selectedPathology = null;
                document.querySelectorAll('.pathology-btn').forEach(btn => {
                    btn.classList.remove('active');
                });

                // Enable briefing button
                document.getElementById('briefingBtn').disabled = false;

                // Clear red flags when using custom (will be generated)
                activeRedFlags = [];

                console.log(`‚úÖ Custom pathology entered: ${customPathology}`);
            } else if (customPathology.length === 0) {
                // Disable button if no input and no selection
                if (!selectedPathology) {
                    document.getElementById('briefingBtn').disabled = true;
                }
            }
        }

        // Generate Deep Briefing with Clinical Checklist
        async function generateDeepBriefing() {
            // Validate inputs
            if (!selectedPathology && !customPathology) {
                alert('Please enter a specific pathology or select a common category');
                return;
            }

            if (!API_KEY) {
                alert('API key not configured.');
                return;
            }

            const depth = document.getElementById('briefingDepth').value;
            const btn = document.getElementById('briefingBtn');
            const output = document.getElementById('briefingOutput');

            btn.disabled = true;
            btn.textContent = '‚è≥ Generating Deep Research...';
            output.innerHTML = '<p style="color: #999; text-align: center; padding: 30px;">Performing deep search and generating clinical checklist...</p>';

            try {
                // Determine pathology context
                let pathologyName, pathologyContext;

                if (customPathology) {
                    // Custom pathology - deep search mode
                    pathologyName = customPathology;
                    pathologyContext = `custom search for: ${customPathology}`;
                } else {
                    // Preset pathology - use database
                    const pathology = PathologyDatabase[selectedPathology];
                    pathologyName = pathology.name;
                    pathologyContext = `database-supported: ${pathology.name}`;
                }

                // Build depth-specific parameters
                const depthConfig = {
                    quick: { tokens: 2048, focus: 'essential checklist items', detail: 'concise' },
                    standard: { tokens: 4096, focus: 'comprehensive checklist with evidence', detail: 'detailed' },
                    comprehensive: { tokens: 8192, focus: 'exhaustive analysis with decision algorithms', detail: 'exhaustive' }
                };

                const config = depthConfig[depth];

                // Build additional context from uploaded documents
                let expertDocContext = '';
                if (uploadedDocText && uploadedDocText.trim().length > 0) {
                    expertDocContext = `\n\n=== UPLOADED EXPERT DOCUMENTS ===\nYou have been provided with ${uploadedDocuments.length} expert document(s) containing additional research, guidelines, or clinical information. Integrate this knowledge into your briefing:\n\n${uploadedDocText}\n\n=== END UPLOADED DOCUMENTS ===\n\nIMPORTANT: Synthesize information from the uploaded documents with your medical knowledge. Cite specific findings from the uploaded documents when relevant.\n\n`;
                }

                // Enhanced prompt for deep research + checklist
                const prompt = `You are a world-class neurosurgical consultant conducting deep research for a patient consultation on: ${pathologyName}
${expertDocContext}
Generate a ${config.detail} clinical briefing with an actionable checklist. Provide ${config.focus}.

${uploadedDocuments.length > 0 ? `üìö INTEGRATION NOTE: ${uploadedDocuments.length} expert document(s) uploaded. Please synthesize this additional information throughout your briefing.\n\n` : ''}Structure your response with these sections:

## üéØ Clinical Overview
- Pathophysiology and clinical significance
- Key anatomical considerations
- Common presentations and variants

## üìã CLINICAL CHECKLIST

### History Questions to Ask:
- [ ] [List 5-10 specific questions organized by system]

### Physical Examination Maneuvers:
- [ ] [List 5-10 specific exam techniques with interpretation]

### Critical Red Flags to Screen:
- [ ] [List 5-10 emergency warning signs requiring urgent intervention]

### Differential Diagnoses to Consider:
- [ ] [List 5-8 alternative diagnoses ranked by likelihood]

## üî¨ Diagnostic Workup

### First-Line Investigations:
- [ ] [List essential studies with rationale]

### Advanced/Specialized Testing:
- [ ] [List additional studies if first-line inconclusive]

### Laboratory Studies:
- [ ] [List relevant lab tests]

## üíé Evidence-Based Management

### Conservative Management Options:
- [Level I-V evidence citations]

### Surgical Indications:
- Absolute indications:
- Relative indications:

### Decision Algorithm:
- If [finding], then [action]
- [Provide step-by-step clinical decision tree]

## üìö Clinical Guidelines & Evidence
- [List relevant Level I-III evidence]
- [Citation to major guidelines]

## ‚ö†Ô∏è Complications & Risk Stratification
- Common complications to discuss
- Risk factors for poor outcomes

Make this actionable and ready to use during the patient consultation. Use checkboxes for items to verify.`;

                // Call Gemini API
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.4,  // Slightly higher for comprehensive research
                                maxOutputTokens: config.tokens
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                const briefingText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No briefing generated';

                // Store briefing data globally for integration
                generatedBriefing = briefingText;
                briefingUsed = false;  // Will be set to true when used in documentation

                // Extract checklist items for later use
                briefingChecklist = extractChecklistItems(briefingText);

                console.log(`‚úÖ Deep briefing generated for: ${pathologyName}`);
                console.log(`üìã Extracted ${briefingChecklist.length} checklist items`);

                // Convert markdown to HTML for display
                let html = briefingText
                    .replace(/^## (.+)$/gm, '<h3 style="color: #0066CC; margin-top: 15px; margin-bottom: 8px; font-size: 1rem;">$1</h3>')
                    .replace(/^### (.+)$/gm, '<h4 style="color: #333; margin-top: 12px; margin-bottom: 6px; font-size: 0.95rem; font-weight: 600;">$1</h4>')
                    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                    .replace(/^- \[ \] (.+)$/gm, '<div style="margin-left: 15px; margin-bottom: 5px;"><input type="checkbox" style="margin-right: 8px;">$1</div>')
                    .replace(/^- (.+)$/gm, '<div style="margin-left: 15px; margin-bottom: 5px;">‚Ä¢ $1</div>')
                    .replace(/\n\n/g, '<br>');

                output.innerHTML = html;

                // Update status to show briefing is ready
                const status = document.getElementById('status');
                status.className = 'status';
                status.style.background = '#d4edda';
                status.style.color = '#155724';
                status.textContent = '‚úÖ Deep briefing ready - Will be integrated with documentation';

                // Enable enhancement toggles now that briefing is available
                updateEnhancementToggles();

            } catch (error) {
                console.error('Deep briefing generation error:', error);
                output.innerHTML = `<p style="color: #DC143C; padding: 20px;">‚ùå Error: ${error.message}</p>`;
                alert(`Deep briefing generation failed: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üéØ Generate Deep Research + Checklist';
            }
        }

        // Extract checklist items from briefing text
        function extractChecklistItems(text) {
            const checklistItems = [];
            const lines = text.split('\n');

            for (const line of lines) {
                // Match checkbox items: - [ ] Item text
                const match = line.match(/^- \[ \] (.+)$/);
                if (match) {
                    checklistItems.push(match[1].trim());
                }
            }

            return checklistItems;
        }

        // Real-time Red Flag Monitoring
        function checkForRedFlags(text) {
            if (activeRedFlags.length === 0) return;

            const lowerText = text.toLowerCase();
            const detectedFlags = [];

            activeRedFlags.forEach(flag => {
                if (lowerText.includes(flag.toLowerCase())) {
                    detectedFlags.push(flag);
                }
            });

            if (detectedFlags.length > 0) {
                const transcriptArea = document.getElementById('transcript');
                const status = document.getElementById('status');

                // Visual alert
                transcriptArea.style.borderColor = '#DC143C';
                transcriptArea.style.borderWidth = '3px';

                // Update status
                status.className = 'status';
                status.style.background = '#f8d7da';
                status.style.color = '#721c24';
                status.textContent = `üö® RED FLAG DETECTED: ${detectedFlags.join(', ')}`;

                console.warn('üö® RED FLAGS DETECTED:', detectedFlags);

                // Reset border after 5 seconds
                setTimeout(() => {
                    transcriptArea.style.borderColor = '#ddd';
                    transcriptArea.style.borderWidth = '2px';
                    if (isRecording) {
                        status.className = 'status recording';
                        status.textContent = 'üî¥ Recording in progress...';
                    } else {
                        status.className = 'status connected';
                        status.textContent = '‚úÖ Ready to generate';
                    }
                }, 5000);
            }
        }

        async function generate() {
            // Detect which input mode is active
            const inputMode = detectActiveInputPanel();

            // Route to appropriate generation function
            if (inputMode === 'soap') {
                // Validate SOAP entry (async - supports parsing in simple mode)
                if (!await validateSOAPEntry()) {
                    return;
                }
                // Call SOAP generation
                await generateFromSOAP();
                return;
            }

            // Continue with transcript mode
            const transcript = document.getElementById('transcript').value.trim();

            if (!transcript) {
                alert('Please enter or record a clinical transcript first');
                return;
            }

            if (!API_KEY) {
                alert('API key not configured.');
                return;
            }

            const btn = document.getElementById('generateBtn');
            const status = document.getElementById('status');
            const output = document.getElementById('output');

            // V6: Reset review state for new generation
            currentSuggestions = [];
            const reviewTabButton = document.getElementById('review-tab-button');
            if (reviewTabButton) {
                reviewTabButton.style.display = 'none';
            }

            btn.disabled = true;
            btn.textContent = '‚è≥ Generating Expert Analysis...';
            status.className = 'status';
            status.style.background = '#d1ecf1';
            status.style.color = '#0c5460';

            // Check if briefing is available for integration
            const hasBriefing = generatedBriefing && generatedBriefing.length > 0;

            // Check enhancement mode toggle
            if (transcriptEnhanceMode && hasBriefing) {
                status.textContent = 'üîÑ Enhanced Mode: Briefing + Transcript ‚Üí Expert Analysis';
            } else {
                status.textContent = 'üîÑ Expand Only: Professional documentation from transcript';
            }

            try {
                let prompt;

                if (transcriptEnhanceMode && hasBriefing) {
                    // EXPERT MODE: Integrated briefing + transcript analysis (toggle ON + briefing available)
                    const pathologyData = selectedPathology ? PathologyDatabase[selectedPathology] : null;
                    const pathologyName = customPathology || (pathologyData ? pathologyData.name : 'Unknown');

                    // Build scale assessment section
                    let scaleAssessmentSection = '';
                    if (pathologyData && pathologyData.recommendedScales && pathologyData.recommendedScales.length > 0) {
                        const scaleNames = pathologyData.recommendedScales
                            .map(id => ClinicalScalesDatabase[id]?.shortName || id)
                            .join(', ');

                        scaleAssessmentSection = `\n### üìã Clinical Scales Assessment:\nRecommended scales for this pathology: ${scaleNames}\n\nFor each recommended scale, assess which components were addressed in the transcript and which are missing:\n`;

                        for (const scaleId of pathologyData.recommendedScales) {
                            const scale = ClinicalScalesDatabase[scaleId];
                            if (scale) {
                                scaleAssessmentSection += `\n**${scale.shortName}** (${scale.name}):\n`;
                                for (const q of scale.questions) {
                                    const questionText = q.text.length > 80 ? q.text.substring(0, 80) + '...' : q.text;
                                    scaleAssessmentSection += `- [ ] ${questionText}\n`;
                                }
                            }
                        }

                        scaleAssessmentSection += `\n‚ö†Ô∏è MISSING INFORMATION TO OBTAIN:\n[List specific scale questions that were NOT addressed in transcript and should be asked during follow-up]\n`;
                    }

                    prompt = `You are an expert neurosurgical consultant. Create a comprehensive consultation note from the transcript AND provide expert clinical analysis.

CRITICAL STRUCTURE REQUIREMENTS:

## SECTION 1: DOCUMENTED CONVERSATION
Start with what was actually said in the encounter:
üìù DOCUMENTED: [Professional narrative of the actual conversation - NO additions]

## SECTION 2: AI-GENERATED EXPERT ANALYSIS
After documented content, provide expert analysis wrapped in AI_SUGGESTION markers.

MARKER FORMAT EXAMPLES:

<!-- AI_SUGGESTION type="clinical-analysis" id="analysis-001" category="subjective" depends-on="" -->
ü§ñ CLINICAL ANALYSIS:
[Your expert interpretation of symptoms, patterns, temporal relationships]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="clinical-reasoning" id="reasoning-001" category="assessment" depends-on="analysis-001" -->
üß† DIAGNOSTIC REASONING:

**Hypothesis Generation:**
- Initial differential based on chief complaint: [List 3-5 hypotheses]
- Pre-test probabilities ranked: [Most likely ‚Üí Least likely with rationale]

**Data Interpretation:**
- Key positive findings supporting diagnosis:
  ‚Ä¢ [Finding 1] - Weight: High/Moderate/Low (likelihood ratio +X.X)
  ‚Ä¢ [Finding 2] - Weight: High/Moderate/Low
  ‚Ä¢ [Finding 3] - Weight: High/Moderate/Low
- Key negative findings against alternatives:
  ‚Ä¢ [Negative finding 1] - Rules out: [Alternative diagnosis]
  ‚Ä¢ [Negative finding 2] - Makes unlikely: [Alternative diagnosis]
- Discriminating features present: [Findings that narrow differential]

**Bayesian Reasoning:**
- Findings that significantly INCREASE probability:
  ‚Ä¢ [Finding] ‚Üí Increases likelihood by [X]% (LR+ = X.X)
  ‚Ä¢ [Finding] ‚Üí Strongly supports [diagnosis] (LR+ = X.X)
- Findings that significantly DECREASE probability:
  ‚Ä¢ [Absence of finding] ‚Üí Decreases likelihood by [X]% (LR- = 0.X)
  ‚Ä¢ [Negative finding] ‚Üí Argues against [diagnosis] (LR- = 0.X)

**Diagnostic Threshold Assessment:**
- Test threshold reached: [Yes/No with explanation]
  ‚Üí Additional testing needed: [Yes/No - specify tests]
- Treatment threshold reached: [Yes/No with explanation]
  ‚Üí Sufficient certainty to treat empirically: [Yes/No]
- Certainty level: [High (>90%) / Moderate (70-90%) / Low (<70%)]
  ‚Üí Basis for certainty: [Explain reasoning]

**Clinical Synthesis:**
[Summarize diagnostic reasoning in 2-3 sentences showing logical progression from symptoms ‚Üí findings ‚Üí diagnosis]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="differential" id="diff-001" category="assessment" depends-on="analysis-001,reasoning-001" -->
ü§ñ SYSTEMATIC DIFFERENTIAL DIAGNOSIS:

**PRIMARY DIAGNOSIS:**
1. **[Most Likely Diagnosis]** - Confidence: [High/Moderate/Low] ([X]%)
   - Supporting features (present):
     ‚Ä¢ [Feature 1 with specificity/sensitivity data]
     ‚Ä¢ [Feature 2]
     ‚Ä¢ [Feature 3]
   - Discriminating features: [Findings that distinguish from alternatives]
   - Epidemiological fit: [Age/gender/risk factor concordance - relevant/not relevant]
   - Timeline consistency: [Natural history alignment - consistent/atypical]
   - Against: [Any contradicting findings that don't fit]
   - Evidence base: [Cite relevant guidelines/studies if applicable]

**ALTERNATIVE DIAGNOSES (Ranked by Likelihood):**
2. **[Alternative 1]** - Confidence: [X]%
   - Why considered: [Key overlapping clinical features]
   - Why less likely: [Discriminating negatives or timeline issues]
   - Rule-out criteria: [What specific findings would exclude this diagnosis]

3. **[Alternative 2]** - Confidence: [X]%
   - Why considered: [Overlapping features]
   - Why less likely: [Key differences]
   - Rule-out criteria: [Exclusion criteria]

**MUST-NOT-MISS DIAGNOSES:**
‚ùó **[Dangerous diagnosis 1]** - Status: [Ruled out / Unlikely / Cannot exclude]
   - Ruled out by: [Specific findings/tests OR "Cannot exclude - needs further workup"]

‚ùó **[Dangerous diagnosis 2]** - Status: [Ruled out / Unlikely / Cannot exclude]
   - Ruled out by: [Specific findings/tests]

**RED FLAG DIFFERENTIAL:**
‚ö†Ô∏è Life-threatening conditions systematically screened:
- [ ] [Condition 1 (e.g., herniation, cauda equina)] - Status: [Ruled out / Possible / Confirmed]
      Evidence: [Specific exam findings or imaging]
- [ ] [Condition 2] - Status: [Ruled out / Possible / Confirmed]
      Evidence: [Findings]

**NEXT DIAGNOSTIC STEPS TO NARROW DIFFERENTIAL:**
- If [specific clinical finding present], then [specific action to favor diagnosis A over B]
- If [test result X], strongly favors [diagnosis Y] over [diagnosis Z] (sensitivity/specificity data)
- Key discriminating test needed: [Test name] - will differentiate between [diagnosis A vs B]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="red-flag" id="alert-001" category="assessment" depends-on="" -->
‚ö†Ô∏è RED FLAG ALERT:
[Critical findings requiring immediate attention]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="gap-analysis" id="gap-001" category="assessment" depends-on="" -->
ü§ñ CLINICAL GAPS IDENTIFIED:
Missing from history: [list]
Missing from exam: [list from briefing checklist]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="workup" id="workup-001" category="plan" depends-on="diff-001" -->
üî¨ RECOMMENDED DIAGNOSTIC WORKUP:
### Immediate/Urgent:
- [Studies with rationale]
### Standard:
- [Routine investigations from briefing]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="recommendation" id="rec-001" category="plan" depends-on="diff-001,workup-001" -->
üíä EVIDENCE-BASED MANAGEMENT PLAN:
### Conservative:
- [Options with evidence levels from briefing]
### Surgical Considerations:
- [If indications met per briefing]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="scales" id="scales-001" category="objective" depends-on="" -->
üìè CLINICAL SCALES ASSESSMENT:
${scaleAssessmentSection}
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="pearl" id="pearl-001" category="assessment" depends-on="" -->
üí° CLINICAL PEARL:
[Expert insight relevant to this presentation]
üìä Evidence Level: [I/II/III/IV from briefing]
<!-- /AI_SUGGESTION -->

MARKER RULES:
1. **Every AI-generated insight MUST be wrapped** in AI_SUGGESTION markers
2. **Use type attribute**: clinical-analysis, differential, recommendation, pearl, red-flag, gap-analysis, workup, scales
3. **Unique ID**: Use format type-### (e.g., diff-001, rec-002)
4. **Category**: subjective, objective, assessment, plan
5. **depends-on**: Comma-separated parent IDs if suggestion builds on others (empty string if independent)
6. **DO NOT wrap** üìù DOCUMENTED sections - only AI additions

=== PRE-CONSULTATION BRIEFING ===
${generatedBriefing}

Use this briefing to inform your expert analysis. Check for:
- Completeness of history/exam per briefing checklist
- Red flags identified or ruled out
- Evidence-based workup recommendations
- Pathology-specific management guidelines
- Clinical scales completion status

=== CLINICAL ENCOUNTER TRANSCRIPT ===
${transcript}

---
CONTEXT:
- Pathology Context: ${pathologyName}
- Evidence Base: Pre-consultation briefing available

ANTI-HALLUCINATION RULES:
‚úÖ Document actual conversation professionally in üìù DOCUMENTED
‚úÖ Provide expert analysis in marked AI_SUGGESTION blocks
‚úÖ Use briefing to inform analysis
‚úÖ Mark all suggestions properly with correct attributes
‚úÖ Link related suggestions with depends-on

‚ùå DO NOT add facts to üìù DOCUMENTED
‚ùå DO NOT modify what was actually said
‚ùå DO NOT forget markers on AI suggestions
‚ùå DO NOT create suggestions without proper type, id, category

Generate the comprehensive note with proper markers:`;

                } else {
                    // EXPAND ONLY MODE: Simple documentation (toggle OFF or no briefing)

                    // Check consultation type for appropriate prompt
                    if (consultationType === 'followup') {
                        // FOLLOW-UP VISIT EXPAND ONLY PROMPT
                        prompt = `You are a medical documentation assistant. Convert this follow-up visit transcript into professional clinical documentation.

CRITICAL RULES - WHAT YOU MUST DO:
‚úÖ Expand transcript into proper medical narrative format
‚úÖ Organize into standard follow-up visit structure
‚úÖ Use correct medical terminology and grammar
‚úÖ Expand common abbreviations appropriately

CRITICAL RULES - WHAT YOU MUST NOT DO:
‚ùå DO NOT add medical facts, symptoms, or findings not in transcript
‚ùå DO NOT infer or assume clinical information
‚ùå DO NOT add differential diagnoses beyond what clinician stated
‚ùå DO NOT add treatment recommendations not discussed
‚ùå DO NOT add examination findings not documented
‚ùå If information not mentioned, note "[Not documented]"

PROFESSIONAL LANGUAGE REQUIREMENTS:
‚úÖ Use precise medical terminology (avoid colloquialisms like "guy came in with")
‚úÖ Write in complete, grammatically correct sentences with proper medical narrative structure
‚úÖ Use standard medical abbreviations from Joint Commission approved list ONLY
‚úÖ Avoid ambiguous pronouns - use "the patient" consistently (not "he/she/they")
‚úÖ Use objective descriptors with measurements (not "seems somewhat" or "appears pretty")
‚úÖ Quantify whenever possible: pain 7/10 (not "severe pain"), weakness 4/5 (not "weak")
‚úÖ Use present tense for current status, past tense for historical information
‚úÖ Maintain professional clinical tone throughout (not conversational or casual)
‚úÖ Use patient-centered, non-stigmatizing language
‚ùå DO NOT use: casual language, ambiguous descriptors, dangerous abbreviations
‚ùå DO NOT use: judgmental language ("non-compliant" ‚Üí "did not adhere to treatment")
‚ùå DO NOT use: stigmatizing terms ("drug-seeking", "frequent flyer")

FOLLOW-UP VISIT FOCUS:
- Frame as INTERVAL HISTORY (changes since last visit)
- Document treatment response from transcript only
- Compare to baseline only if mentioned in transcript

# NEUROSURGICAL FOLLOW-UP NOTE

## INTERVAL HISTORY
[Document changes since last visit: symptoms better/worse/same, new developments, complications, medication compliance, therapy adherence]

## CURRENT SYMPTOMS
[Current symptom status with comparison to baseline if mentioned]
- Pain level: [Current vs previous]
- Functional status: [Current vs previous]
- New symptoms: [If any]

## MEDICATIONS & TREATMENTS
[Current medications with compliance, any changes, response to therapy]

## PHYSICAL EXAMINATION
**Updated Examination Findings:**
[Focus on relevant changes; state "unchanged from previous" if applicable]
- Neurological Examination:
  - Mental Status: [if assessed]
  - Motor: [any changes in strength, tone]
  - Sensory: [any changes]
  - Reflexes: [if assessed]
  - Gait: [if assessed]
  - Special tests: [if performed]

## DIAGNOSTIC RESULTS
[New imaging, labs, or studies since last visit with interpretation]

## ASSESSMENT
[Current status from transcript - improved/stable/worsened]
[Clinician's stated assessment from transcript only]

## PLAN
[Plan modifications from transcript ONLY - what was discussed]

## ICD-10 CODES
[Only if diagnosis clearly stated]

FINAL CHECK - CRITICAL:
‚úì Used ONLY information explicitly in transcript
‚úì Added NO medical facts or clinical information
‚úì Added NO treatment recommendations not discussed
‚úì Compared to baseline ONLY if mentioned in transcript
‚úì Professional language and organization from transcript content only

Transcript:
${transcript}`;

                    } else {
                        // NEW CONSULTATION EXPAND ONLY PROMPT
                        prompt = `You are a medical documentation assistant. Convert this clinical consultation transcript into professional clinical documentation.

CRITICAL RULES - WHAT YOU MUST DO:
‚úÖ Extract all information from transcript systematically
‚úÖ Organize into proper SOAP/consultation format
‚úÖ Use correct medical terminology and grammar
‚úÖ Expand common abbreviations appropriately
‚úÖ Maintain chronological narrative in HPI

CRITICAL RULES - WHAT YOU MUST NOT DO:
‚ùå DO NOT add medical facts, symptoms, or findings not in transcript
‚ùå DO NOT infer or assume clinical information
‚ùå DO NOT add differential diagnoses beyond what clinician stated
‚ùå DO NOT add workup studies not discussed in transcript
‚ùå DO NOT add treatment recommendations not mentioned
‚ùå DO NOT add examination findings not documented
‚ùå If information not mentioned, note "[Not documented]"

EXTRACTION REQUIREMENTS:
- Extract EVERY clinical detail mentioned in transcript
- Quantify when possible (pain scores, duration, frequency, ranges)
- Note temporal patterns (onset, progression, alleviating/aggravating factors)
- Document all examination findings with precise descriptions
- Identify any red flags or concerning features
- Note information gaps that should be obtained

# NEUROSURGICAL CONSULTATION NOTE

## CHIEF COMPLAINT
[Primary symptom or reason for visit - be specific and concise]

## HISTORY OF PRESENT ILLNESS
[Comprehensive narrative including: onset, location, duration, character, alleviating/aggravating factors, radiation, temporal pattern, associated symptoms, treatments tried, functional impact]

## PAST MEDICAL HISTORY
[List all conditions mentioned]

## PAST SURGICAL HISTORY
[List all surgeries with approximate dates if provided]

## MEDICATIONS
[List all medications with dosages if mentioned]

## ALLERGIES
[List drug/environmental allergies and reactions]

## PHYSICAL EXAMINATION
- **Vital Signs:** [Extract if mentioned]
- **General Appearance:** [Patient's overall presentation]
- **Neurological Examination:**
  - Mental Status: [Orientation, attention, memory]
  - Cranial Nerves: [I-XII assessment results]
  - Motor: [Strength by muscle group, tone, bulk]
  - Sensory: [Modalities tested and distributions]
  - Reflexes: [DTRs, pathological reflexes]
  - Cerebellar: [Coordination, dysmetria]
  - Gait: [Pattern, stability, aids needed]

## DIAGNOSTIC RESULTS
[Imaging, labs, EMG/NCS - extract findings if discussed]

## ASSESSMENT
[Clinician's stated diagnosis/impression from transcript - DO NOT add differential unless clinician discussed it]

## PLAN
[Management plan from transcript ONLY - DO NOT add recommendations not discussed]

## ICD-10 CODES
[Only if diagnosis clearly stated in transcript]

FINAL CHECK - CRITICAL:
‚úì Used ONLY information explicitly in transcript
‚úì Added NO medical facts, symptoms, or findings
‚úì Added NO differential diagnoses unless clinician stated them
‚úì Added NO treatment recommendations not discussed
‚úì Professional language and organization from transcript content only

Transcript:
${transcript}`;
                    }
                }

                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.4,  // Balanced: Maintains accuracy while improving narrative flow
                                maxOutputTokens: hasBriefing ? 16384 : 8192  // Double tokens for integrated analysis
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';

                output.value = generatedText;
                status.className = 'status connected';

                if (hasBriefing) {
                    briefingUsed = true;
                    status.textContent = '‚úÖ Expert Analysis Complete - Briefing + Transcript Integrated!';
                    console.log('‚úÖ Expert integrated analysis generated successfully');
                    console.log(`üìã Briefing checklist items: ${briefingChecklist.length}`);
                } else {
                    status.textContent = '‚úÖ Documentation Generated Successfully!';
                    console.log('‚úÖ Generated successfully (no briefing)');
                }

                // Update formatted output tab
                updateFormattedOutput(generatedText);

                // V6: Parse AI suggestions if in enhanced mode
                if (transcriptEnhanceMode && hasBriefing) {
                    currentSuggestions = parseAISuggestions(generatedText);

                    if (currentSuggestions.length > 0) {
                        displayReviewInterface(currentSuggestions);

                        // Show review tab button and switch to it
                        const reviewTabButton = document.getElementById('review-tab-button');
                        if (reviewTabButton) {
                            reviewTabButton.style.display = 'inline-block';
                        }

                        switchTab('review');
                        status.textContent = `‚úÖ Expert Analysis Complete! Review ${currentSuggestions.length} AI suggestions.`;
                        console.log(`üîç ${currentSuggestions.length} suggestions ready for review`);
                    } else {
                        // No suggestions found, show formatted view
                        switchTab('formatted');
                    }
                } else {
                    // Expand-only mode: go directly to formatted view
                    switchTab('formatted');
                }

                // Auto-generate compressed and ultracompressed summaries
                console.log('üìä Auto-generating compressed and ultracompressed summaries...');

                // Store the full note
                currentNoteVersions.full = generatedText;

                // Generate standard compression (independent)
                currentNoteVersions.status.standard = 'generating';
                updateCompressionStatusBadges();
                try {
                    const standardSummary = await generateAttendingSummary(generatedText);
                    currentNoteVersions.standard = standardSummary || '';
                    currentNoteVersions.status.standard = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Standard compression generated');
                } catch (standardError) {
                    console.error('‚ùå Standard compression failed:', standardError.message);
                    currentNoteVersions.standard = '‚ö†Ô∏è Standard compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.standard = 'failed';
                    updateCompressionStatusBadges();
                }

                // Generate ULTRA compression (independent)
                currentNoteVersions.status.ultra = 'generating';
                updateCompressionStatusBadges();
                try {
                    const ultraSummary = await generateUltraAttendingSummary(generatedText);
                    currentNoteVersions.ultra = ultraSummary || '';
                    currentNoteVersions.status.ultra = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ ULTRA compression generated');
                } catch (ultraError) {
                    console.error('‚ùå ULTRA compression failed:', ultraError.message);
                    currentNoteVersions.ultra = '‚ö†Ô∏è ULTRA compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.ultra = 'failed';
                    updateCompressionStatusBadges();
                }

                // Generate Telegram compression (independent)
                currentNoteVersions.status.telegram = 'generating';
                updateCompressionStatusBadges();
                try {
                    const telegramSummary = await generateTelegramSummary(generatedText);
                    currentNoteVersions.telegram = telegramSummary || '';
                    currentNoteVersions.status.telegram = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Telegram compression generated');
                } catch (telegramError) {
                    console.error('‚ùå Telegram compression failed:', telegramError.message);
                    currentNoteVersions.telegram = '‚ö†Ô∏è Telegram compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.telegram = 'failed';
                    updateCompressionStatusBadges();
                }

                // Display based on currently selected compression mode
                const selectedMode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
                const summaryToDisplay = selectedMode === 'ultra' ? currentNoteVersions.ultra
                                       : selectedMode === 'telegram' ? currentNoteVersions.telegram
                                       : currentNoteVersions.standard;

                if (summaryToDisplay && !summaryToDisplay.includes('failed')) {
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else if (summaryToDisplay) {
                    // Show error message in textarea
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else {
                    console.warn('‚ö†Ô∏è No summary generated');
                }

            } catch (error) {
                console.error('Generation error:', error);
                output.value = `‚ùå Error: ${error.message}`;
                status.className = 'status disconnected';
                status.textContent = '‚ùå Generation Failed';
                alert(`Generation failed: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.textContent = hasBriefing ? '‚ö° Generate Expert Analysis' : '‚ö° Generate Clinical Note';
            }
        }

        /**
         * Generate clinical note from SOAP quick-entry
         */
        async function generateFromSOAP() {
            if (!API_KEY) {
                alert('API key not configured.');
                return;
            }

            const btn = document.getElementById('generateBtn');
            const status = document.getElementById('status');
            const output = document.getElementById('output');

            // V6: Reset review state for new generation
            currentSuggestions = [];
            const reviewTabButton = document.getElementById('review-tab-button');
            if (reviewTabButton) {
                reviewTabButton.style.display = 'none';
            }

            btn.disabled = true;
            btn.textContent = '‚è≥ Generating from SOAP entry...';
            status.className = 'status';
            status.style.background = '#d1ecf1';
            status.style.color = '#0c5460';

            const hasBriefing = generatedBriefing && generatedBriefing.length > 0;

            if (soapEnhanceMode && hasBriefing) {
                status.textContent = 'üîÑ Enhanced mode: Expanding + Adding clinical analysis from briefing...';
            } else if (soapEnhanceMode) {
                status.textContent = 'üîÑ Enhanced mode: Expanding + General clinical analysis...';
            } else {
                status.textContent = 'üîÑ Expand mode: Professional writing only (no added facts)...';
            }

            try {
                let prompt;

                if (soapEnhanceMode) {
                    // ========================================
                    // MODE 2: ENHANCED (Expand + Analysis)
                    // ========================================

                    const pathologyData = selectedPathology ? PathologyDatabase[selectedPathology] : null;
                    const pathologyName = customPathology || (pathologyData ? pathologyData.name : 'General');

                    // Build scale recommendation section if pathology selected
                    let scaleRecommendation = '';
                    if (pathologyData && pathologyData.recommendedScales && pathologyData.recommendedScales.length > 0) {
                        const scaleNames = pathologyData.recommendedScales
                            .map(id => ClinicalScalesDatabase[id]?.shortName || id)
                            .join(', ');
                        scaleRecommendation = `\n## ü§ñ RECOMMENDED CLINICAL SCALES\nFor comprehensive assessment of ${pathologyName}, consider:\n${scaleNames}\n\n(These can be completed in the Clinical Scales tab)`;
                    }

                    prompt = `You are an expert neurosurgical consultant analyzing a clinical case. You will receive:
1. CLINICIAN'S SOAP NOTES (user's documented facts)
2. PRE-CONSULTATION BRIEFING (relevant medical context)

Your task: Generate a comprehensive clinical note that expands the brief SOAP notes AND provides expert clinical analysis.

CRITICAL STRUCTURE REQUIREMENTS:

## SECTION 1: USER'S DOCUMENTED FACTS
Always start with the clinician's documented observations marked as:
üìù DOCUMENTED: [Expand the user's SOAP notes professionally - NO additions, NO inferences]

## SECTION 2: AI-GENERATED EXPERT ANALYSIS
After documented facts, provide expert analysis wrapped in AI_SUGGESTION markers:

<!-- AI_SUGGESTION type="clinical-analysis" id="analysis-001" category="subjective" depends-on="" -->
ü§ñ CLINICAL ANALYSIS:
[Your expert interpretation of symptoms, patterns, temporal relationships]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="differential" id="diff-001" category="assessment" depends-on="analysis-001" -->
ü§ñ DIFFERENTIAL DIAGNOSIS:
1. **Most Likely:** [Diagnosis] - Confidence: High/Moderate/Low
   - Supporting: [specific findings]
   - Against: [contradicting findings]
2. **Alternative:** [Diagnosis] - Confidence: [level]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="red-flag" id="alert-001" category="assessment" depends-on="" -->
‚ö†Ô∏è RED FLAG ALERT:
[Critical findings requiring immediate attention]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="gap-analysis" id="gap-001" category="assessment" depends-on="" -->
ü§ñ CLINICAL GAPS IDENTIFIED:
Missing from history: [list]
Missing from exam: [list]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="workup" id="workup-001" category="plan" depends-on="diff-001" -->
üî¨ RECOMMENDED DIAGNOSTIC WORKUP:
### Imaging:
- [Specific study] - Rationale: [why]
### Laboratory:
- [Specific test] - Rationale: [why]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="recommendation" id="rec-001" category="plan" depends-on="diff-001,workup-001" -->
üíä EVIDENCE-BASED MANAGEMENT PLAN:
### Conservative:
- [Specific intervention] - Evidence: [level]
### Surgical Considerations:
- [If indicated, specific approach]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="scales" id="scales-001" category="objective" depends-on="" -->
üìè CLINICAL SCALES ASSESSMENT:
[Apply relevant scales from briefing - mJOA, Nurick, etc.]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="pearl" id="pearl-001" category="assessment" depends-on="" -->
üí° CLINICAL PEARL:
[Evidence-based insight or teaching point]
üìä Evidence Level: [I/II/III/IV]
<!-- /AI_SUGGESTION -->

MARKER RULES:
1. **Every AI-generated insight MUST be wrapped** in AI_SUGGESTION markers
2. **Use type attribute**: clinical-analysis, differential, recommendation, pearl, red-flag, gap-analysis, workup, scales
3. **Unique ID**: Use format type-### (e.g., diff-001, rec-002)
4. **Category**: subjective, objective, assessment, plan
5. **depends-on**: Comma-separated parent IDs if suggestion builds on others (empty string if independent)
6. **DO NOT wrap** üìù DOCUMENTED sections - only AI additions

${hasBriefing ?
`=== PRE-CONSULTATION BRIEFING ===
${generatedBriefing}

Use this briefing to inform your expert analysis. Check for:
- Completeness of history/exam per briefing checklist
- Red flags identified or ruled out
- Evidence-based workup recommendations
- Pathology-specific management guidelines
` : ''}

CLINICIAN'S SOAP HEADNOTES:

=== SUBJECTIVE ===
${soapQuickEntry.subjective || '[Not documented]'}

=== OBJECTIVE ===
${soapQuickEntry.objective || '[Not documented]'}

=== ASSESSMENT ===
${soapQuickEntry.assessment || '[Not documented]'}

=== PLAN ===
${soapQuickEntry.plan || '[Not documented]'}

---
CONTEXT:
- Consultation Type: ${consultationType === 'followup' ? 'Follow-up Visit' : 'New Consultation'}
- Pathology Context: ${pathologyName}
${hasBriefing ? '- Evidence Base: Pre-consultation briefing available' : ''}

${scaleRecommendation}

ANTI-HALLUCINATION RULES:
‚úÖ Expand user's notes professionally in üìù DOCUMENTED section
‚úÖ Provide expert analysis in marked AI_SUGGESTION blocks
‚úÖ Use briefing/pathology database to inform analysis
‚úÖ Mark all suggestions with proper attributes

‚ùå DO NOT add facts to üìù DOCUMENTED sections
‚ùå DO NOT modify user's observations
‚ùå DO NOT create findings not stated by clinician
‚ùå DO NOT forget to wrap suggestions in markers

Generate the comprehensive clinical note now with proper markers:`;

                } else {
                    // ========================================
                    // MODE 1: EXPAND ONLY (No Analysis)
                    // ========================================

                    prompt = `You are a medical documentation assistant. Your ONLY job is to convert the clinician's brief SOAP headnotes into professionally written clinical documentation.

CRITICAL RULES - WHAT YOU MUST DO:
‚úÖ Convert brief notes into proper medical narrative style
‚úÖ Organize information logically within each SOAP section
‚úÖ Use correct medical terminology and grammar
‚úÖ Expand common abbreviations appropriately (e.g., "x" ‚Üí "for", "F/U" ‚Üí "follow-up")
‚úÖ Maintain professional tone

CRITICAL RULES - WHAT YOU MUST NOT DO:
‚ùå DO NOT add medical facts, symptoms, or findings not stated by clinician
‚ùå DO NOT infer or assume clinical information
‚ùå DO NOT add differential diagnoses unless explicitly stated
‚ùå DO NOT suggest treatments or workup not mentioned
‚ùå DO NOT add physical exam findings not documented
‚ùå DO NOT fabricate history details
‚ùå If a section is empty, note "[Not documented]" - do not add content

CLINICIAN'S HEADNOTES:

=== SUBJECTIVE ===
${soapQuickEntry.subjective || '[Not documented]'}

=== OBJECTIVE ===
${soapQuickEntry.objective || '[Not documented]'}

=== ASSESSMENT ===
${soapQuickEntry.assessment || '[Not documented]'}

=== PLAN ===
${soapQuickEntry.plan || '[Not documented]'}

---
CONSULTATION TYPE: ${consultationType === 'followup' ? 'Follow-up Visit' : 'New Consultation'}

TASK: Expand these notes into professional clinical documentation using standard ${consultationType === 'followup' ? 'follow-up visit' : 'consultation'} format.

${consultationType === 'followup' ?
`For follow-up visits:
- Frame Subjective as "INTERVAL HISTORY" (changes since last visit)
- Focus on treatment response and progression
- Compare to baseline when clinician mentioned it
` :
`For new consultations:
- Use comprehensive SOAP format
- Maintain chronological narrative in HPI
- Organize exam findings systematically
`}

# CLINICAL NOTE

## ${consultationType === 'followup' ? 'INTERVAL HISTORY' : 'SUBJECTIVE / HISTORY'}
[Professional narrative based ONLY on clinician's subjective notes above - expand grammar and organization but add NO new medical facts]

## OBJECTIVE
[Organized examination findings based ONLY on clinician's objective notes above - use proper medical terminology but add NO new findings]

## ASSESSMENT
[Professional impression based ONLY on clinician's assessment notes above - add NO new diagnoses or analysis]

## PLAN
[Organized management plan based ONLY on clinician's plan notes above - add NO new treatments or recommendations]

## ICD-10 CODES
[Only if diagnosis clearly stated in assessment above]

FINAL CHECK:
‚úì Used only information explicitly provided by clinician
‚úì Added no medical facts or clinical reasoning
‚úì Professional language and organization
‚úì Appropriate medical terminology`;
                }

                // Call Gemini API
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: soapEnhanceMode ? 0.4 : 0.2,  // Lower temp for expand-only
                                maxOutputTokens: soapEnhanceMode && hasBriefing ? 12288 : 8192
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';

                output.value = generatedText;
                status.className = 'status connected';

                if (soapEnhanceMode) {
                    status.textContent = '‚úÖ Enhanced SOAP Note Generated!';
                    console.log('‚úÖ SOAP Enhanced mode generation complete');
                } else {
                    status.textContent = '‚úÖ SOAP Note Expanded!';
                    console.log('‚úÖ SOAP Expand-only mode generation complete');
                }

                // Update formatted output tab
                updateFormattedOutput(generatedText);

                // V6: Parse AI suggestions if in enhanced mode
                if (soapEnhanceMode) {
                    currentSuggestions = parseAISuggestions(generatedText);

                    if (currentSuggestions.length > 0) {
                        displayReviewInterface(currentSuggestions);

                        // Show review tab button and switch to it
                        const reviewTabButton = document.getElementById('review-tab-button');
                        if (reviewTabButton) {
                            reviewTabButton.style.display = 'inline-block';
                        }

                        switchTab('review');
                        status.textContent = `‚úÖ Enhanced Note Generated! Review ${currentSuggestions.length} AI suggestions.`;
                        console.log(`üîç ${currentSuggestions.length} suggestions ready for review`);
                    } else {
                        // No suggestions found, show formatted view
                        switchTab('formatted');
                    }
                } else {
                    // Expand-only mode: go directly to formatted view
                    switchTab('formatted');
                }

                // Auto-generate compressed and ultracompressed summaries
                console.log('üìä Auto-generating compressed and ultracompressed summaries...');

                // Store the full note
                currentNoteVersions.full = generatedText;

                // Generate standard compression (independent)
                currentNoteVersions.status.standard = 'generating';
                updateCompressionStatusBadges();
                try {
                    const standardSummary = await generateAttendingSummary(generatedText);
                    currentNoteVersions.standard = standardSummary || '';
                    currentNoteVersions.status.standard = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Standard compression generated');
                } catch (standardError) {
                    console.error('‚ùå Standard compression failed:', standardError.message);
                    currentNoteVersions.standard = '‚ö†Ô∏è Standard compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.standard = 'failed';
                    updateCompressionStatusBadges();
                }

                // Generate ULTRA compression (independent)
                currentNoteVersions.status.ultra = 'generating';
                updateCompressionStatusBadges();
                try {
                    const ultraSummary = await generateUltraAttendingSummary(generatedText);
                    currentNoteVersions.ultra = ultraSummary || '';
                    currentNoteVersions.status.ultra = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ ULTRA compression generated');
                } catch (ultraError) {
                    console.error('‚ùå ULTRA compression failed:', ultraError.message);
                    currentNoteVersions.ultra = '‚ö†Ô∏è ULTRA compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.ultra = 'failed';
                    updateCompressionStatusBadges();
                }

                // Generate Telegram compression (independent)
                currentNoteVersions.status.telegram = 'generating';
                updateCompressionStatusBadges();
                try {
                    const telegramSummary = await generateTelegramSummary(generatedText);
                    currentNoteVersions.telegram = telegramSummary || '';
                    currentNoteVersions.status.telegram = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Telegram compression generated');
                } catch (telegramError) {
                    console.error('‚ùå Telegram compression failed:', telegramError.message);
                    currentNoteVersions.telegram = '‚ö†Ô∏è Telegram compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.telegram = 'failed';
                    updateCompressionStatusBadges();
                }

                // Display based on currently selected compression mode
                const selectedMode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
                const summaryToDisplay = selectedMode === 'ultra' ? currentNoteVersions.ultra
                                       : selectedMode === 'telegram' ? currentNoteVersions.telegram
                                       : currentNoteVersions.standard;

                if (summaryToDisplay && !summaryToDisplay.includes('failed')) {
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else if (summaryToDisplay) {
                    // Show error message in textarea
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else {
                    console.warn('‚ö†Ô∏è No summary generated');
                }

            } catch (error) {
                console.error('‚ùå SOAP generation error:', error);
                output.value = `‚ùå Error: ${error.message}`;
                status.className = 'status disconnected';
                status.textContent = '‚ùå Generation Failed';
                alert(`SOAP generation failed: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.textContent = '‚ö° Generate Clinical Note';
            }
        }

        function copyOutput() {
            const output = document.getElementById('output');
            output.select();
            document.execCommand('copy');
            alert('‚úÖ Copied to clipboard!');
        }

        function downloadOutput() {
            const text = document.getElementById('output').value;
            if (!text) {
                alert('No content to download');
                return;
            }

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Tab Navigation Functions
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Find and activate the correct tab button
            const targetButton = document.getElementById(`${tabName}-tab-button`) ||
                                 document.querySelector(`button[onclick*="switchTab('${tabName}')"]`);
            if (targetButton) {
                targetButton.classList.add('active');
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            const targetTab = document.getElementById(`tab-${tabName}`);
            if (targetTab) {
                targetTab.classList.add('active');
            } else {
                console.error(`‚ùå Tab not found: tab-${tabName}`);
            }
        }

        function copyFormatted() {
            const formattedText = document.getElementById('formattedOutput').innerText;
            if (!formattedText || formattedText.includes('Generate documentation')) {
                alert('No content to copy');
                return;
            }
            navigator.clipboard.writeText(formattedText);
            alert('‚úÖ Copied formatted text to clipboard!');
        }

        function printFormatted() {
            const content = document.getElementById('formattedOutput').innerHTML;
            if (!content || content.includes('Generate documentation')) {
                alert('No content to print');
                return;
            }

            const printWindow = window.open('', '', 'width=800,height=600');
            printWindow.document.write(`
                <html>
                <head>
                    <title>Clinical Note</title>
                    <style>
                        body { font-family: Georgia, serif; line-height: 1.6; padding: 40px; }
                        h1 { color: #333; border-bottom: 2px solid #0066CC; padding-bottom: 10px; }
                        h2 { color: #0066CC; margin-top: 20px; }
                        h3 { color: #333; margin-top: 15px; }
                    </style>
                </head>
                <body>${content}</body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        }

        function doExport() {
            const format = document.getElementById('exportFormat').value;
            const includes = document.getElementById('exportIncludes').value;
            const rawText = document.getElementById('output').value;

            if (!rawText) {
                alert('No content to export. Generate documentation first.');
                return;
            }

            let content = rawText;

            // Filter content based on selection
            if (includes === 'summary') {
                // Extract summary sections only
                const sections = ['CHIEF COMPLAINT', 'HISTORY OF PRESENT ILLNESS', 'ASSESSMENT'];
                content = extractSections(rawText, sections);
            } else if (includes === 'plan') {
                // Extract assessment and plan only
                const sections = ['ASSESSMENT', 'PLAN', 'ICD-10'];
                content = extractSections(rawText, sections);
            }

            // Export based on format
            switch (format) {
                case 'txt':
                    downloadAsText(content);
                    break;
                case 'html':
                    downloadAsHTML(content);
                    break;
                case 'json':
                    downloadAsJSON(content);
                    break;
                case 'docx':
                    alert('DOCX export requires additional library. Use HTML or TXT for now.');
                    break;
                case 'pdf':
                    alert('PDF export requires additional library. Use Print to PDF from browser for now.');
                    break;
            }
        }

        function extractSections(text, sectionNames) {
            let result = '';
            const lines = text.split('\n');
            let capturing = false;

            for (const line of lines) {
                const isHeader = sectionNames.some(section => line.includes(section));
                if (isHeader) {
                    capturing = true;
                }
                if (capturing) {
                    result += line + '\n';
                }
            }

            return result || text;
        }

        function downloadAsText(content) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadAsHTML(content) {
            const html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Clinical Note</title>
    <style>
        body { font-family: Georgia, serif; line-height: 1.6; max-width: 800px; margin: 40px auto; padding: 20px; }
        h1 { color: #333; border-bottom: 2px solid #0066CC; padding-bottom: 10px; }
        h2 { color: #0066CC; margin-top: 20px; }
        h3 { color: #333; margin-top: 15px; }
        pre { white-space: pre-wrap; font-family: inherit; }
    </style>
</head>
<body>
    <pre>${content}</pre>
</body>
</html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadAsJSON(content) {
            // Prepare scale data for export
            const scaleData = {};
            for (const scaleId in calculatedScores) {
                const score = calculatedScores[scaleId];
                const scale = ClinicalScalesDatabase[scaleId];
                if (scale) {
                    scaleData[scaleId] = {
                        scaleName: scale.name,
                        shortName: scale.shortName,
                        score: score,
                        responses: scaleResponses[scaleId] || {},
                        interpretation: scale.interpretation ?
                            (scaleId === 'ndi' || scaleId === 'odi' ? scale.interpretation(score.percentage) :
                             scaleId === 'vas_pain' ? scale.interpretation(score.overallAverage) :
                             scale.interpretation(score.total)) : null,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            const jsonData = {
                timestamp: new Date().toISOString(),
                generatedBy: 'NeuroScribe V7 - Professional Clinical Intelligence',
                pathology: selectedPathology,
                briefingUsed: briefingUsed,
                clinicalNote: content,
                wordCount: content.split(/\s+/).length,
                clinicalScales: scaleData,
                scalesSummary: {
                    totalScalesCompleted: Object.keys(calculatedScores).length,
                    scalesAssessed: Object.keys(calculatedScores)
                }
            };

            const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function updateFormattedOutput(markdown) {
            // Convert markdown to HTML with enhanced clinical highlighting
            let html = markdown
                .replace(/^# (.+)$/gm, '<h1>$1</h1>')
                .replace(/^## (.+)$/gm, '<h2>$1</h2>')
                .replace(/^### (.+)$/gm, '<h3>$1</h3>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')

                // Highlight expert analysis sections (V5 specific)
                .replace(/## üìã BRIEFING-TRANSCRIPT INTEGRATION ANALYSIS/gi,
                    '<h2 style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üìã BRIEFING-TRANSCRIPT INTEGRATION ANALYSIS</h2>')

                .replace(/## üéØ EXPERT DIFFERENTIAL DIAGNOSIS/gi,
                    '<h2 style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üéØ EXPERT DIFFERENTIAL DIAGNOSIS</h2>')

                .replace(/## üí° ASSESSMENT & SYNTHESIS/gi,
                    '<h2 style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üí° ASSESSMENT & SYNTHESIS</h2>')

                .replace(/## üìä QUALITY METRICS/gi,
                    '<h2 style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üìä QUALITY METRICS</h2>')

                // Highlight clinical pearls
                .replace(/üíé CLINICAL PEARL:([^<\n]+)/gi,
                    '<div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin: 10px 0; border-radius: 4px;"><strong>üíé CLINICAL PEARL:</strong>$1</div>')

                // Highlight red flags
                .replace(/‚ö†Ô∏è RED FLAG:([^<\n]+)/gi,
                    '<div style="background: #f8d7da; border-left: 4px solid #dc3545; padding: 10px; margin: 10px 0; border-radius: 4px;"><strong>‚ö†Ô∏è RED FLAG:</strong>$1</div>')

                // Highlight evidence levels
                .replace(/üìä Level (I{1,3}|IV|V) Evidence:([^<\n]+)/gi,
                    '<div style="background: #d1ecf1; border-left: 4px solid #0c5460; padding: 8px; margin: 8px 0; border-radius: 4px; font-size: 0.95rem;"><strong>üìä Level $1 Evidence:</strong>$2</div>')

                // Highlight confidence levels
                .replace(/Confidence level: (High|Medium|Low)/gi,
                    '<span style="background: #e3f2fd; padding: 4px 8px; border-radius: 4px; font-weight: 600; color: #0066CC;">Confidence: $1</span>')

                .replace(/\n/g, '<br>');

            document.getElementById('formattedOutput').innerHTML = html;
        }

        // ============================================================
        // EXPERT DOCUMENT UPLOAD FUNCTIONS
        // ============================================================

        async function handleDocumentUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            const uploadedDocsDiv = document.getElementById('uploadedDocs');
            uploadedDocsDiv.innerHTML = '<div style="color: #0066CC;">üì§ Processing documents...</div>';

            try {
                let duplicateCount = 0;
                let skippedCount = 0;

                for (const file of files) {
                    console.log(`üìÑ Processing: ${file.name}`);
                    const text = await readFileContent(file);

                    if (text && text.trim().length > 0) {
                        // Check for duplicates
                        if (isDuplicateDocument(file, text)) {
                            duplicateCount++;
                            console.warn(`‚ö†Ô∏è Duplicate detected: ${file.name}`);
                            continue;
                        }

                        // Check storage limit before adding
                        const currentSize = getDocumentStorageSize();
                        const newContentSize = text.length;
                        const limit = getStorageLimit();

                        if (currentSize + newContentSize > limit) {
                            const percentUsed = Math.round(((currentSize + newContentSize) / limit) * 100);
                            alert(`‚ö†Ô∏è Storage Limit Warning!\n\nAdding "${file.name}" would exceed storage capacity (${percentUsed}%).\n\nPlease delete some existing documents before uploading new ones.`);
                            skippedCount++;
                            console.warn(`‚ö†Ô∏è Skipped due to storage limit: ${file.name}`);
                            continue;
                        }

                        // Warn if approaching limit (>80%)
                        if ((currentSize + newContentSize) / limit > 0.8) {
                            const percentUsed = Math.round(((currentSize + newContentSize) / limit) * 100);
                            if (!confirm(`‚ö†Ô∏è Storage Warning\n\nYou are using ${percentUsed}% of available storage.\n\nContinue uploading "${file.name}"?`)) {
                                skippedCount++;
                                continue;
                            }
                        }

                        uploadedDocuments.push({
                            name: file.name,
                            content: text,
                            size: file.size,
                            type: file.type,
                            timestamp: new Date().toISOString()
                        });

                        console.log(`‚úÖ Loaded: ${file.name} (${text.length} chars)`);
                    } else {
                        console.warn(`‚ö†Ô∏è Empty or unreadable: ${file.name}`);
                        skippedCount++;
                    }
                }

                // Combine all document texts
                uploadedDocText = uploadedDocuments.map(doc =>
                    `\n=== ${doc.name} ===\n${doc.content}\n`
                ).join('\n');

                // Save to localStorage
                saveUploadedDocumentsToStorage();

                // Update UI
                updateUploadedDocsList();
                updateDocumentStorageUI();

                // Show summary
                let summary = `‚úÖ Total documents loaded: ${uploadedDocuments.length}`;
                if (duplicateCount > 0) {
                    summary += `\n‚ö†Ô∏è ${duplicateCount} duplicate(s) skipped`;
                }
                if (skippedCount > 0) {
                    summary += `\n‚ö†Ô∏è ${skippedCount} file(s) skipped`;
                }

                console.log(summary);
                console.log(`üìä Total text content: ${uploadedDocText.length} characters`);

            } catch (error) {
                console.error('‚ùå Error processing documents:', error);
                uploadedDocsDiv.innerHTML = `<div style="color: #dc2626;">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = (e) => {
                    try {
                        const content = e.target.result;

                        // Handle different file types
                        if (file.type === 'application/pdf') {
                            // For PDF, we can only read text if it's text-based PDF
                            // In a full implementation, you'd use pdf.js library
                            resolve('[PDF content - Note: Full PDF parsing requires pdf.js library. Please convert to TXT for best results.]');
                        } else {
                            // Text files, Word docs as text, etc.
                            resolve(content);
                        }
                    } catch (error) {
                        reject(error);
                    }
                };

                reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));

                // Read as text
                if (file.type.includes('text') || file.name.endsWith('.txt') || file.name.endsWith('.md')) {
                    reader.readAsText(file);
                } else if (file.type.includes('pdf')) {
                    resolve('[PDF Upload - Please convert to .TXT format for full text extraction, or paste content manually into Custom Pathology field]');
                } else {
                    // Try reading as text anyway
                    reader.readAsText(file);
                }
            });
        }

        function updateUploadedDocsList() {
            const uploadedDocsDiv = document.getElementById('uploadedDocs');

            if (uploadedDocuments.length === 0) {
                uploadedDocsDiv.innerHTML = '';
                return;
            }

            let html = '<div style="background: #e3f2fd; padding: 10px; border-radius: 6px; margin-top: 10px;">';
            html += `<strong>‚úÖ ${uploadedDocuments.length} document(s) loaded:</strong><br>`;

            uploadedDocuments.forEach((doc, index) => {
                const sizeKB = (doc.size / 1024).toFixed(1);
                html += `<div style="margin-top: 5px; padding: 5px; background: white; border-radius: 4px;">`;
                html += `üìÑ ${doc.name} (${sizeKB} KB)`;
                html += `<button onclick="removeDocument(${index})" style="float: right; padding: 2px 8px; font-size: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 3px; cursor: pointer;">‚úï</button>`;
                html += `</div>`;
            });

            html += `<div style="margin-top: 8px; font-size: 0.75rem; color: #666;">`;
            html += `Total content: ${(uploadedDocText.length / 1024).toFixed(1)} KB`;
            html += `</div>`;
            html += '</div>';

            uploadedDocsDiv.innerHTML = html;
        }

        function removeDocument(index) {
            if (confirm(`Remove ${uploadedDocuments[index].name}?`)) {
                uploadedDocuments.splice(index, 1);

                // Rebuild combined text
                uploadedDocText = uploadedDocuments.map(doc =>
                    `\n=== ${doc.name} ===\n${doc.content}\n`
                ).join('\n');

                // Save to localStorage
                saveUploadedDocumentsToStorage();

                // Update UI
                updateUploadedDocsList();
                updateDocumentStorageUI();

                console.log(`üóëÔ∏è Document removed. Remaining: ${uploadedDocuments.length}`);
            }
        }

        function clearAllDocuments() {
            if (confirm('Clear all uploaded documents? This will remove them from storage permanently.')) {
                uploadedDocuments = [];
                uploadedDocText = '';
                document.getElementById('expertDocUpload').value = '';
                localStorage.removeItem('neuroscribe_uploaded_documents');
                updateUploadedDocsList();
                updateDocumentStorageUI();
                console.log('üóëÔ∏è All documents cleared from memory and storage');
            }
        }

        // ============================================================
        // DOCUMENT PERSISTENCE FUNCTIONS
        // ============================================================

        /**
         * Save uploaded documents to localStorage
         */
        function saveUploadedDocumentsToStorage() {
            try {
                const dataToSave = {
                    documents: uploadedDocuments,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('neuroscribe_uploaded_documents', JSON.stringify(dataToSave));
                console.log(`‚úÖ ${uploadedDocuments.length} document(s) saved to localStorage`);
                return true;
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    alert('‚ö†Ô∏è Storage limit reached! Please delete some documents before uploading new ones.');
                    console.error('‚ùå Storage quota exceeded');
                } else {
                    console.error('‚ùå Error saving documents:', error);
                }
                return false;
            }
        }

        /**
         * Load uploaded documents from localStorage
         */
        function loadUploadedDocumentsFromStorage() {
            try {
                const saved = localStorage.getItem('neuroscribe_uploaded_documents');
                if (saved) {
                    const data = JSON.parse(saved);
                    uploadedDocuments = data.documents || [];

                    // Rebuild combined text
                    uploadedDocText = uploadedDocuments.map(doc =>
                        `\n=== ${doc.name} ===\n${doc.content}\n`
                    ).join('\n');

                    updateUploadedDocsList();
                    updateDocumentStorageUI();

                    console.log(`‚úÖ ${uploadedDocuments.length} document(s) loaded from localStorage (saved: ${data.timestamp})`);
                    return true;
                }
            } catch (error) {
                console.error('‚ùå Error loading documents:', error);
            }
            return false;
        }

        /**
         * Check if a document is a duplicate
         */
        function isDuplicateDocument(file, content) {
            return uploadedDocuments.some(doc =>
                doc.name === file.name &&
                doc.size === file.size &&
                doc.content.substring(0, 100) === content.substring(0, 100)
            );
        }

        /**
         * Calculate total storage used by documents
         */
        function getDocumentStorageSize() {
            const totalBytes = uploadedDocuments.reduce((sum, doc) => sum + doc.content.length, 0);
            return totalBytes;
        }

        /**
         * Get estimated storage limit (5 MB)
         */
        function getStorageLimit() {
            return 5 * 1024 * 1024; // 5 MB in bytes
        }

        /**
         * Update document storage UI showing usage and list
         */
        function updateDocumentStorageUI() {
            const storageUIDiv = document.getElementById('documentStorageUI');
            if (!storageUIDiv) return;

            const totalSize = getDocumentStorageSize();
            const limit = getStorageLimit();
            const percentUsed = Math.round((totalSize / limit) * 100);
            const totalMB = (totalSize / (1024 * 1024)).toFixed(2);
            const limitMB = (limit / (1024 * 1024)).toFixed(0);

            let html = '<div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #0066CC;">';
            html += '<strong>üì¶ Document Storage</strong><br>';
            html += `<div style="margin-top: 8px; font-size: 0.85rem;">`;
            html += `Storage used: ${totalMB} MB / ${limitMB} MB (${percentUsed}%)`;

            // Storage bar
            const barColor = percentUsed > 80 ? '#dc2626' : percentUsed > 60 ? '#f59e0b' : '#10b981';
            html += `<div style="margin-top: 5px; background: #e5e7eb; border-radius: 3px; height: 8px; overflow: hidden;">`;
            html += `<div style="background: ${barColor}; height: 100%; width: ${Math.min(percentUsed, 100)}%;"></div>`;
            html += `</div>`;
            html += `</div>`;

            if (uploadedDocuments.length > 0) {
                html += '<div style="margin-top: 12px; max-height: 200px; overflow-y: auto;">';
                html += '<strong style="font-size: 0.85rem;">Stored Documents:</strong><br>';

                uploadedDocuments.forEach((doc, index) => {
                    const sizeKB = (doc.size / 1024).toFixed(1);
                    const uploadDate = new Date(doc.timestamp).toLocaleDateString();
                    html += `<div style="margin-top: 6px; padding: 6px; background: white; border-radius: 4px; font-size: 0.8rem; display: flex; justify-content: space-between; align-items: center;">`;
                    html += `<div>üìÑ ${doc.name}<br><span style="color: #666; font-size: 0.75rem;">${sizeKB} KB ‚Ä¢ ${uploadDate}</span></div>`;
                    html += `<button onclick="removeDocument(${index})" style="padding: 4px 10px; font-size: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>`;
                    html += `</div>`;
                });

                html += '</div>';

                html += `<div style="margin-top: 10px;">`;
                html += `<button onclick="clearAllDocuments()" style="padding: 6px 12px; font-size: 0.8rem; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer;">üóëÔ∏è Clear All Documents</button>`;
                html += `</div>`;
            } else {
                html += '<div style="margin-top: 8px; font-size: 0.8rem; color: #666;">No documents stored</div>';
            }

            html += '</div>';
            storageUIDiv.innerHTML = html;
        }

        // ============================================================
        // SOAP QUICK-ENTRY FUNCTIONS
        // ============================================================

        /**
         * Toggle SOAP enhancement mode
         */
        function toggleSOAPEnhancement() {
            soapEnhanceMode = document.getElementById('soapEnhanceToggle').checked;
            console.log(`ü§ñ SOAP Enhancement mode: ${soapEnhanceMode ? 'ON (Expand + Analysis)' : 'OFF (Expand Only)'}`);

            // Update mode stat display
            document.getElementById('soapMode').textContent = soapEnhanceMode ? 'Enhanced' : 'Expand';

            // Show/hide enhancement warning
            const hasBriefing = generatedBriefing && generatedBriefing.length > 0;
            const hasPathology = selectedPathology || customPathology;

            if (soapEnhanceMode && !hasBriefing && !hasPathology) {
                document.getElementById('enhanceWarning').style.display = 'block';
            } else {
                document.getElementById('enhanceWarning').style.display = 'none';
            }
        }

        /**
         * Toggle Transcript enhancement mode
         */
        function toggleTranscriptEnhancement() {
            transcriptEnhanceMode = document.getElementById('transcriptEnhanceToggle').checked;
            console.log(`ü§ñ Transcript Enhancement mode: ${transcriptEnhanceMode ? 'ON (Briefing Integration)' : 'OFF (Expand Only)'}`);
        }

        /**
         * Update enhancement toggles based on briefing availability
         */
        function updateEnhancementToggles() {
            const hasBriefing = generatedBriefing && generatedBriefing.length > 0;

            // Update Transcript toggle
            const transcriptToggle = document.getElementById('transcriptEnhanceToggle');
            const transcriptWarning = document.getElementById('transcriptEnhanceWarning');
            const transcriptLabel = document.getElementById('transcriptEnhanceLabel');

            if (transcriptToggle) {
                transcriptToggle.disabled = !hasBriefing;
                transcriptLabel.style.cursor = hasBriefing ? 'pointer' : 'not-allowed';
                transcriptLabel.style.opacity = hasBriefing ? '1' : '0.6';

                if (hasBriefing) {
                    transcriptWarning.style.display = 'none';
                } else {
                    transcriptWarning.style.display = 'block';
                    transcriptToggle.checked = false;
                    transcriptEnhanceMode = false;
                }
            }

            // Update SOAP toggle
            const soapToggle = document.getElementById('soapEnhanceToggle');
            const soapWarning = document.getElementById('enhanceWarning');

            if (soapToggle) {
                soapToggle.disabled = !hasBriefing;

                // Update parent label styling
                const soapLabel = soapToggle.closest('label');
                if (soapLabel) {
                    soapLabel.style.cursor = hasBriefing ? 'pointer' : 'not-allowed';
                    soapLabel.style.opacity = hasBriefing ? '1' : '0.6';
                }

                if (hasBriefing) {
                    soapWarning.style.display = 'none';
                } else {
                    soapWarning.innerHTML = 'üí° <strong>Note:</strong> Generate a briefing first to enable Enhanced Mode';
                    soapWarning.style.display = 'block';
                    soapToggle.checked = false;
                    soapEnhanceMode = false;
                }
            }

            console.log(`üîÑ Enhancement toggles updated: ${hasBriefing ? 'ENABLED' : 'DISABLED'}`);
        }

        /**
         * =====================================================
         * V6 INTERACTIVE REVIEW SYSTEM - Parser & UI Functions
         * =====================================================
         */

        /**
         * Parse AI suggestions from generated note
         * @param {string} noteText - The generated note containing AI_SUGGESTION markers
         * @returns {Array} Array of suggestion objects
         */
        function parseAISuggestions(noteText) {
            const suggestions = [];
            const regex = /<!-- AI_SUGGESTION (.*?) -->([\s\S]*?)<!-- \/AI_SUGGESTION -->/g;
            let match;
            let index = 0;

            while ((match = regex.exec(noteText)) !== null) {
                const attrs = match[1];
                const content = match[2].trim();

                // Parse attributes
                const typeMatch = attrs.match(/type="([^"]+)"/);
                const idMatch = attrs.match(/id="([^"]+)"/);
                const categoryMatch = attrs.match(/category="([^"]+)"/);
                const dependsMatch = attrs.match(/depends-on="([^"]*)"/);

                suggestions.push({
                    id: idMatch ? idMatch[1] : `ai-${index}`,
                    type: typeMatch ? typeMatch[1] : 'unknown',
                    category: categoryMatch ? categoryMatch[1] : 'general',
                    dependsOn: dependsMatch && dependsMatch[1] ? dependsMatch[1].split(',').map(d => d.trim()).filter(d => d) : [],
                    content: content,
                    startPos: match.index,
                    endPos: match.index + match[0].length,
                    fullMatch: match[0],
                    kept: true  // Default to keeping suggestions
                });
                index++;
            }

            console.log(`üìä Parsed ${suggestions.length} AI suggestions`);
            return suggestions;
        }

        /**
         * Display suggestions in review interface
         * @param {Array} suggestions - Array of parsed suggestions
         */
        function displayReviewInterface(suggestions) {
            const container = document.getElementById('reviewInterface');

            if (!container) {
                console.error('‚ùå Review interface container not found');
                return;
            }

            if (suggestions.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; padding: 20px; font-style: italic;">No AI suggestions found in this note. The note contains only documented facts.</p>';
                return;
            }

            // Group by category
            const grouped = {
                subjective: [],
                objective: [],
                assessment: [],
                plan: [],
                general: []
            };

            suggestions.forEach(s => {
                if (grouped[s.category]) {
                    grouped[s.category].push(s);
                } else {
                    grouped.general.push(s);
                }
            });

            let html = '';

            // Render each category
            Object.keys(grouped).forEach(category => {
                if (grouped[category].length === 0) return;

                const categoryTitle = category.charAt(0).toUpperCase() + category.slice(1);
                html += `<div class="suggestion-category" style="margin-bottom: 25px;">`;
                html += `<h3 style="color: #4A90E2; font-size: 1.1rem; margin-bottom: 12px; font-weight: 600;">${categoryTitle} Section</h3>`;

                grouped[category].forEach(suggestion => {
                    const typeLabel = getSuggestionTypeLabel(suggestion.type);
                    const icon = getSuggestionIcon(suggestion.type);
                    const hasDeps = suggestion.dependsOn.length > 0;

                    html += `
                    <div class="suggestion-item" style="background: #f9fafb; border: 1px solid #E1E4E8; border-radius: 6px; padding: 14px; margin-bottom: 12px; transition: all 0.2s;">
                        <label style="display: flex; align-items: start; cursor: pointer; user-select: none;">
                            <input type="checkbox"
                                   id="suggestion-${suggestion.id}"
                                   data-suggestion-id="${suggestion.id}"
                                   onchange="toggleSuggestion('${suggestion.id}')"
                                   ${suggestion.kept ? 'checked' : ''}
                                   style="margin-right: 12px; margin-top: 4px; width: 18px; height: 18px; cursor: pointer; flex-shrink: 0; accent-color: #4A90E2;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: #24292e; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                                    <span>${icon} ${typeLabel}</span>
                                    ${hasDeps ? '<span style="font-size: 0.75rem; color: #6a737d; font-weight: normal; background: #fff; padding: 2px 6px; border-radius: 3px; border: 1px solid #e1e4e8;">üîó linked</span>' : ''}
                                </div>
                                <div style="background: white; padding: 12px; border-radius: 4px; border: 1px solid #e1e4e8; white-space: pre-wrap; font-size: 0.9rem; line-height: 1.6; color: #24292e; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;">
${escapeHtml(suggestion.content)}</div>
                            </div>
                        </label>
                    </div>`;
                });

                html += `</div>`;
            });

            container.innerHTML = html;
            console.log(`‚úÖ Review interface displayed with ${suggestions.length} suggestions`);
        }

        /**
         * Get human-readable label for suggestion type
         * @param {string} type - Suggestion type code
         * @returns {string} Human-readable label
         */
        function getSuggestionTypeLabel(type) {
            const labels = {
                'clinical-analysis': 'Clinical Analysis',
                'differential': 'Differential Diagnosis',
                'recommendation': 'Management Recommendation',
                'pearl': 'Clinical Pearl',
                'red-flag': 'Red Flag Alert',
                'gap-analysis': 'Clinical Gaps Identified',
                'evidence': 'Evidence-Based Analysis',
                'workup': 'Diagnostic Workup',
                'scales': 'Clinical Scales Assessment'
            };
            return labels[type] || type.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        /**
         * Get icon for suggestion type
         * @param {string} type - Suggestion type code
         * @returns {string} Emoji icon
         */
        function getSuggestionIcon(type) {
            const icons = {
                'clinical-analysis': 'ü§ñ',
                'differential': 'üéØ',
                'recommendation': 'üíä',
                'pearl': 'üíé',
                'red-flag': '‚ö†Ô∏è',
                'gap-analysis': 'üìã',
                'evidence': 'üìä',
                'workup': 'üî¨',
                'scales': 'üìè'
            };
            return icons[type] || 'üìù';
        }

        /**
         * Escape HTML special characters
         * @param {string} text - Text to escape
         * @returns {string} Escaped text
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * =====================================================
         * V6 INTERACTIVE REVIEW SYSTEM - Interaction Logic
         * =====================================================
         */

        /**
         * Toggle a suggestion on/off
         * @param {string} id - Suggestion ID
         */
        function toggleSuggestion(id) {
            const checkbox = document.getElementById(`suggestion-${id}`);
            const suggestion = currentSuggestions.find(s => s.id === id);

            if (!suggestion) {
                console.error(`‚ùå Suggestion ${id} not found`);
                return;
            }

            suggestion.kept = checkbox.checked;
            console.log(`${suggestion.kept ? '‚úÖ KEPT' : '‚ùå DISCARDED'}: ${getSuggestionTypeLabel(suggestion.type)} (${id})`);

            // Smart dependencies - ask about related items when discarding
            if (!suggestion.kept) {
                handleDependencies(id);
            }
        }

        /**
         * Handle smart dependencies when discarding a suggestion
         * @param {string} parentId - ID of the suggestion being discarded
         */
        function handleDependencies(parentId) {
            // Find suggestions that depend on this one
            const dependents = currentSuggestions.filter(s =>
                s.dependsOn.includes(parentId) && s.kept
            );

            if (dependents.length === 0) return;

            // Build list of dependent items
            const dependentNames = dependents.map(d =>
                `‚Ä¢ ${getSuggestionIcon(d.type)} ${getSuggestionTypeLabel(d.type)}`
            ).join('\n');

            const shouldDiscard = confirm(
                `‚ö†Ô∏è LINKED SUGGESTIONS DETECTED\n\n` +
                `The following ${dependents.length} suggestion(s) depend on the item you just discarded:\n\n` +
                `${dependentNames}\n\n` +
                `Would you like to also discard these related items?\n\n` +
                `Click OK to discard related items, or Cancel to keep them.`
            );

            if (shouldDiscard) {
                dependents.forEach(dep => {
                    dep.kept = false;
                    const checkbox = document.getElementById(`suggestion-${dep.id}`);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                    console.log(`üîó Auto-discarded dependent: ${dep.id}`);
                });

                console.log(`‚úÖ Discarded ${dependents.length} dependent suggestion(s)`);
            } else {
                console.log(`‚ÑπÔ∏è Kept ${dependents.length} dependent suggestion(s)`);
            }
        }

        /**
         * Select all suggestions (check all checkboxes)
         */
        function selectAllSuggestions() {
            if (currentSuggestions.length === 0) {
                alert('‚ÑπÔ∏è No suggestions to select. Generate a note with Enhanced Mode first.');
                return;
            }

            currentSuggestions.forEach(s => {
                s.kept = true;
                const checkbox = document.getElementById(`suggestion-${s.id}`);
                if (checkbox) checkbox.checked = true;
            });

            console.log(`‚úÖ All ${currentSuggestions.length} suggestions kept`);
        }

        /**
         * Deselect all suggestions (uncheck all checkboxes)
         */
        function deselectAllSuggestions() {
            if (currentSuggestions.length === 0) {
                alert('‚ÑπÔ∏è No suggestions to deselect.');
                return;
            }

            const confirmed = confirm(
                `‚ö†Ô∏è DISCARD ALL SUGGESTIONS?\n\n` +
                `This will remove all ${currentSuggestions.length} AI-generated suggestions from your final note.\n\n` +
                `Only your documented facts will remain.\n\n` +
                `Click OK to discard all, or Cancel to keep them.`
            );

            if (!confirmed) return;

            currentSuggestions.forEach(s => {
                s.kept = false;
                const checkbox = document.getElementById(`suggestion-${s.id}`);
                if (checkbox) checkbox.checked = false;
            });

            console.log(`‚ùå All ${currentSuggestions.length} suggestions discarded`);
        }

        /**
         * =====================================================
         * V6 INTERACTIVE REVIEW SYSTEM - Final Note Generator
         * =====================================================
         */

        /**
         * Generate final clean note with only kept suggestions
         */
        async function generateFinalNote() {
            if (currentSuggestions.length === 0) {
                alert('‚ÑπÔ∏è No suggestions to process. This note contains only documented facts and is already finalized.');
                return;
            }

            console.log('üìÑ Generating final clean note...');

            // Get the raw generated note
            const rawNote = document.getElementById('output').value;
            if (!rawNote) {
                alert('‚ùå No note content found. Please generate a note first.');
                return;
            }

            let finalNote = rawNote;

            // Count kept vs discarded
            const keptCount = currentSuggestions.filter(s => s.kept).length;
            const discardedCount = currentSuggestions.length - keptCount;

            console.log(`üìä Processing: ${keptCount} kept, ${discardedCount} discarded`);

            // Remove all AI_SUGGESTION markers and their content
            currentSuggestions.forEach(suggestion => {
                if (suggestion.kept) {
                    // Keep the content but remove the markers
                    finalNote = finalNote.replace(
                        suggestion.fullMatch,
                        suggestion.content
                    );
                } else {
                    // Remove entirely (markers + content)
                    finalNote = finalNote.replace(suggestion.fullMatch, '');
                }
            });

            // Clean up formatting
            finalNote = cleanFinalNote(finalNote);

            // Display in new tab
            displayFinalNote(finalNote, keptCount, discardedCount);

            // Generate ALL compression levels automatically from final note
            console.log('üìä Auto-generating compressed and ultracompressed summaries...');

            // Store the full note
            currentNoteVersions.full = finalNote;

            // Generate standard compression (independent)
            currentNoteVersions.status.standard = 'generating';
            updateCompressionStatusBadges();
            try {
                const standardSummary = await generateAttendingSummary(finalNote);
                currentNoteVersions.standard = standardSummary || '';
                currentNoteVersions.status.standard = 'ready';
                updateCompressionStatusBadges();
                console.log('‚úÖ Standard compression generated');
            } catch (standardError) {
                console.error('‚ùå Standard compression failed:', standardError.message);
                currentNoteVersions.standard = '‚ö†Ô∏è Standard compression failed. Click "Regenerate" to retry.';
                currentNoteVersions.status.standard = 'failed';
                updateCompressionStatusBadges();
            }

            // Generate ULTRA compression (independent)
            currentNoteVersions.status.ultra = 'generating';
            updateCompressionStatusBadges();
            try {
                const ultraSummary = await generateUltraAttendingSummary(finalNote);
                currentNoteVersions.ultra = ultraSummary || '';
                currentNoteVersions.status.ultra = 'ready';
                updateCompressionStatusBadges();
                console.log('‚úÖ ULTRA compression generated');
            } catch (ultraError) {
                console.error('‚ùå ULTRA compression failed:', ultraError.message);
                currentNoteVersions.ultra = '‚ö†Ô∏è ULTRA compression failed. Click "Regenerate" to retry.';
                currentNoteVersions.status.ultra = 'failed';
                updateCompressionStatusBadges();
            }

            // Generate Telegram compression (independent)
            currentNoteVersions.status.telegram = 'generating';
            updateCompressionStatusBadges();
            try {
                const telegramSummary = await generateTelegramSummary(finalNote);
                currentNoteVersions.telegram = telegramSummary || '';
                currentNoteVersions.status.telegram = 'ready';
                updateCompressionStatusBadges();
                console.log('‚úÖ Telegram compression generated');
            } catch (telegramError) {
                console.error('‚ùå Telegram compression failed:', telegramError.message);
                currentNoteVersions.telegram = '‚ö†Ô∏è Telegram compression failed. Click "Regenerate" to retry.';
                currentNoteVersions.status.telegram = 'failed';
                updateCompressionStatusBadges();
            }

            // Display based on currently selected compression mode
            const selectedMode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
            const summaryToDisplay = selectedMode === 'ultra' ? currentNoteVersions.ultra
                                   : selectedMode === 'telegram' ? currentNoteVersions.telegram
                                   : currentNoteVersions.standard;

            if (summaryToDisplay && !summaryToDisplay.includes('failed')) {
                displayAttendingSummary(summaryToDisplay, selectedMode);
            } else if (summaryToDisplay) {
                // Show error message in textarea
                displayAttendingSummary(summaryToDisplay, selectedMode);
            } else {
                console.warn('‚ö†Ô∏è No summary generated');
            }
        }

        /**
         * Clean final note formatting for EMR
         * @param {string} note - Note text to clean
         * @returns {string} Cleaned note
         */
        function cleanFinalNote(note) {
            return note
                // Remove emoji markers
                .replace(/üìù DOCUMENTED:/g, '')
                .replace(/üìù /g, '')
                .replace(/ü§ñ CLINICAL ANALYSIS:/g, 'CLINICAL ANALYSIS:')
                .replace(/ü§ñ DIFFERENTIAL DIAGNOSIS:/g, 'DIFFERENTIAL DIAGNOSIS:')
                .replace(/ü§ñ EVIDENCE-BASED RECOMMENDATIONS:/g, 'RECOMMENDATIONS:')
                .replace(/ü§ñ CLINICAL GAPS IDENTIFIED:/g, 'CLINICAL GAPS:')
                .replace(/ü§ñ /g, '')
                .replace(/üí° CLINICAL PEARL:/g, 'CLINICAL PEARL:')
                .replace(/üí° /g, '')
                .replace(/‚ö†Ô∏è RED FLAG ALERT:/g, 'IMPORTANT:')
                .replace(/‚ö†Ô∏è RED FLAGS:/g, 'RED FLAGS:')
                .replace(/‚ö†Ô∏è /g, '')
                .replace(/üìä Evidence Level:/g, 'Evidence Level:')
                .replace(/üìä /g, '')
                .replace(/üî¨ RECOMMENDED DIAGNOSTIC WORKUP/g, 'DIAGNOSTIC WORKUP')
                .replace(/üî¨ /g, '')
                .replace(/üíä EVIDENCE-BASED MANAGEMENT PLAN/g, 'MANAGEMENT PLAN')
                .replace(/üíä /g, '')
                .replace(/üìè CLINICAL SCALES ASSESSMENT/g, 'CLINICAL SCALES ASSESSMENT')
                .replace(/üìè /g, '')
                .replace(/üîó /g, '')
                .replace(/üéØ /g, '')
                .replace(/üíé /g, '')
                .replace(/üìã /g, '')

                // Remove multiple blank lines (max 2 consecutive)
                .replace(/\n{4,}/g, '\n\n\n')
                .replace(/\n{3,}/g, '\n\n')

                // Remove trailing whitespace from lines
                .replace(/[ \t]+$/gm, '')

                // Clean up spacing around headers
                .replace(/\n\n##/g, '\n\n\n##')
                .replace(/##([^\n])/g, '## $1')

                .trim();
        }

        /**
         * Display final note in dedicated tab
         * @param {string} finalNote - The cleaned final note
         * @param {number} keptCount - Number of kept suggestions
         * @param {number} discardedCount - Number of discarded suggestions
         */
        function displayFinalNote(finalNote, keptCount, discardedCount) {
            // Check if Final Note tab already exists
            let finalTab = document.getElementById('tab-final');
            let finalButton = document.getElementById('final-tab-button');

            if (!finalTab) {
                // Create the tab button
                const tabButtons = document.querySelector('.tab-buttons');
                finalButton = document.createElement('button');
                finalButton.className = 'tab-button';
                finalButton.id = 'final-tab-button';
                finalButton.onclick = () => switchTab('final');
                finalButton.innerHTML = 'üìÑ Final Note';
                tabButtons.appendChild(finalButton);

                // Create the tab content
                const outputPanel = document.querySelector('#tab-export').parentElement;
                finalTab = document.createElement('div');
                finalTab.className = 'tab-content';
                finalTab.id = 'tab-final';
                finalTab.style.display = 'none';
                finalTab.innerHTML = `
                    <div style="background: #d4edda; padding: 14px; border-radius: 6px; margin-bottom: 20px; color: #155724; border-left: 4px solid #28a745;">
                        <strong>‚úÖ Final Clean Note:</strong> Professional clinical documentation ready for medical record.
                        All markers and emojis removed. You can edit before exporting.
                    </div>

                    <div id="finalNoteSummary" style="background: #f6f8fa; padding: 12px; border-radius: 6px; margin-bottom: 15px; font-size: 0.9rem; color: #24292e; display: flex; gap: 20px; justify-content: center; border: 1px solid #e1e4e8;">
                        <span id="finalKeptCount"></span>
                        <span id="finalDiscardedCount"></span>
                    </div>

                    <textarea id="finalNoteText"
                              style="width: 100%; min-height: 500px; font-family: 'Courier New', Courier, monospace; font-size: 0.95rem; padding: 15px; border: 2px solid #E1E4E8; border-radius: 6px; line-height: 1.6; resize: vertical;"
                              placeholder="Final note will appear here..."></textarea>

                    <div style="margin-top: 15px; display: flex; gap: 12px;">
                        <button onclick="copyFinalNote()" class="success" style="flex: 1; padding: 12px;">
                            üìã Copy to Clipboard
                        </button>
                        <button onclick="downloadFinalNote()" class="success" style="flex: 1; padding: 12px;">
                            üíæ Download as TXT
                        </button>
                        <button onclick="printFinalNote()" style="flex: 1; padding: 12px;">
                            üñ®Ô∏è Print Note
                        </button>
                    </div>
                `;
                outputPanel.appendChild(finalTab);

                console.log('üìÑ Final Note tab created');
            }

            // Update summary
            document.getElementById('finalKeptCount').textContent = `‚úÖ ${keptCount} suggestions kept`;
            document.getElementById('finalDiscardedCount').textContent = `‚ùå ${discardedCount} discarded`;

            // Set the final note text
            document.getElementById('finalNoteText').value = finalNote;

            // Switch to the Final Note tab
            switchTab('final');

            console.log('‚úÖ Final note generated and displayed');
        }

        /**
         * Copy final note to clipboard
         */
        function copyFinalNote() {
            const finalNote = document.getElementById('finalNoteText');
            if (!finalNote || !finalNote.value) {
                alert('‚ùå No final note to copy. Generate the final note first.');
                return;
            }

            finalNote.select();
            finalNote.setSelectionRange(0, 99999); // For mobile

            try {
                document.execCommand('copy');
                alert('‚úÖ Final note copied to clipboard!');
                console.log('üìã Final note copied to clipboard');
            } catch (err) {
                alert('‚ùå Failed to copy. Please select and copy manually.');
                console.error('Copy failed:', err);
            }
        }

        /**
         * Download final note as text file
         */
        function downloadFinalNote() {
            const text = document.getElementById('finalNoteText').value;
            if (!text) {
                alert('‚ùå No final note to download. Generate the final note first.');
                return;
            }

            const patientName = document.getElementById('patientName').value || 'Patient';
            const dateStr = new Date().toISOString().slice(0, 10);
            const filename = `Clinical_Note_${patientName.replace(/\s+/g, '_')}_${dateStr}.txt`;

            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log(`üíæ Downloaded: ${filename}`);
        }

        /**
         * Print final note
         */
        function printFinalNote() {
            const text = document.getElementById('finalNoteText').value;
            if (!text) {
                alert('‚ùå No final note to print. Generate the final note first.');
                return;
            }

            const printWindow = window.open('', '', 'height=800,width=800');
            printWindow.document.write('<html><head><title>Clinical Note</title>');
            printWindow.document.write('<style>body { font-family: "Courier New", monospace; font-size: 12pt; line-height: 1.6; padding: 1in; white-space: pre-wrap; }</style>');
            printWindow.document.write('</head><body>');
            printWindow.document.write(text);
            printWindow.document.write('</body></html>');
            printWindow.document.close();
            printWindow.print();

            console.log('üñ®Ô∏è Print dialog opened');
        }

        /**
         * =====================================================
         * ATTENDING SUMMARY (Ultra Summarizer) - DOAP Framework
         * =====================================================
         */

        /**
         * Generate attending presentation summary using DOAP framework
         * @param {string} clinicalNote - The full clinical note to summarize
         */
        async function generateAttendingSummary(clinicalNote) {
            if (!API_KEY) {
                console.error('‚ùå API key not configured for attending summary');
                return;
            }

            if (!clinicalNote || clinicalNote.trim().length === 0) {
                console.error('‚ùå No clinical note to summarize');
                return;
            }

            // Show immediate visual feedback
            const textarea = document.getElementById('attendingSummaryText');
            const tabButton = document.getElementById('attending-tab-button');

            if (textarea) {
                textarea.value = '‚è≥ Generating DOAP attending summary...\n\nPlease wait while the AI creates your 45-second presentation.';
            }

            // Show tab immediately
            if (tabButton) {
                tabButton.style.display = 'inline-block';
            }

            // Store for regeneration
            lastGeneratedNote = clinicalNote;

            try {
                // DOAP Framework Prompt
                const prompt = `You are an expert at creating concise attending presentations for neurosurgical cases. Your task is to create a 45-second presentation summary using the DOAP framework.

**DOAP Framework:**
- **D** (Diagnosis Line) - 5 seconds: [Age][Sex], [key PMHx], [primary diagnosis with grade/severity]
- **O** (One-Liner) - 10 seconds: Exam (GCS + critical findings) + Imaging (key pathology with size/grade)
- **A** (Assessment) - 10 seconds: Severity assessment + candidacy for intervention
- **P** (Plan) - 20 seconds: Intervention + timing + main concern/risk

**Critical Rules:**
1. Extract ONLY factual information from the note - NO fabrication
2. Be extremely concise - target 45-second speaking time (~120-140 words)
3. Use neurosurgical terminology appropriately
4. Prioritize most critical findings
5. Format clearly with D/O/A/P headers
6. If information missing, note it briefly (e.g., "exam not documented")

**Example Format:**
D: 67M, HTN, ruptured ACoA aneurysm H&H 3

O: GCS 13, no focal deficit, stiff neck. CT shows Fisher 3 SAH, 7mm ACoA aneurysm on CTA, acute hydrocephalus

A: Low-grade bleed, symptomatic ICP, favorable anatomy for clipping, no contraindications

P: EVD tonight for hydrocephalus, clip tomorrow via pterional. Main concern is vasospasm‚ÄîFisher 3, so TCDs day 3, nimodipine √ó 21 days

---
**Clinical Note to Summarize:**
${clinicalNote}

---
Generate the DOAP summary now:`;

                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.3,  // Factual but concise
                                maxOutputTokens: 4096  // Doubled to handle thinking tokens + actual output
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå API Response NOT OK:', response.status, errorText.substring(0, 500));
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                console.log('üìä Full API Response:', JSON.stringify(data, null, 2));

                // Check for safety blocking
                if (data.promptFeedback?.blockReason) {
                    const blockReason = data.promptFeedback.blockReason;
                    console.error('‚ùå Content blocked by API:', blockReason);
                    throw new Error(`API blocked content: ${blockReason}`);
                }

                // Check if candidates exist
                if (!data.candidates || data.candidates.length === 0) {
                    console.error('‚ùå No candidates in response');
                    console.error('Response structure:', JSON.stringify(data, null, 2));
                    throw new Error('API returned no candidates. Check console for details.');
                }

                // Check finish reason
                const finishReason = data.candidates[0]?.finishReason;
                if (finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during compression generation');
                    console.error('Note may be too long. Candidate structure:', JSON.stringify(data.candidates[0], null, 2));
                    throw new Error('Token limit exceeded. Try with a shorter clinical note or increase maxOutputTokens.');
                } else if (finishReason && finishReason !== 'STOP') {
                    console.warn('‚ö†Ô∏è Unusual finish reason:', finishReason);
                }

                const summary = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No summary generated';

                if (summary === 'No summary generated') {
                    console.error('‚ùå Failed to extract text from response');
                    console.error('Candidate structure:', JSON.stringify(data.candidates[0], null, 2));
                    throw new Error(`Generation failed with finish reason: ${finishReason || 'UNKNOWN'}`);
                }

                console.log('‚úÖ Attending summary generated successfully');
                console.log('Summary length:', summary.length, 'characters');
                return summary;

            } catch (error) {
                console.error('‚ùå Error generating attending summary:', error);

                // Show error in textarea
                if (textarea) {
                    textarea.value = `‚ùå Error generating attending summary:\n\n${error.message}\n\nPlease check:\n1. API key is configured\n2. Internet connection is active\n3. Gemini API quota is available\n\nTry the Regenerate button or generate a new note.`;
                }

                throw error;
            }
        }

        /**
         * Display attending summary in the UI
         * @param {string} summary - The DOAP summary text
         */
        function displayAttendingSummary(summary, mode = null) {
            const textarea = document.getElementById('attendingSummaryText');
            const tabButton = document.getElementById('attending-tab-button');

            if (!textarea) {
                console.error('‚ùå Attending summary textarea not found');
                return;
            }

            // Display the summary
            textarea.value = summary;

            // Show the attending summary tab button
            if (tabButton) {
                tabButton.style.display = 'inline-block';
            }

            // Automatically switch to the attending summary tab
            switchTab('attending');

            // Log which compression level is being displayed
            const displayMode = mode || document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
            const modeLabels = {
                'standard': 'Compressed (Standard DOAP)',
                'ultra': 'Ultracompressed (ULTRATHINK)',
                'telegram': 'Super-compressed (Telegram)'
            };
            console.log(`‚úÖ ${modeLabels[displayMode]} summary displayed and tab switched`);

            // Update stats after displaying
            updateSummaryStats(summary);
        }

        /**
         * Update status badges for compression modes
         */
        function updateCompressionStatusBadges() {
            const statusMap = {
                'pending': { emoji: '‚è≥', text: 'Pending', bg: '#e0e0e0', color: '#666' },
                'generating': { emoji: '‚åõ', text: 'Generating...', bg: '#FFF9C4', color: '#F57F17' },
                'ready': { emoji: '‚úÖ', text: 'Ready', bg: '#C8E6C9', color: '#2E7D32' },
                'failed': { emoji: '‚ùå', text: 'Failed', bg: '#FFCDD2', color: '#C62828' }
            };

            ['standard', 'ultra', 'telegram'].forEach(mode => {
                const badge = document.getElementById(`status-${mode}`);
                if (badge) {
                    const status = currentNoteVersions.status[mode] || 'pending';
                    const statusInfo = statusMap[status];
                    badge.textContent = `${statusInfo.emoji} ${statusInfo.text}`;
                    badge.style.background = statusInfo.bg;
                    badge.style.color = statusInfo.color;
                }
            });
        }

        /**
         * Update compression info box based on selected mode
         */
        function updateCompressionInfo() {
            const mode = document.querySelector('input[name="compressionMode"]:checked').value;
            const infoBox = document.getElementById('compressionInfoBox');

            if (!infoBox) return;

            if (mode === 'standard') {
                infoBox.innerHTML = `
                    <strong>üìä DOAP Framework for Attending Presentation:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>D</strong> - Diagnosis (5 sec): Age, Sex, PMHx, Primary diagnosis</li>
                        <li><strong>O</strong> - One-liner (10 sec): Exam findings + Imaging results</li>
                        <li><strong>A</strong> - Assessment (10 sec): Severity + Candidacy</li>
                        <li><strong>P</strong> - Plan (20 sec): Intervention + Timing + Main concern</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 45-second presentation to impress attending staff</p>
                `;
                infoBox.style.background = '#e3f2fd';
                infoBox.style.borderLeft = '4px solid #2196F3';
            } else if (mode === 'ultra') {
                infoBox.innerHTML = `
                    <strong>‚ö° ULTRATHINK Compression Mode:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>Ultra-Brief Format:</strong> Merge D+O into one line, strip all non-essential words</li>
                        <li><strong>Aggressive Abbreviations:</strong> sz (seizure), fx (fracture), EDH (epidural hematoma)</li>
                        <li><strong>Numbers Only:</strong> GCS scores, vital signs, timeframes</li>
                        <li><strong>Key Actions:</strong> Only critical interventions and monitoring</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 15-second rapid-fire summary (~35-50 words)</p>
                `;
                infoBox.style.background = '#FFE5E0';
                infoBox.style.borderLeft = '4px solid #FF5722';
            } else if (mode === 'telegram') {
                infoBox.innerHTML = `
                    <strong>üì± Telegram Style - Extreme Compression:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>One Sentence Only:</strong> Age+Dx+Key finding+Action</li>
                        <li><strong>Maximum Abbreviations:</strong> Every word counts</li>
                        <li><strong>No Elaboration:</strong> Core facts only</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 5-second elevator pitch (~15-25 words max)</p>
                `;
                infoBox.style.background = '#F3E5F5';
                infoBox.style.borderLeft = '4px solid #9C27B0';
            }

            console.log('üîÑ Compression mode changed to:', mode);

            // Auto-switch to display the already-generated version if it exists
            const textarea = document.getElementById('attendingSummaryText');
            if (!textarea) return;

            let summaryToDisplay = '';
            const modeLabels = {
                'standard': 'Compressed (Standard DOAP)',
                'ultra': 'Ultracompressed (ULTRATHINK)',
                'telegram': 'Telegram Style'
            };

            if (mode === 'ultra' && currentNoteVersions.ultra) {
                summaryToDisplay = currentNoteVersions.ultra;
                console.log('‚úÖ Switched to ultracompressed version');
            } else if (mode === 'standard' && currentNoteVersions.standard) {
                summaryToDisplay = currentNoteVersions.standard;
                console.log('‚úÖ Switched to compressed version');
            } else if (mode === 'telegram' && currentNoteVersions.telegram) {
                summaryToDisplay = currentNoteVersions.telegram;
                console.log('‚úÖ Switched to telegram version');
            }

            // Display the summary (including error messages)
            if (summaryToDisplay) {
                textarea.value = summaryToDisplay;
                // Only update stats if not an error message
                if (!summaryToDisplay.includes('failed')) {
                    updateSummaryStats(summaryToDisplay);
                }
            } else {
                // Show helpful message if mode not yet generated
                const status = currentNoteVersions.status[mode];
                if (status === 'pending') {
                    textarea.value = `‚ÑπÔ∏è ${modeLabels[mode]} will be generated automatically after you create a clinical note.\n\nGenerate a note using transcript or SOAP entry to see ${modeLabels[mode]} here.`;
                } else if (status === 'generating') {
                    textarea.value = `‚åõ Generating ${modeLabels[mode]}...\n\nPlease wait a moment.`;
                }
            }
        }

        /**
         * Generate ULTRA-compressed attending summary (15 seconds, ~35-50 words)
         */
        async function generateUltraAttendingSummary(clinicalNote) {
            if (!API_KEY) {
                console.error('‚ùå API key not configured');
                return;
            }

            if (!clinicalNote || clinicalNote.trim().length === 0) {
                console.error('‚ùå No clinical note to summarize');
                return;
            }

            const prompt = `You are an expert neurosurgeon creating ULTRA-COMPRESSED handoff presentations. Create a 15-second ULTRATHINK summary for safe neurosurgical handoff.

‚ö†Ô∏è CRITICAL SAFETY - NEVER COMPRESS THESE:
1. **GCS components** - ALWAYS include E_V_M_ breakdown (e.g., GCS8:E2V2M4) NOT just total
2. **Laterality** - ALWAYS specify L/R: "L hemiparesis", "R pupil dilated 6mm"
3. **Exact measurements** - NEVER round: "7mm aneurysm" NOT "small aneurysm"
4. **Time-critical windows** - Include exact times: "onset 2h ago", "last normal 14:30"
5. **Anticoagulation** - If on anticoag: "+warfarin INR2.8", "+Plavix"
6. **Neuro exam changes** - Always include direction: "pupil L3‚Üí6mm", "weakness improving 2/5‚Üí4/5"
7. **Critical actions** - Never abbreviate urgent interventions: "Stat craniotomy" not "crani"

**COMPRESSION RULES:**
1. Target 35-50 words total (strict limit)
2. Merge diagnosis + exam into continuous flow
3. Use neurosurgical abbreviations ONLY
4. Strip non-essential words BUT maintain clarity
5. Numbers and critical timeframes mandatory
6. Action items in shortest form that remains unambiguous

‚õî PROHIBITED ABBREVIATIONS (Joint Commission):
- U (units) ‚Üí spell "units"
- Q.D./Q.O.D. ‚Üí "daily"/"every other day"
- Trailing zeros (1.0mg) ‚Üí "1mg"
- MS/MSO4 ‚Üí spell out medication

**NEUROSURGICAL APPROVED ABBREVIATIONS:**
TBI, SAH, EDH, SDH, IPH, ICH, IVH, AVM, GBM, mets, HCP, sz, fx, SCI, ACDF, lami, EVD, ICP, crani, VP shunt, C/T/L/S levels, H&H, Fisher, mRS

**NEUROSURGERY HANDOFF EXAMPLES:**

**TRAUMA (Emergent Surgical):**
29M polytrauma: TBI+3cm R temporal EDH (GCS8:E2V2M4 intubated, L hemiplegia 0/5, R pupil 5mm). 5mm midline shift. EMERGENT craniotomy OR2 in 30min. WATCH: L pupil pre-op, ICP>25.

**VASCULAR (Urgent Observation):**
67F ruptured ACoA: 7mm aneurysm H&H3 Fisher3 (GCS13:E4V4M6 stiff neck). Acute hydroceph, dilated ventricles. EVD tonight, clip AM. WATCH: Vasospasm day 3-14, rebleed, TCDs q12h.

**DEGENERATIVE (Elective - Cauda Equina):**
58M L4-5 massive disc: cauda equina 12h (saddle anesthesia, retention, foot drop L2/5 R3/5). MRI confirms compression. SURGERY <6h from onset‚Äîfunction salvage. WATCH: Return bladder/motor post-op.

**TUMOR (Urgent Resection):**
45F L frontal GBM: 4cm enhancing mass (headache+sz 2wks, now hemiparesis R4/5 declining). 10mm shift+edema. Resection this week, dex 4mg q6h. WATCH: Neuro decline‚Äîexpedite if worsens.

**SPINE TRAUMA (Unstable):**
35M C5-6 fx-dislocation: fall 6m (incomplete SCI, hands weak 3/5, legs 4/5, sensory C6). CT unstable fx, MRI cord contusion. SURGERY 24h‚ÄîACDF+fusion. Halo until OR. WATCH: Neuro decline, resp failure.

---
**Clinical Note to Compress:**
${clinicalNote}

---
Generate ULTRATHINK neurosurgical handoff (35-50 words, preserve ALL safety-critical details):`;

            try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.1,  // Maximum factual accuracy for critical neurosurgical handoffs
                                maxOutputTokens: 4096  // Quadrupled - handles complex notes with long prompts
                            }
                        })
                    }
                );

                if (!response.ok) {
                    throw new Error(`API Error ${response.status}`);
                }

                const data = await response.json();

                // Check for MAX_TOKENS finish reason
                const finishReason = data.candidates?.[0]?.finishReason;
                if (finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during ULTRA compression');
                    throw new Error('Token limit exceeded for ULTRA compression. Note may be too complex.');
                }

                const summary = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No summary generated';

                if (summary === 'No summary generated') {
                    console.error('‚ùå Failed to generate ULTRA summary. Finish reason:', finishReason);
                    throw new Error(`ULTRA generation failed: ${finishReason || 'UNKNOWN'}`);
                }

                console.log('‚úÖ ULTRA summary generated');
                return summary;

            } catch (error) {
                console.error('‚ùå Error generating ULTRA summary:', error);
                throw error;
            }
        }

        /**
         * Generate Telegram-style summary (5 seconds, ~15-25 words)
         */
        async function generateTelegramSummary(clinicalNote) {
            if (!API_KEY) {
                console.error('‚ùå API key not configured');
                return;
            }

            if (!clinicalNote || clinicalNote.trim().length === 0) {
                console.error('‚ùå No clinical note to summarize');
                return;
            }

            const prompt = `You are an expert at creating TELEGRAM-STYLE neurosurgical summaries. Create a 5-second extreme compression.

**Telegram Rules:**
1. Maximum 15-25 words (ABSOLUTE LIMIT)
2. ONE sentence only
3. Format: [Age][Sex] [Dx]+[complication]: [key finding]. [GCS]. [Action]
4. Maximum abbreviations everywhere
5. No elaboration whatsoever

**Example:**
29M TBI+sz: bifrontal contusions, EDH mass effect. GCS8. Observe, CT q8h

---
**Clinical Note:**
${clinicalNote}

---
Generate Telegram summary (15-25 words ONLY):`;

            try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.1,  // Extremely factual
                                maxOutputTokens: 2048  // Adequate buffer for thinking + input + output
                            }
                        })
                    }
                );

                if (!response.ok) {
                    throw new Error(`API Error ${response.status}`);
                }

                const data = await response.json();

                // Check for MAX_TOKENS finish reason
                const finishReason = data.candidates?.[0]?.finishReason;
                if (finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during Telegram compression');
                    throw new Error('Token limit exceeded for Telegram compression.');
                }

                const summary = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No summary generated';

                if (summary === 'No summary generated') {
                    console.error('‚ùå Failed to generate Telegram summary. Finish reason:', finishReason);
                    throw new Error(`Telegram generation failed: ${finishReason || 'UNKNOWN'}`);
                }

                console.log('‚úÖ Telegram summary generated');
                return summary;

            } catch (error) {
                console.error('‚ùå Error generating Telegram summary:', error);
                throw error;
            }
        }

        /**
         * Update summary statistics display
         */
        function updateSummaryStats(summaryText) {
            if (!summaryText || summaryText.trim().length === 0) {
                document.getElementById('summaryWordCount').textContent = '0';
                document.getElementById('summarySeconds').textContent = '0';
                document.getElementById('compressionRatio').textContent = '0%';
                return;
            }

            // Calculate word count
            const words = summaryText.trim().split(/\s+/).length;

            // Calculate speaking time (150 words per minute = 2.5 words per second)
            const seconds = Math.ceil(words / 2.5);

            // Calculate compression ratio if original note exists
            let compressionRatio = 0;
            if (lastGeneratedNote && lastGeneratedNote.trim().length > 0) {
                const originalWords = lastGeneratedNote.trim().split(/\s+/).length;
                compressionRatio = Math.round((1 - words / originalWords) * 100);
            }

            // Update display
            document.getElementById('summaryWordCount').textContent = words;
            document.getElementById('summarySeconds').textContent = seconds;
            document.getElementById('compressionRatio').textContent = compressionRatio + '%';

            console.log(`üìä Stats: ${words} words, ${seconds}s, ${compressionRatio}% compression`);
        }

        /**
         * Copy attending summary to clipboard
         */
        function copyAttendingSummary() {
            const textarea = document.getElementById('attendingSummaryText');
            if (!textarea || !textarea.value) {
                alert('‚ùå No attending summary to copy. Generate a note first.');
                return;
            }

            textarea.select();
            textarea.setSelectionRange(0, 99999);

            try {
                document.execCommand('copy');
                alert('‚úÖ Attending summary copied to clipboard!');
                console.log('üìã Attending summary copied');
            } catch (err) {
                alert('‚ùå Failed to copy. Please select and copy manually.');
                console.error('Copy failed:', err);
            }
        }

        /**
         * Regenerate attending summary from last note
         */
        async function regenerateAttendingSummary() {
            if (!lastGeneratedNote || lastGeneratedNote.trim().length === 0) {
                alert('‚ùå No note available to regenerate summary. Generate a clinical note first.');
                return;
            }

            // Get selected compression mode
            const mode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';

            const textarea = document.getElementById('attendingSummaryText');
            if (textarea) {
                const modeLabel = mode === 'ultra' ? 'ULTRATHINK' : mode === 'telegram' ? 'Telegram' : 'Standard DOAP';
                textarea.value = `‚è≥ Regenerating ${modeLabel} summary...`;
            }

            try {
                let summary;
                if (mode === 'ultra') {
                    console.log('‚ö° Generating ULTRATHINK summary...');
                    summary = await generateUltraAttendingSummary(lastGeneratedNote);
                } else if (mode === 'telegram') {
                    console.log('üì± Generating Telegram summary...');
                    summary = await generateTelegramSummary(lastGeneratedNote);
                } else {
                    console.log('üìä Generating Standard DOAP summary...');
                    summary = await generateAttendingSummary(lastGeneratedNote);
                }

                displayAttendingSummary(summary);
                switchTab('attending');
            } catch (error) {
                if (textarea) {
                    textarea.value = `‚ùå Error: ${error.message}`;
                }
                alert(`Failed to regenerate attending summary: ${error.message}`);
            }
        }

        /**
         * Test attending summary generation with current note
         */
        async function testAttendingSummary() {
            console.log('üß™ TEST: Manual attending summary test triggered');

            // Get current note from output textarea
            const output = document.getElementById('output');
            if (!output || !output.value || output.value.trim().length === 0) {
                alert('‚ùå No clinical note found. Please generate a note first (Transcript, SOAP, or V6 Final Note).');
                return;
            }

            const currentNote = output.value;
            console.log('üß™ TEST: Found note with length:', currentNote.length);

            // Get selected compression mode
            const mode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
            const modeLabel = mode === 'ultra' ? 'ULTRATHINK' : mode === 'telegram' ? 'Telegram' : 'Standard DOAP';
            console.log(`üß™ TEST: Selected mode: ${modeLabel}`);

            // Show the attending tab immediately
            const tabButton = document.getElementById('attending-tab-button');
            if (tabButton) {
                tabButton.style.display = 'inline-block';
                switchTab('attending');
            }

            // Show loading message in textarea
            const textarea = document.getElementById('attendingSummaryText');
            if (textarea) {
                textarea.value = `‚è≥ Generating ${modeLabel} summary...\n\nPlease wait...`;
            }

            try {
                let summary;
                if (mode === 'ultra') {
                    console.log('üß™ TEST: Calling generateUltraAttendingSummary...');
                    summary = await generateUltraAttendingSummary(currentNote);
                } else if (mode === 'telegram') {
                    console.log('üß™ TEST: Calling generateTelegramSummary...');
                    summary = await generateTelegramSummary(currentNote);
                } else {
                    console.log('üß™ TEST: Calling generateAttendingSummary...');
                    summary = await generateAttendingSummary(currentNote);
                }

                if (summary) {
                    console.log('üß™ TEST: Summary received, length:', summary.length);
                    displayAttendingSummary(summary);
                    alert(`‚úÖ Test successful! ${modeLabel} summary generated.`);
                } else {
                    console.error('üß™ TEST: No summary returned');
                    alert('‚ùå Test failed: No summary returned from API');
                }
            } catch (error) {
                console.error('üß™ TEST: Error:', error);
                if (textarea) {
                    textarea.value = `‚ùå Error: ${error.message}`;
                }
                alert(`‚ùå Test failed: ${error.message}`);
            }
        }

        /**
         * Update SOAP statistics in real-time
         */
        function updateSOAPStats() {
            const subjective = document.getElementById('soapSubjective').value.trim();
            const objective = document.getElementById('soapObjective').value.trim();
            const assessment = document.getElementById('soapAssessment').value.trim();
            const plan = document.getElementById('soapPlan').value.trim();

            // Count total words
            const allText = `${subjective} ${objective} ${assessment} ${plan}`;
            const wordCount = allText.trim() ? allText.trim().split(/\s+/).length : 0;
            document.getElementById('soapTotalWords').textContent = wordCount;

            // Count completed sections
            let sectionCount = 0;
            if (subjective) sectionCount++;
            if (objective) sectionCount++;
            if (assessment) sectionCount++;
            if (plan) sectionCount++;
            document.getElementById('soapSectionCount').textContent = `${sectionCount}/4`;
        }

        /**
         * SOAP UNIFIED INPUT PARSERS
         * Three-tier parsing strategy for single-textbox SOAP input
         */

        /**
         * Tier 1: Regex-based SOAP section detector (Fast path - handles 70-80% of cases)
         * Detects labeled sections: "S:", "Subjective:", etc.
         * Returns: { success: boolean, data: {S, O, A, P}, confidence: number }
         */
        function detectSOAPSections(text) {
            if (!text || !text.trim()) {
                return { success: false, data: null, confidence: 0 };
            }

            // Common SOAP section markers (case-insensitive)
            const patterns = {
                subjective: /(?:^|\n)\s*(?:S(?:ubjective)?|SUBJECTIVE|Chief Complaint)\s*[:Ôºö]\s*([^\n]*(?:\n(?!(?:O(?:bjective)?|A(?:ssessment)?|P(?:lan)?)\s*[:Ôºö])[^\n]*)*)/i,
                objective: /(?:^|\n)\s*(?:O(?:bjective)?|OBJECTIVE|Exam(?:ination)?)\s*[:Ôºö]\s*([^\n]*(?:\n(?!(?:A(?:ssessment)?|P(?:lan)?)\s*[:Ôºö])[^\n]*)*)/i,
                assessment: /(?:^|\n)\s*(?:A(?:ssessment)?|ASSESSMENT|Diagnosis|Impression)\s*[:Ôºö]\s*([^\n]*(?:\n(?!(?:P(?:lan)?)\s*[:Ôºö])[^\n]*)*)/i,
                plan: /(?:^|\n)\s*(?:P(?:lan)?|PLAN|Treatment|Recommendations?)\s*[:Ôºö]\s*([\s\S]*)/i
            };

            const result = {
                subjective: '',
                objective: '',
                assessment: '',
                plan: ''
            };

            let sectionsFound = 0;

            // Try to match each section
            for (const [key, pattern] of Object.entries(patterns)) {
                const match = text.match(pattern);
                if (match && match[1]) {
                    result[key] = match[1].trim();
                    if (result[key].length > 0) sectionsFound++;
                }
            }

            // Calculate confidence based on sections found and formatting
            let confidence = 0;
            if (sectionsFound >= 2) {
                confidence = Math.min(95, sectionsFound * 25); // 2 sections = 50%, 3 = 75%, 4 = 100%

                // Bonus for proper formatting (labels present)
                const hasLabels = /(?:S(?:ubjective)?|O(?:bjective)?|A(?:ssessment)?|P(?:lan)?)\s*[:Ôºö]/i.test(text);
                if (hasLabels) confidence = Math.min(95, confidence + 10);
            }

            return {
                success: sectionsFound >= 2, // At least 2 sections needed for regex success
                data: result,
                confidence: confidence,
                sectionsFound: sectionsFound
            };
        }

        /**
         * Tier 2: AI-powered SOAP parser (Accurate path - handles ambiguous/unlabeled cases)
         * Uses Gemini to intelligently parse unstructured clinical text into SOAP format
         */
        async function aiParseSOAP(text) {
            if (!API_KEY) {
                throw new Error('API key not configured');
            }

            const prompt = `You are a clinical documentation expert. Parse the following clinical text into SOAP format.

CRITICAL INSTRUCTIONS:
1. Extract information into 4 categories: Subjective, Objective, Assessment, Plan
2. DO NOT add information not present in the original text
3. DO NOT infer or make assumptions
4. Preserve exact medical terminology and measurements
5. If a section is empty, return empty string
6. Output ONLY valid JSON in this exact format:

{
  "subjective": "patient's symptoms and history",
  "objective": "physical exam findings, vital signs, labs",
  "assessment": "diagnosis, clinical impression",
  "plan": "treatment recommendations, follow-up"
}

CLINICAL TEXT TO PARSE:
${text}

OUTPUT (JSON only, no markdown, no explanation):`;

            try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.1, // Maximum accuracy for parsing
                                maxOutputTokens: 8192 // Increased to handle thinking tokens + JSON output
                            }
                        })
                    }
                );

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();

                // Check for MAX_TOKENS finish reason
                if (data.candidates?.[0]?.finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during SOAP parsing');
                    throw new Error('Response too long. Try shortening the input note.');
                }

                // Extract response text
                const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!responseText) {
                    const finishReason = data.candidates?.[0]?.finishReason || 'UNKNOWN';
                    console.error('‚ùå No response text generated. Finish reason:', finishReason);
                    console.error('Response data:', JSON.stringify(data, null, 2));
                    throw new Error(`AI generation failed: ${finishReason}`);
                }

                // Clean up response (remove markdown code blocks if present)
                const cleanedText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                // Parse JSON response
                const parsed = JSON.parse(cleanedText);

                // Validate structure
                if (typeof parsed === 'object' &&
                    'subjective' in parsed &&
                    'objective' in parsed &&
                    'assessment' in parsed &&
                    'plan' in parsed) {
                    return {
                        success: true,
                        data: {
                            subjective: parsed.subjective || '',
                            objective: parsed.objective || '',
                            assessment: parsed.assessment || '',
                            plan: parsed.plan || ''
                        },
                        confidence: 85 // AI parsing gets 85% confidence
                    };
                } else {
                    throw new Error('Invalid JSON structure from AI');
                }
            } catch (error) {
                console.error('‚ùå AI parsing failed:', error);
                return {
                    success: false,
                    data: null,
                    confidence: 0,
                    error: error.message
                };
            }
        }

        /**
         * Tier 3: Orchestrator function - Coordinates regex and AI parsing
         * Strategy: Try regex first (fast), fall back to AI if needed (accurate)
         */
        async function parseSOAPInput(text, forceAI = false) {
            console.log('üîç Parsing SOAP input...', { length: text.length, forceAI });

            // Step 1: Try regex parsing first (unless forced to use AI)
            if (!forceAI) {
                const regexResult = detectSOAPSections(text);
                console.log('üìä Regex parsing result:', regexResult);

                // If regex parsing successful with high confidence, use it
                if (regexResult.success && regexResult.confidence >= 70) {
                    console.log('‚úÖ Using regex parsing (fast path)');
                    return {
                        ...regexResult,
                        method: 'regex'
                    };
                }

                // If regex found some sections but low confidence, show preview and ask
                if (regexResult.sectionsFound >= 1 && regexResult.confidence < 70) {
                    console.log('‚ö†Ô∏è Regex found sections but low confidence, falling back to AI');
                }
            }

            // Step 2: Fall back to AI parsing
            console.log('ü§ñ Using AI parsing (accurate path)');
            const aiResult = await aiParseSOAP(text);

            if (aiResult.success) {
                return {
                    ...aiResult,
                    method: 'ai'
                };
            }

            // Step 3: Both failed - return error
            return {
                success: false,
                data: null,
                confidence: 0,
                method: 'none',
                error: 'Both regex and AI parsing failed'
            };
        }

        /**
         * SOAP MODE TOGGLE & UI FUNCTIONS
         */

        // Current SOAP input mode ('simple' or 'advanced')
        let currentSOAPMode = 'simple';

        /**
         * Switch between Simple (unified) and Advanced (4-box) SOAP input modes
         */
        function switchSOAPMode(mode) {
            currentSOAPMode = mode;

            const unifiedContainer = document.getElementById('soapUnifiedContainer');
            const separateContainer = document.getElementById('soapSeparateContainer');
            const simpleModeBtn = document.getElementById('simpleModeBtn');
            const advancedModeBtn = document.getElementById('advancedModeBtn');
            const modeDescription = document.getElementById('modeDescription');

            if (mode === 'simple') {
                // Show unified textarea, hide 4 boxes
                unifiedContainer.style.display = 'block';
                separateContainer.style.display = 'none';

                // Update button styles
                simpleModeBtn.style.background = '#2196F3';
                simpleModeBtn.style.color = 'white';
                advancedModeBtn.style.background = '#E0E0E0';
                advancedModeBtn.style.color = '#666';

                // Update description
                modeDescription.innerHTML = '<strong>Simple:</strong> Enter all SOAP sections in one textbox (AI will intelligently parse sections)';

                console.log('‚úÖ Switched to Simple mode (unified input)');
            } else {
                // Show 4 boxes, hide unified textarea
                unifiedContainer.style.display = 'none';
                separateContainer.style.display = 'block';

                // Update button styles
                simpleModeBtn.style.background = '#E0E0E0';
                simpleModeBtn.style.color = '#666';
                advancedModeBtn.style.background = '#2196F3';
                advancedModeBtn.style.color = 'white';

                // Update description
                modeDescription.innerHTML = '<strong>Advanced:</strong> Enter each SOAP section separately in dedicated textboxes';

                console.log('‚úÖ Switched to Advanced mode (4-box input)');
            }

            // Update stats for current mode
            if (mode === 'simple') {
                updateUnifiedStats();
            } else {
                updateSOAPStats();
            }
        }

        /**
         * Update statistics for unified SOAP textarea
         */
        function updateUnifiedStats() {
            const unifiedText = document.getElementById('soapUnifiedInput').value.trim();
            const wordCount = unifiedText ? unifiedText.split(/\s+/).length : 0;

            document.getElementById('soapTotalWords').textContent = wordCount;

            // For unified mode, section count is shown as "Unified"
            document.getElementById('soapSectionCount').textContent = 'Unified';

            // Reset parse indicators when text changes (user needs to re-parse)
            const parseMethod = document.getElementById('parseMethod');
            const parseConfidence = document.getElementById('parseConfidence');
            if (parseMethod && parseMethod.textContent !== 'Not parsed') {
                parseMethod.textContent = 'Not parsed';
                parseMethod.style.background = '#F5F5F5';
                parseMethod.style.color = '#999';
                parseConfidence.textContent = '';

                // Clear stored parsed data (will trigger fresh parsing on generate)
                if (soapQuickEntry && (soapQuickEntry.subjective || soapQuickEntry.objective ||
                    soapQuickEntry.assessment || soapQuickEntry.plan)) {
                    soapQuickEntry = { subjective: '', objective: '', assessment: '', plan: '' };
                }
            }
        }

        /**
         * Preview how SOAP will be parsed from unified input
         */
        async function previewSOAPParsing() {
            const unifiedText = document.getElementById('soapUnifiedInput').value.trim();

            if (!unifiedText) {
                alert('‚ö†Ô∏è Please enter some clinical notes first.');
                return;
            }

            // Show loading state
            const parseMethod = document.getElementById('parseMethod');
            const parseConfidence = document.getElementById('parseConfidence');
            parseMethod.textContent = 'Parsing...';
            parseMethod.style.background = '#FFF9C4';
            parseConfidence.textContent = '';

            try {
                // Try to parse using orchestrator
                const result = await parseSOAPInput(unifiedText);

                console.log('üìä Parse result:', result);

                if (result.success) {
                    // Update UI indicators
                    parseMethod.textContent = result.method === 'regex' ? '‚ö° Regex' : 'ü§ñ AI';
                    parseMethod.style.background = result.method === 'regex' ? '#C8E6C9' : '#E1F5FE';
                    parseConfidence.textContent = `Confidence: ${result.confidence}%`;

                    // Show preview modal with parsed sections
                    showParsePreviewModal(result.data, result.method, result.confidence);
                } else {
                    parseMethod.textContent = '‚ùå Failed';
                    parseMethod.style.background = '#FFCDD2';
                    parseConfidence.textContent = result.error || 'Unable to parse';
                    alert('‚ùå Unable to parse SOAP sections. Please check your input format.');
                }
            } catch (error) {
                console.error('‚ùå Parsing error:', error);
                parseMethod.textContent = '‚ùå Error';
                parseMethod.style.background = '#FFCDD2';
                parseConfidence.textContent = error.message;
                alert('‚ùå Error parsing SOAP: ' + error.message);
            }
        }

        // Temporary storage for parsed data during modal preview
        let tempParsedData = null;

        /**
         * Show modal with parsed SOAP sections for user confirmation
         */
        function showParsePreviewModal(parsedData, method, confidence) {
            // Store data in temporary variable (safer than inline JSON)
            tempParsedData = parsedData;

            const modal = document.createElement('div');
            modal.id = 'soapPreviewModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            const methodLabel = method === 'regex' ? '‚ö° Fast Regex Parsing' : 'ü§ñ AI Parsing';
            const methodColor = method === 'regex' ? '#4CAF50' : '#2196F3';

            // Escape HTML in parsed data to prevent XSS
            const escapeHtml = (text) => {
                if (!text) return '<i style="color: #999;">Empty</i>';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };

            modal.innerHTML = `
                <div style="background: white; padding: 24px; border-radius: 8px; max-width: 700px; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h3 style="margin: 0; color: #333;">üîç SOAP Parsing Preview</h3>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <span style="font-size: 0.8rem; padding: 4px 10px; background: ${methodColor}; color: white; border-radius: 4px; font-weight: 600;">
                                ${methodLabel}
                            </span>
                            <span style="font-size: 0.8rem; padding: 4px 10px; background: #E0E0E0; border-radius: 4px;">
                                ${confidence}% confidence
                            </span>
                        </div>
                    </div>

                    <div style="background: #F5F5F5; padding: 12px; border-radius: 6px; margin-bottom: 16px; font-size: 0.85rem; color: #666;">
                        ‚ÑπÔ∏è Review the parsed sections below. Click "Use This Parsing" to proceed with generation.
                    </div>

                    <div style="margin-bottom: 12px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">üìù Subjective:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.subjective)}
                        </div>
                    </div>

                    <div style="margin-bottom: 12px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">üî¨ Objective:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.objective)}
                        </div>
                    </div>

                    <div style="margin-bottom: 12px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">ü©∫ Assessment:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.assessment)}
                        </div>
                    </div>

                    <div style="margin-bottom: 16px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">üíä Plan:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.plan)}
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeParsePreviewModal()"
                                style="padding: 10px 20px; background: #E0E0E0; color: #666; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                            ‚ùå Cancel
                        </button>
                        <button onclick="acceptParsedSOAPFromModal()"
                                style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                            ‚úÖ Use This Parsing
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        /**
         * Close the SOAP preview modal
         */
        function closeParsePreviewModal() {
            const modal = document.getElementById('soapPreviewModal');
            if (modal) {
                modal.remove();
            }
            tempParsedData = null;
        }

        /**
         * Accept parsed data from modal and close
         */
        function acceptParsedSOAPFromModal() {
            if (tempParsedData) {
                acceptParsedSOAP(tempParsedData);
            }
            closeParsePreviewModal();
        }

        /**
         * Accept parsed SOAP data and populate the 4-box fields (for verification or editing)
         */
        function acceptParsedSOAP(parsedData) {
            // Store in soapQuickEntry for generation
            soapQuickEntry = {
                subjective: parsedData.subjective || '',
                objective: parsedData.objective || '',
                assessment: parsedData.assessment || '',
                plan: parsedData.plan || ''
            };

            console.log('‚úÖ Accepted parsed SOAP data:', soapQuickEntry);

            // Update parse method indicator
            const parseMethod = document.getElementById('parseMethod');
            parseMethod.textContent = '‚úÖ Parsed';
            parseMethod.style.background = '#C8E6C9';
            parseMethod.style.color = '#2E7D32';

            alert('‚úÖ SOAP sections parsed successfully! You can now generate the clinical note.');
        }

        /**
         * Validate SOAP entry before generation (supports both Simple and Advanced modes)
         */
        async function validateSOAPEntry() {
            let subjective, objective, assessment, plan;

            // MODE 1: SIMPLE (Unified Textarea) - Parse the text
            if (currentSOAPMode === 'simple') {
                const unifiedText = document.getElementById('soapUnifiedInput').value.trim();

                if (!unifiedText) {
                    alert('‚ö†Ô∏è Please enter clinical notes before generating.');
                    return false;
                }

                console.log('üîç Simple mode: Parsing unified SOAP input...');

                // Check if already parsed (user clicked "Preview Parsing" and accepted)
                if (soapQuickEntry &&
                    (soapQuickEntry.subjective || soapQuickEntry.objective ||
                     soapQuickEntry.assessment || soapQuickEntry.plan)) {
                    console.log('‚úÖ Using previously parsed SOAP data');
                    subjective = soapQuickEntry.subjective;
                    objective = soapQuickEntry.objective;
                    assessment = soapQuickEntry.assessment;
                    plan = soapQuickEntry.plan;
                } else {
                    // Parse on-the-fly
                    console.log('‚ö° Auto-parsing SOAP input...');
                    try {
                        const parseResult = await parseSOAPInput(unifiedText);

                        if (!parseResult.success) {
                            alert('‚ùå Unable to parse SOAP sections. Please check your input format or use "Preview Parsing" first.');
                            return false;
                        }

                        // Store parsed data
                        soapQuickEntry = {
                            subjective: parseResult.data.subjective || '',
                            objective: parseResult.data.objective || '',
                            assessment: parseResult.data.assessment || '',
                            plan: parseResult.data.plan || ''
                        };

                        subjective = soapQuickEntry.subjective;
                        objective = soapQuickEntry.objective;
                        assessment = soapQuickEntry.assessment;
                        plan = soapQuickEntry.plan;

                        console.log(`‚úÖ Auto-parsed using ${parseResult.method} (${parseResult.confidence}% confidence)`);
                    } catch (error) {
                        console.error('‚ùå Parsing error:', error);
                        alert('‚ùå Error parsing SOAP: ' + error.message);
                        return false;
                    }
                }
            }
            // MODE 2: ADVANCED (4 Separate Textboxes) - Read directly
            else {
                subjective = document.getElementById('soapSubjective').value.trim();
                objective = document.getElementById('soapObjective').value.trim();
                assessment = document.getElementById('soapAssessment').value.trim();
                plan = document.getElementById('soapPlan').value.trim();

                // At least one section must have content
                if (!subjective && !objective && !assessment && !plan) {
                    alert('‚ö†Ô∏è Please enter information in at least one SOAP section before generating.');
                    return false;
                }

                // Store values
                soapQuickEntry = {
                    subjective: subjective,
                    objective: objective,
                    assessment: assessment,
                    plan: plan
                };
            }

            // Common validation for both modes
            // Warning if assessment empty (but allow to proceed)
            if (!assessment && (subjective || objective || plan)) {
                const proceed = confirm('‚ö†Ô∏è Assessment section is empty. Proceed without diagnosis/impression?');
                if (!proceed) return false;
            }

            console.log('‚úÖ SOAP validation passed');
            console.log(`üìä SOAP Entry: S=${subjective.length} O=${objective.length} A=${assessment.length} P=${plan.length} chars`);
            console.log(`Mode: ${currentSOAPMode}`);
            return true;
        }

        /**
         * Determine which input panel is active (transcript or SOAP)
         */
        function detectActiveInputPanel() {
            // Check if SOAP panel has content (both unified and separate modes)
            let soapHasContent = false;

            if (currentSOAPMode === 'simple') {
                soapHasContent = document.getElementById('soapUnifiedInput').value.trim();
            } else {
                soapHasContent =
                    document.getElementById('soapSubjective').value.trim() ||
                    document.getElementById('soapObjective').value.trim() ||
                    document.getElementById('soapAssessment').value.trim() ||
                    document.getElementById('soapPlan').value.trim();
            }

            // Check if transcript has content
            const transcriptHasContent = document.getElementById('transcript').value.trim();

            // If SOAP has content, use SOAP mode
            if (soapHasContent) {
                activeInputPanel = 'soap';
                return 'soap';
            }

            // Otherwise default to transcript mode
            activeInputPanel = 'transcript';
            return 'transcript';
        }

        // ============================================================
        // CONSULTATION TYPE FUNCTIONS
        // ============================================================

        function selectConsultType(type) {
            consultationType = type;

            // Update button styles
            const newBtn = document.getElementById('consultTypeNew');
            const followupBtn = document.getElementById('consultTypeFollowup');
            const descDiv = document.getElementById('consultTypeDescription');

            if (type === 'new') {
                newBtn.style.background = '#4A90E2';
                newBtn.style.color = 'white';
                newBtn.style.borderColor = '#4A90E2';

                followupBtn.style.background = 'white';
                followupBtn.style.color = '#333';
                followupBtn.style.borderColor = '#E1E4E8';

                descDiv.innerHTML = '<strong>New Consultation:</strong> Comprehensive initial assessment with full history, examination, and workup.';
            } else {
                followupBtn.style.background = '#4A90E2';
                followupBtn.style.color = 'white';
                followupBtn.style.borderColor = '#4A90E2';

                newBtn.style.background = 'white';
                newBtn.style.color = '#333';
                newBtn.style.borderColor = '#E1E4E8';

                descDiv.innerHTML = '<strong>Follow-up Visit:</strong> Interval history, treatment response, updated assessment, and plan modifications.';
            }

            console.log(`‚úÖ Consultation type set to: ${type}`);
        }

        // ============================================================
        // REAL-TIME MONITORING FUNCTIONS
        // ============================================================

        function checkForRedFlags(text) {
            if (!selectedPathology || !activeRedFlags || activeRedFlags.length === 0) {
                return;
            }

            const lowerText = text.toLowerCase();
            const detectedFlags = [];

            for (const flag of activeRedFlags) {
                if (lowerText.includes(flag.toLowerCase())) {
                    detectedFlags.push(flag);
                }
            }

            if (detectedFlags.length > 0) {
                // Display alert in status area
                const status = document.getElementById('status');
                const originalStatus = status.textContent;
                const originalClass = status.className;

                status.className = 'status disconnected';
                status.innerHTML = `‚ö†Ô∏è RED FLAG DETECTED: ${detectedFlags[0]}`;

                // Revert after 5 seconds
                setTimeout(() => {
                    if (isRecording) {
                        status.className = 'status recording';
                        status.textContent = 'üî¥ Recording in progress...';
                    } else {
                        status.className = originalClass;
                        status.textContent = originalStatus;
                    }
                }, 5000);

                console.log('üö® Red flags detected:', detectedFlags);
            }
        }

        function checkForScaleComponents(text) {
            if (!selectedPathology) {
                return;
            }

            // Get recommended scales for current pathology
            const pathologyData = PathologyDatabase[selectedPathology];
            if (!pathologyData || !pathologyData.recommendedScales) {
                return;
            }

            const lowerText = text.toLowerCase();
            const detectedComponents = [];

            // Check each recommended scale's keywords
            for (const scaleId of pathologyData.recommendedScales) {
                const scale = ClinicalScalesDatabase[scaleId];
                if (!scale) continue;

                for (const question of scale.questions) {
                    if (!question.keywords) continue;

                    for (const keyword of question.keywords) {
                        if (lowerText.includes(keyword.toLowerCase())) {
                            detectedComponents.push({
                                scale: scale.shortName,
                                scaleId: scaleId,
                                question: question.text,
                                questionId: question.id,
                                keyword: keyword
                            });
                            break; // Only detect once per question
                        }
                    }
                }
            }

            if (detectedComponents.length > 0) {
                // Log detected components
                console.log('üìä Scale components detected:', detectedComponents);

                // Could add visual indicator here if desired
                // For now, just log to console for physician review

                // Optional: Show subtle notification (non-intrusive)
                const component = detectedComponents[0];
                console.log(`‚úì ${component.scale} - ${component.question.substring(0, 50)}...`);
            }
        }

        // ============================================================
        // CLINICAL SCALES FUNCTIONS
        // ============================================================

        function initializeScales() {
            try {
                // Check if database is loaded
                if (typeof ClinicalScalesDatabase === 'undefined') {
                    console.error('‚ùå ClinicalScalesDatabase not loaded');
                    alert('Error: Clinical scales database failed to load. Please refresh the page.');
                    return false;
                }

                // Populate scale selector dropdown
                const select = document.getElementById('scaleSelect');
                if (!select) {
                    console.error('‚ùå Scale selector element not found');
                    return false;
                }

                // Clear existing options except first
                while (select.options.length > 1) {
                    select.remove(1);
                }

                // Add all available scales
                let scalesAdded = 0;
                for (const scaleId in ClinicalScalesDatabase) {
                    const scale = ClinicalScalesDatabase[scaleId];
                    if (scale && scale.name && scale.shortName) {
                        const option = document.createElement('option');
                        option.value = scaleId;
                        option.textContent = `${scale.shortName} - ${scale.name}`;
                        select.appendChild(option);
                        scalesAdded++;
                    }
                }

                console.log(`‚úÖ Clinical scales initialized: ${scalesAdded} scales loaded`);
                return true;
            } catch (error) {
                console.error('‚ùå Error initializing scales:', error);
                alert('Error initializing clinical scales. Please refresh the page.');
                return false;
            }
        }

        function loadScaleForm() {
            const scaleId = document.getElementById('scaleSelect').value;

            if (!scaleId) {
                document.getElementById('scaleFormContainer').style.display = 'none';
                document.getElementById('scalesPlaceholder').style.display = 'block';
                document.getElementById('scaleResults').style.display = 'none';
                return;
            }

            currentScale = ClinicalScalesDatabase[scaleId];

            // Initialize responses object for this scale if not exists
            if (!scaleResponses[scaleId]) {
                scaleResponses[scaleId] = {};
            }

            // Show form container, hide placeholder
            document.getElementById('scaleFormContainer').style.display = 'block';
            document.getElementById('scalesPlaceholder').style.display = 'none';
            document.getElementById('scaleResults').style.display = 'none';

            // Display scale description
            const descDiv = document.getElementById('scaleDescription');
            descDiv.innerHTML = `
                <h3 style="margin: 0 0 10px 0; color: #0066CC;">${currentScale.name}</h3>
                <p style="margin: 0 0 8px 0; font-size: 0.95rem;">${currentScale.description}</p>
                <p style="margin: 0; font-size: 0.85rem; color: #666;">
                    <strong>Range:</strong> ${currentScale.minScore}-${currentScale.maxScore} |
                    <strong>Evidence Level:</strong> ${currentScale.evidenceLevel}
                </p>
            `;

            // Generate form questions
            const questionsDiv = document.getElementById('scaleQuestions');
            questionsDiv.innerHTML = '';

            currentScale.questions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.style.cssText = 'background: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; border: 2px solid #ddd;';

                // Question header
                let questionHTML = `
                    <div style="margin-bottom: 12px;">
                        <span style="background: #0066CC; color: white; padding: 4px 10px; border-radius: 4px; font-weight: 600; margin-right: 8px;">
                            Q${index + 1}
                        </span>
                        ${question.section ? `<span style="color: #666; font-size: 0.9rem;">${question.section}</span>` : ''}
                    </div>
                    <div style="font-weight: 600; margin-bottom: 15px; color: #333; font-size: 1.05rem;">
                        ${question.text}
                    </div>
                `;

                // Generate input based on question type
                if (question.type === 'slider') {
                    // Slider for VAS pain scale
                    questionHTML += `
                        <div style="margin: 15px 0;">
                            <input type="range"
                                id="scale_${scaleId}_${question.id}"
                                min="0" max="10"
                                value="${scaleResponses[scaleId][question.id] || 5}"
                                oninput="updateSliderValue('${scaleId}', '${question.id}', this.value)"
                                style="width: 100%; height: 8px; border-radius: 5px; background: #ddd; outline: none; cursor: pointer;">
                            <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.9rem; color: #666;">
                                <span>0 (No Pain)</span>
                                <span id="slider_value_${scaleId}_${question.id}" style="font-weight: 600; color: #0066CC; font-size: 1.2rem;">
                                    ${scaleResponses[scaleId][question.id] || 5}
                                </span>
                                <span>10 (Worst Pain)</span>
                            </div>
                        </div>
                    `;
                } else {
                    // Radio buttons for standard scales
                    questionHTML += '<div style="margin-top: 10px;">';
                    question.options.forEach((option) => {
                        const isChecked = scaleResponses[scaleId][question.id] === option.value ? 'checked' : '';
                        questionHTML += `
                            <label style="display: flex; align-items: flex-start; padding: 12px; margin-bottom: 8px; border: 2px solid ${isChecked ? '#0066CC' : '#e0e0e0'}; border-radius: 6px; cursor: pointer; background: ${isChecked ? '#e3f2fd' : 'white'}; transition: all 0.2s;">
                                <input type="radio"
                                    name="scale_${scaleId}_${question.id}"
                                    value="${option.value}"
                                    onchange="updateScaleResponse('${scaleId}', '${question.id}', ${option.value})"
                                    ${isChecked}
                                    style="margin-right: 12px; margin-top: 4px; transform: scale(1.2);">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: #333; margin-bottom: 4px;">${option.label}</div>
                                    ${option.description ? `<div style="font-size: 0.85rem; color: #666;">${option.description}</div>` : ''}
                                </div>
                            </label>
                        `;
                    });
                    questionHTML += '</div>';
                }

                questionDiv.innerHTML = questionHTML;
                questionsDiv.appendChild(questionDiv);
            });
        }

        function updateSliderValue(scaleId, questionId, value) {
            // Update display
            document.getElementById(`slider_value_${scaleId}_${questionId}`).textContent = value;
            // Store response
            scaleResponses[scaleId][questionId] = parseInt(value);
            // Save to localStorage
            saveScaleResponsesToStorage();
        }

        function updateScaleResponse(scaleId, questionId, value) {
            // Store the response
            scaleResponses[scaleId][questionId] = value;

            // Save to localStorage
            saveScaleResponsesToStorage();

            // Update all radio labels to reflect selection visually
            const radios = document.getElementsByName(`scale_${scaleId}_${questionId}`);
            radios.forEach(radio => {
                const label = radio.parentElement;
                if (radio.checked) {
                    label.style.borderColor = '#0066CC';
                    label.style.background = '#e3f2fd';
                } else {
                    label.style.borderColor = '#e0e0e0';
                    label.style.background = 'white';
                }
            });
        }

        function saveScaleResponsesToStorage() {
            try {
                const dataToSave = {
                    responses: scaleResponses,
                    scores: calculatedScores,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('neuroscribe_scale_data', JSON.stringify(dataToSave));
                console.log('‚úÖ Scale data saved to localStorage');
            } catch (error) {
                console.error('‚ùå Error saving scale data:', error);
            }
        }

        function loadScaleResponsesFromStorage() {
            try {
                const saved = localStorage.getItem('neuroscribe_scale_data');
                if (saved) {
                    const data = JSON.parse(saved);
                    scaleResponses = data.responses || {};
                    calculatedScores = data.scores || {};
                    console.log(`‚úÖ Scale data loaded from localStorage (saved: ${data.timestamp})`);
                    return true;
                }
            } catch (error) {
                console.error('‚ùå Error loading scale data:', error);
            }
            return false;
        }

        function clearScaleData() {
            if (confirm('Are you sure you want to clear all scale responses and scores? This cannot be undone.')) {
                scaleResponses = {};
                calculatedScores = {};
                localStorage.removeItem('neuroscribe_scale_data');
                // Reset current scale if loaded
                if (currentScale) {
                    loadScaleForm(); // Reload the form to show empty state
                }
                alert('‚úÖ All scale data cleared');
                console.log('‚úÖ Scale data cleared');
            }
        }

        function calculateScale() {
            try {
                if (!currentScale) {
                    alert('Please select a clinical scale first.');
                    return;
                }

                const scaleId = currentScale.id;
                const responses = scaleResponses[scaleId] || {};

                // Validate that at least some questions are answered
                const answeredCount = Object.keys(responses).filter(key => responses[key] !== null && responses[key] !== undefined).length;

                if (answeredCount === 0) {
                    alert('Please answer at least one question before calculating the score.');
                    return;
                }

                // Warn if not all questions answered
                if (answeredCount < currentScale.questions.length) {
                    const proceed = confirm(`Only ${answeredCount} out of ${currentScale.questions.length} questions answered. Score may be incomplete. Continue?`);
                    if (!proceed) return;
                }

                // Update scale object with current responses
                currentScale.questions.forEach(q => {
                    q.value = responses[q.id] !== undefined ? responses[q.id] : null;
                });

                // Calculate score using scale's scoring function
                if (typeof currentScale.scoring !== 'function') {
                    throw new Error('Scale scoring function not found');
                }

                const scoreResult = currentScale.scoring(responses);
                if (!scoreResult) {
                    throw new Error('Score calculation failed');
                }

                calculatedScores[scaleId] = scoreResult;

                // Get interpretation
                let interpretation;
                if (typeof currentScale.interpretation !== 'function') {
                    // Provide default interpretation if function missing
                    interpretation = {
                        severity: 'Score Calculated',
                        color: '#0066CC',
                        description: 'Score calculated successfully',
                        recommendation: 'Review clinical context'
                    };
                } else {
                    if (scaleId === 'ndi' || scaleId === 'odi') {
                        interpretation = currentScale.interpretation(scoreResult.percentage);
                    } else if (scaleId === 'vas_pain') {
                        interpretation = currentScale.interpretation(scoreResult.overallAverage);
                    } else {
                        interpretation = currentScale.interpretation(scoreResult.total);
                    }
                }

                // Display results
                displayScaleResults(currentScale, scoreResult, interpretation);

                console.log(`‚úÖ ${currentScale.shortName} calculated:`, scoreResult);

            } catch (error) {
                console.error('‚ùå Error calculating scale:', error);
                alert(`Error calculating scale: ${error.message}. Please try again.`);
            }
        }

        function displayScaleResults(scale, scoreResult, interpretation) {
            const resultsDiv = document.getElementById('scaleResults');
            resultsDiv.style.display = 'block';

            let resultsHTML = `
                <h3 style="margin: 0 0 20px 0; color: #0066CC; display: flex; align-items: center; justify-content: space-between;">
                    ${scale.shortName} Results
                    <span style="background: ${interpretation.color}; color: white; padding: 6px 12px; border-radius: 6px; font-size: 0.9rem;">
                        ${interpretation.severity}
                    </span>
                </h3>
            `;

            // Score display based on scale type
            if (scale.id === 'vas_pain') {
                resultsHTML += `
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid ${interpretation.color};">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Current Pain</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.current !== null ? scoreResult.current : 'N/A'}</div>
                            </div>
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Worst (24h)</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.worst !== null ? scoreResult.worst : 'N/A'}</div>
                            </div>
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Average</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.average !== null ? scoreResult.average : 'N/A'}</div>
                            </div>
                        </div>
                    </div>
                `;
            } else if (scale.id === 'ndi' || scale.id === 'odi') {
                resultsHTML += `
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid ${interpretation.color};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Raw Score</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.total} / ${scoreResult.max}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Disability Index</div>
                                <div style="font-size: 2.5rem; font-weight: 600; color: ${interpretation.color};">${scoreResult.percentage}%</div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                resultsHTML += `
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid ${interpretation.color};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Total Score</div>
                                <div style="font-size: 2.5rem; font-weight: 600; color: #333;">${scoreResult.total}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Range</div>
                                <div style="font-size: 1.2rem; color: #666;">${scale.minScore} - ${scale.maxScore}</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Completion status
            resultsHTML += `
                <div style="background: ${scoreResult.percentage === 100 ? '#d4edda' : '#fff3cd'}; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                    <strong>Completion:</strong> ${scoreResult.answered} / ${scoreResult.totalQuestions} questions answered (${scoreResult.percentage}%)
                    ${scoreResult.percentage < 100 ? '<div style="margin-top: 5px; font-size: 0.9rem; color: #856404;">‚ö†Ô∏è Score may be inaccurate - not all questions answered</div>' : ''}
                </div>
            `;

            // Interpretation
            resultsHTML += `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="font-weight: 600; color: #333; margin-bottom: 8px;">Clinical Interpretation:</div>
                    <div style="color: #555; margin-bottom: 10px;">${interpretation.description}</div>
                    <div style="background: white; padding: 12px; border-radius: 6px; border-left: 4px solid #0066CC;">
                        <strong>Recommendation:</strong> ${interpretation.recommendation}
                    </div>
                </div>
            `;

            // Evidence and references
            if (scale.references && scale.references.length > 0) {
                resultsHTML += `
                    <div style="font-size: 0.85rem; color: #666; padding-top: 12px; border-top: 1px solid #ddd;">
                        <strong>References:</strong><br>
                        ${scale.references.map(ref => `‚Ä¢ ${ref}`).join('<br>')}
                    </div>
                `;
            }

            resultsDiv.innerHTML = resultsHTML;

            // Scroll to results
            resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // Load scales based on selected pathology
        function loadRecommendedScales(pathologyId) {
            if (!pathologyId) return;

            const select = document.getElementById('scaleSelect');

            // Get scales that match this pathology
            const recommendedScales = [];
            for (const scaleId in ClinicalScalesDatabase) {
                const scale = ClinicalScalesDatabase[scaleId];
                if (scale.pathologies.includes(pathologyId)) {
                    recommendedScales.push(scaleId);
                }
            }

            // If we have recommended scales, highlight them or auto-select first one
            if (recommendedScales.length > 0) {
                // Could implement highlighting or auto-selection here
                console.log('Recommended scales for', pathologyId, ':', recommendedScales);
            }
        }

        // Initialize on load
        // ============================================================
        // APPLICATION INITIALIZATION
        // ============================================================
        window.addEventListener('load', () => {
            try {
                console.log('üé¨ Starting application initialization...');

                // Run startup validation
                const validationPassed = validateStartup();
                if (!validationPassed) {
                    console.error('‚ùå Startup validation failed!');
                    return;
                }

                console.log('‚úÖ Startup validation passed');

                // Initialize components
                console.log('üîë Loading API key...');
                loadAPIKey();

                console.log('üé§ Initializing speech recognition...');
                initSpeechRecognition();

                console.log('üìä Updating word count...');
                updateWordCount();

                console.log('üíæ Loading saved scale data...');
                loadScaleResponsesFromStorage();

                console.log('üìö Loading uploaded documents...');
                loadUploadedDocumentsFromStorage();

                console.log('‚öïÔ∏è  Initializing clinical scales...');
                initializeScales();

                console.log('üîÑ Restoring panel states...');
                restorePanelStates();

                // Update word count as user types
                const transcriptEl = document.getElementById('transcript');
                if (transcriptEl) {
                    transcriptEl.addEventListener('input', updateWordCount);
                    console.log('‚úÖ Transcript input listener attached');
                } else {
                    console.error('‚ùå Transcript element not found');
                }

                // Add SOAP textarea event listeners for real-time stats
                const soapSubjective = document.getElementById('soapSubjective');
                const soapObjective = document.getElementById('soapObjective');
                const soapAssessment = document.getElementById('soapAssessment');
                const soapPlan = document.getElementById('soapPlan');

                if (soapSubjective && soapObjective && soapAssessment && soapPlan) {
                    soapSubjective.addEventListener('input', updateSOAPStats);
                    soapObjective.addEventListener('input', updateSOAPStats);
                    soapAssessment.addEventListener('input', updateSOAPStats);
                    soapPlan.addEventListener('input', updateSOAPStats);
                    console.log('‚úÖ SOAP Quick-Entry input listeners attached');
                } else {
                    console.error('‚ùå One or more SOAP textarea elements not found');
                }

                // Attach event listener to attending summary textarea for live stats
                const attendingSummaryText = document.getElementById('attendingSummaryText');
                if (attendingSummaryText) {
                    attendingSummaryText.addEventListener('input', function() {
                        updateSummaryStats(this.value);
                    });
                    console.log('‚úÖ Attending summary stats listener attached');
                } else {
                    console.error('‚ùå Attending summary textarea not found');
                }

                // Initialize enhancement toggles state
                updateEnhancementToggles();
                console.log('‚úÖ Enhancement toggles initialized');

                console.log('üéâ Application initialization complete!');
                console.log('‚ïê'.repeat(60));

            } catch (error) {
                console.error('üö® CRITICAL ERROR during initialization:', error);
                console.error('Stack trace:', error.stack);
                alert(`Critical error during startup: ${error.message}\n\nPlease refresh the page. If the problem persists, check the browser console (F12).`);
            }
        });
    </script>
</body>
</html>
