<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroScribe Unified - Professional Clinical Documentation with Industrial-Grade Validation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #E8F4F8 0%, #F5F8FA 100%);
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        h1 {
            color: #4A90E2;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.2rem;
        }

        .version {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .grid {
            display: grid;
            grid-template-columns: 350px 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1400px) {
            .grid {
                grid-template-columns: 1fr 1fr;
            }
            .briefing-panel {
                grid-column: 1 / -1;
            }
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: #FAFBFC;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #E1E4E8;
        }

        .panel h2 {
            color: #333;
            margin-bottom: 12px;
            font-size: 1.3rem;
        }

        textarea {
            width: 100%;
            min-height: 300px;
            padding: 12px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.95rem;
            resize: vertical;
            margin-bottom: 10px;
        }

        textarea:focus {
            outline: none;
            border-color: #4A90E2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        button {
            padding: 8px 16px;
            background: #4A90E2;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            margin: 3px;
            transition: all 0.2s;
        }

        button:hover {
            background: #5BA3F5;
            box-shadow: 0 2px 8px rgba(74, 144, 226, 0.25);
        }

        button:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
        }

        button.success {
            background: #10b981;
        }

        button.success:hover {
            background: #059669;
        }

        button.danger {
            background: #ef4444;
        }

        button.danger:hover {
            background: #dc2626;
        }

        button.warning {
            background: #f59e0b;
        }

        button.warning:hover {
            background: #d97706;
        }

        .status {
            text-align: center;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .status.connected {
            background: #d1fae5;
            color: #065f46;
        }

        .status.disconnected {
            background: #fee2e2;
            color: #991b1b;
        }

        .status.recording {
            background: #fef3c7;
            color: #92400e;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .buttons button {
            flex: 1;
            min-width: 100px;
        }

        .info {
            background: #EBF5FB;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 0.85rem;
            border-left: 3px solid #4A90E2;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: white;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #E1E4E8;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 600;
            color: #4A90E2;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 4px;
        }

        .recording-controls {
            margin-bottom: 15px;
        }

        /* Pathology Button Styles */
        .pathology-btn {
            padding: 6px 10px;
            background: white;
            color: #6b7280;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0;
        }

        .pathology-btn:hover {
            background: #f9fafb;
            border-color: #4A90E2;
            box-shadow: 0 1px 4px rgba(74, 144, 226, 0.15);
        }

        .pathology-btn.active {
            background: #4A90E2;
            color: white;
            border-color: #4A90E2;
        }

        /* Tab Navigation Styles */
        .tab-buttons {
            display: flex;
            gap: 3px;
            margin-bottom: 12px;
            border-bottom: 1px solid #E1E4E8;
        }

        .tab-button {
            flex: 1;
            padding: 8px 16px;
            background: transparent;
            color: #6b7280;
            border: none;
            border-bottom: 2px solid transparent;
            border-radius: 0;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            margin: 0;
        }

        .tab-button:hover {
            background: #f9fafb;
            color: #4A90E2;
            transform: none;
            box-shadow: none;
        }

        .tab-button.active {
            color: #4A90E2;
            border-bottom-color: #4A90E2;
            background: transparent;
            font-weight: 500;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .formatted-output {
            background: white;
            padding: 15px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            min-height: 300px;
            max-height: 700px;
            overflow-y: auto;
            font-family: 'Georgia', serif;
            line-height: 1.6;
        }

        .formatted-output h1 {
            color: #333;
            font-size: 1.4rem;
            margin-bottom: 12px;
            border-bottom: 2px solid #4A90E2;
            padding-bottom: 8px;
        }

        .formatted-output h2 {
            color: #4A90E2;
            font-size: 1.15rem;
            margin-top: 16px;
            margin-bottom: 8px;
        }

        .formatted-output h3 {
            color: #374151;
            font-size: 0.95rem;
            margin-top: 12px;
            margin-bottom: 6px;
        }

        .formatted-output ul {
            margin-left: 20px;
        }

        .formatted-output p {
            margin: 10px 0;
        }

        .export-options {
            display: grid;
            gap: 15px;
        }

        .export-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .export-row label {
            min-width: 120px;
            font-weight: 600;
        }

        .export-row select {
            flex: 1;
            padding: 8px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        /* Collapsible Panel Styles */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .panel-header h2 {
            margin: 0;
        }

        .collapse-icon {
            font-size: 1.2rem;
            color: #4A90E2;
            transition: transform 0.3s;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .panel-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
            pointer-events: auto;
        }

        .panel-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            pointer-events: none;
        }

        /* SOAP Quick-Entry Panel Styles */
        .soap-panel {
            grid-column: 1 / -1;  /* Span full width on all screen sizes */
        }

        .soap-section {
            margin-bottom: 15px;
        }

        .soap-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .soap-textarea:focus {
            outline: none;
            border-color: #4A90E2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .soap-textarea::placeholder {
            color: #9ca3af;
            font-style: italic;
        }

        /* Enhancement Toggle Disabled State */
        input[type="checkbox"]:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        label:has(input[type="checkbox"]:disabled) {
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h1 style="margin: 0;">üß† NeuroScribe V7 - Professional Clinical Intelligence</h1>
            <div style="display: flex; align-items: center; gap: 15px;">
                <div id="apiKeyStatus" style="font-size: 0.85rem; color: #6b7280;"></div>
                <button onclick="openSettings()" style="padding: 8px 16px; background: #4A90E2; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                    ‚öôÔ∏è Settings
                </button>
            </div>
        </div>
        <div class="version">Enhanced Diagnostic Reasoning + Evidence-Based Medicine + Industrial-Grade 6-Layer Validation | Unified Edition</div>

        <div id="status" class="status disconnected">
            üîë Checking API key...
        </div>

        <!-- Settings Modal -->
        <div id="settingsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 10000; justify-content: center; align-items: center;">
            <div style="background: white; border-radius: 12px; padding: 30px; max-width: 600px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.2);">
                <h2 style="color: #4A90E2; margin-bottom: 15px; font-size: 1.4rem;">‚öôÔ∏è API Key Settings</h2>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 500; margin-bottom: 8px; color: #333; font-size: 0.9rem;">
                        Google Gemini API Key:
                    </label>
                    <input
                        type="password"
                        id="apiKeyInput"
                        placeholder="AIzaSy... (paste your API key here)"
                        style="width: 100%; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: monospace;"
                    />
                    <div style="margin-top: 6px; font-size: 0.8rem; color: #6b7280;">
                        Your API key is encrypted and stored locally in your browser. It never leaves your device.
                    </div>
                </div>

                <div style="background: #EBF5FB; padding: 12px; border-radius: 6px; margin-bottom: 15px; border-left: 3px solid #4A90E2;">
                    <strong style="font-size: 0.9rem;">üìå Don't have an API key?</strong><br>
                    <div style="margin-top: 6px; font-size: 0.85rem; line-height: 1.6;">
                        1. Visit <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: #4A90E2; text-decoration: underline;">Google AI Studio</a><br>
                        2. Sign in with your Google account<br>
                        3. Click "Create API Key"<br>
                        4. Copy the key and paste it above<br>
                        5. It's FREE with generous limits!
                    </div>
                </div>

                <div id="apiKeyStatusModal" style="margin-bottom: 15px; padding: 10px; border-radius: 6px; display: none; font-size: 0.9rem;"></div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                    <button onclick="saveAPIKey()" style="padding: 10px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        üíæ Save & Test
                    </button>
                    <button onclick="testAPIKey()" style="padding: 10px; background: #4A90E2; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        üß™ Test Key
                    </button>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <button onclick="clearAPIKey()" style="padding: 10px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        üóëÔ∏è Clear Key
                    </button>
                    <button onclick="closeSettings()" style="padding: 10px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        Cancel
                    </button>
                </div>

                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 0.85rem; color: #666;">
                    <strong>üîí Privacy & Security:</strong><br>
                    ‚Ä¢ API key stored locally in your browser only<br>
                    ‚Ä¢ Encrypted using Base64 + character reversal<br>
                    ‚Ä¢ No server storage - your key never leaves your device<br>
                    ‚Ä¢ Clear browser data to remove the key
                </div>
            </div>
        </div>

        <div class="grid">
            <!-- Briefing Panel: Pre-Consultation Research -->
            <div class="panel briefing-panel">
                <div class="panel-header" onclick="togglePanel('briefing')">
                    <h2>üî¨ Pre-Consultation Briefing</h2>
                    <span class="collapse-icon" id="briefing-icon">‚ñº</span>
                </div>

                <div class="panel-content" id="briefing-content">
                <div class="info" style="margin-bottom: 12px;">
                    <strong>Expert Analysis:</strong> Enter specific pathology or select common category for deep research
                </div>

                <!-- Custom Pathology Input -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">Specific Pathology / Diagnosis:</label>
                    <input
                        type="text"
                        id="customPathology"
                        placeholder="e.g., C5-6 foraminal stenosis with radiculopathy, diffuse low-grade glioma..."
                        style="width: 100%; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; margin-bottom: 8px;"
                        oninput="onCustomPathologyInput()"
                    />
                    <div style="font-size: 0.8rem; color: #666; font-style: italic;">
                        Enter specific pathology for deep search, or select common category below
                    </div>
                </div>

                <!-- Pathology Quick-Select -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">Or select common pathology:</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="selectPathology('spine-degenerative')" class="pathology-btn" data-pathology="spine-degenerative">
                            ü¶¥ Spine Deg
                        </button>
                        <button onclick="selectPathology('spine-trauma')" class="pathology-btn" data-pathology="spine-trauma">
                            ‚ö†Ô∏è Trauma
                        </button>
                        <button onclick="selectPathology('brain-tumor')" class="pathology-btn" data-pathology="brain-tumor">
                            üß† Tumor
                        </button>
                        <button onclick="selectPathology('vascular')" class="pathology-btn" data-pathology="vascular">
                            üíâ Vascular
                        </button>
                        <button onclick="selectPathology('hydrocephalus')" class="pathology-btn" data-pathology="hydrocephalus">
                            üíß Hydro
                        </button>
                        <button onclick="selectPathology('functional')" class="pathology-btn" data-pathology="functional">
                            ‚öôÔ∏è Functional
                        </button>
                        <button onclick="selectPathology('pediatric')" class="pathology-btn" data-pathology="pediatric">
                            üë∂ Pediatric
                        </button>
                        <button onclick="selectPathology('peripheral')" class="pathology-btn" data-pathology="peripheral">
                            üîå Peripheral
                        </button>
                    </div>
                </div>

                <!-- Research Depth -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">Research Depth:</label>
                    <select id="briefingDepth" style="width: 100%; padding: 8px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem;">
                        <option value="quick">Quick Overview (30 sec)</option>
                        <option value="standard" selected>Standard Briefing (1 min)</option>
                        <option value="comprehensive">Comprehensive (2 min)</option>
                    </select>
                </div>

                <!-- Expert Document Upload -->
                <div style="margin-bottom: 12px; border: 2px dashed #E1E4E8; border-radius: 6px; padding: 12px; background: #FAFBFC;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">
                        üìö Upload Expert Documents (Optional):
                    </label>
                    <div style="font-size: 0.8rem; color: #666; margin-bottom: 10px;">
                        Upload research papers, guidelines, or notes to enrich the briefing
                    </div>
                    <input
                        type="file"
                        id="expertDocUpload"
                        accept=".txt,.pdf,.doc,.docx"
                        multiple
                        style="width: 100%; padding: 8px; font-size: 0.85rem;"
                        onchange="handleDocumentUpload(event)"
                    />
                    <div id="uploadedDocs" style="margin-top: 10px; font-size: 0.8rem; color: #333;">
                    </div>
                    <!-- Document Storage Management UI -->
                    <div id="documentStorageUI"></div>
                </div>

                <!-- Generate Button -->
                <button onclick="generateDeepBriefing()" id="briefingBtn" class="success" style="width: 100%; margin-bottom: 15px;" disabled>
                    üéØ Generate Deep Research + Checklist
                </button>

                <!-- Briefing Output -->
                <div id="briefingOutput" style="background: white; border: 1px solid #E1E4E8; border-radius: 6px; padding: 12px; min-height: 200px; max-height: 500px; overflow-y: auto; font-size: 0.85rem; line-height: 1.5;">
                    <p style="color: #9ca3af; text-align: center; padding: 30px 10px;">
                        Select a pathology type to generate pre-consultation briefing
                    </p>
                </div>
                </div>
            </div>

            <!-- Transcript Panel: Input -->
            <div class="panel">
                <div class="panel-header" onclick="togglePanel('transcript')">
                    <h2>üìù Clinical Transcript</h2>
                    <span class="collapse-icon" id="transcript-icon">‚ñº</span>
                </div>

                <div class="panel-content" id="transcript-content">

                <!-- Consultation Type Selector -->
                <div style="margin-bottom: 12px; background: #EBF5FB; padding: 12px; border-radius: 6px; border-left: 3px solid #4A90E2;">
                    <label style="display: block; font-weight: 500; margin-bottom: 8px; color: #333; font-size: 0.9rem;">
                        üìã Consultation Type:
                    </label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="selectConsultType('new')" id="consultTypeNew" class="consult-type-btn" style="padding: 10px; border: 2px solid #4A90E2; border-radius: 6px; background: #4A90E2; color: white; cursor: pointer; font-weight: 500; transition: all 0.2s; font-size: 0.9rem;">
                            üÜï New Consultation
                        </button>
                        <button onclick="selectConsultType('followup')" id="consultTypeFollowup" class="consult-type-btn" style="padding: 10px; border: 2px solid #E1E4E8; border-radius: 6px; background: white; color: #333; cursor: pointer; font-weight: 500; transition: all 0.2s; font-size: 0.9rem;">
                            üîÑ Follow-up Visit
                        </button>
                    </div>
                    <div id="consultTypeDescription" style="margin-top: 8px; font-size: 0.8rem; color: #6b7280;">
                        <strong>New Consultation:</strong> Comprehensive initial assessment with full history, examination, and workup.
                    </div>
                </div>

                <!-- Transcript Enhancement Mode Toggle -->
                <div style="margin-bottom: 15px; background: #E3F2FD; padding: 12px; border-radius: 6px; border-left: 3px solid #2196F3;">
                    <label style="display: flex; align-items: flex-start; cursor: pointer; font-size: 0.9rem;" id="transcriptEnhanceLabel">
                        <input type="checkbox" id="transcriptEnhanceToggle" onchange="toggleTranscriptEnhancement()"
                               style="margin-right: 10px; margin-top: 2px; width: 18px; height: 18px; cursor: pointer; flex-shrink: 0;"
                               disabled>
                        <div>
                            <strong>ü§ñ Enhanced Mode:</strong> Add briefing-based clinical analysis & recommendations<br>
                            <span style="font-size: 0.75rem; color: #666; font-style: italic;">
                                Unchecked = Expand only | Checked = Briefing Integration + Analysis
                            </span>
                        </div>
                    </label>

                    <div id="transcriptEnhanceWarning" style="display: block; margin-top: 8px; padding: 8px; background: #FFF3CD; border-radius: 4px; font-size: 0.75rem;">
                        üí° <strong>Note:</strong> Generate a briefing first to enable Enhanced Mode
                    </div>
                </div>

                <div class="info">
                    <strong>üé§ New:</strong> Use voice recording or type/paste your transcript
                </div>

                <!-- Recording Controls -->
                <div class="recording-controls">
                    <div class="buttons">
                        <button onclick="startRecording()" id="startBtn">
                            üé§ Start Recording
                        </button>
                        <button onclick="stopRecording()" id="stopBtn" disabled>
                            ‚èπÔ∏è Stop
                        </button>
                        <button onclick="pauseRecording()" id="pauseBtn" class="warning" disabled>
                            ‚è∏Ô∏è Pause
                        </button>
                        <button onclick="clearText()">
                            üóëÔ∏è Clear
                        </button>
                    </div>
                </div>

                <textarea
                    id="transcript"
                    placeholder="Click 'Start Recording' to use voice transcription, or type/paste your clinical encounter transcript here..."
                ></textarea>

                <!-- Stats -->
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="wordCount">0</div>
                        <div class="stat-label">Words</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="duration">00:00</div>
                        <div class="stat-label">Duration</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="confidence">--</div>
                        <div class="stat-label">Confidence</div>
                    </div>
                </div>
                </div>
            </div>

            <!-- SOAP Quick-Entry Panel: Structured Input -->
            <div class="panel soap-panel">
                <div class="panel-header" onclick="togglePanel('soap')">
                    <h2>üìã SOAP Quick-Entry</h2>
                    <span class="collapse-icon" id="soap-icon">‚ñº</span>
                </div>

                <div class="panel-content" id="soap-content">
                <div class="info" style="background: #FFF3CD; border-left: 3px solid #FFA500;">
                    <strong>üìã Quick Entry Mode:</strong> Enter brief headnotes or bullet points - AI will expand into professional clinical documentation
                </div>

                <!-- Enhancement Mode Toggle -->
                <div style="margin-bottom: 15px; background: #E8F5E9; padding: 12px; border-radius: 6px; border-left: 3px solid #4CAF50;">
                    <label style="display: flex; align-items: flex-start; cursor: pointer; font-size: 0.9rem;">
                        <input type="checkbox" id="soapEnhanceToggle" onchange="toggleSOAPEnhancement()" style="margin-right: 10px; margin-top: 2px; width: 18px; height: 18px; cursor: pointer; flex-shrink: 0;">
                        <div>
                            <strong>ü§ñ Enhanced Mode:</strong> Add clinical analysis & evidence-based recommendations<br>
                            <span style="font-size: 0.75rem; color: #666; font-style: italic;">
                                Unchecked = Expand only (safer) | Checked = Expand + Clinical Analysis
                            </span>
                        </div>
                    </label>

                    <div id="enhanceWarning" style="display: none; margin-top: 8px; padding: 8px; background: #FFF3CD; border-radius: 4px; font-size: 0.75rem;">
                        üí° <strong>Tip:</strong> Select a pathology and generate briefing for best enhanced analysis
                    </div>
                </div>

                <!-- Input Mode Toggle: Simple (Unified) vs Advanced (4-Box) -->
                <div style="margin-bottom: 15px; background: #E3F2FD; padding: 12px; border-radius: 6px; border-left: 3px solid #2196F3;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                        <strong style="font-size: 0.9rem;">üìù Input Mode:</strong>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <button id="simpleModeBtn" onclick="switchSOAPMode('simple')"
                                    style="padding: 6px 12px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: 600;">
                                Simple (1 Box)
                            </button>
                            <button id="advancedModeBtn" onclick="switchSOAPMode('advanced')"
                                    style="padding: 6px 12px; background: #E0E0E0; color: #666; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: 600;">
                                Advanced (4 Boxes)
                            </button>
                        </div>
                    </div>
                    <div style="font-size: 0.75rem; color: #555;">
                        <span id="modeDescription">
                            <strong>Simple:</strong> Enter all SOAP sections in one textbox (AI will intelligently parse sections)
                        </span>
                    </div>
                </div>

                <!-- SIMPLE MODE: Unified SOAP Input -->
                <div id="soapUnifiedContainer" style="display: block; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #2196F3;">‚úèÔ∏è</span> Clinical Documentation:
                        </label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <span id="parseMethod" style="font-size: 0.7rem; color: #999; padding: 2px 6px; background: #F5F5F5; border-radius: 3px;">Not parsed</span>
                            <span style="font-size: 0.75rem; color: #999;">Format: S: / O: / A: / P: or free text</span>
                        </div>
                    </div>
                    <textarea
                        id="soapUnifiedInput"
                        class="soap-textarea"
                        placeholder="Enter clinical notes in any format:&#10;&#10;LABELED FORMAT (Recommended):&#10;S: 45F neck pain x 3wks, worse w/ extension, denies numbness, failed NSAIDs&#10;O: Spurling+ left, motor 5/5, decreased C6 sensation left&#10;A: C5-6 foraminal stenosis with left C6 radiculopathy&#10;P: MRI cervical spine, continue NSAIDs, PT, F/U 4wks&#10;&#10;FREE TEXT FORMAT (AI will parse):&#10;Patient reports 3 weeks of neck pain that worsens with extension. No numbness. NSAIDs haven't helped. Exam shows positive Spurling test on left, motor strength 5/5, decreased C6 sensation. Impression is C5-6 foraminal stenosis with left C6 radiculopathy. Plan for MRI, NSAIDs, PT, follow-up in 4 weeks."
                        oninput="updateUnifiedStats()"
                        style="width: 100%; min-height: 200px; padding: 12px; border: 2px solid #2196F3; border-radius: 6px; font-size: 0.9rem; font-family: 'Courier New', monospace; resize: vertical; line-height: 1.6;"
                    ></textarea>

                    <!-- Parse Preview Button -->
                    <div style="margin-top: 10px; display: flex; gap: 10px; align-items: center;">
                        <button onclick="previewSOAPParsing()"
                                style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 600;">
                            üîç Preview Parsing
                        </button>
                        <span id="parseConfidence" style="font-size: 0.8rem; color: #666;"></span>
                    </div>
                </div>

                <!-- ADVANCED MODE: 4 Separate Textareas (Original) -->
                <div id="soapSeparateContainer" style="display: none;">
                <!-- SOAP Section: Subjective -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Subjective (Patient History):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">bullets or brief phrases</span>
                    </div>
                    <textarea
                        id="soapSubjective"
                        class="soap-textarea"
                        placeholder="Enter brief notes, e.g.:&#10;‚Ä¢ Neck pain x 3 weeks&#10;‚Ä¢ Worse with extension&#10;‚Ä¢ Denies numbness&#10;‚Ä¢ Failed NSAIDs"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: vertical;"
                    ></textarea>
                </div>

                <!-- SOAP Section: Objective -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Objective (Examination):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">findings only</span>
                    </div>
                    <textarea
                        id="soapObjective"
                        class="soap-textarea"
                        placeholder="Enter exam findings, e.g.:&#10;‚Ä¢ Spurling test positive left&#10;‚Ä¢ Motor 5/5 throughout&#10;‚Ä¢ Decreased C6 sensation left"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: vertical;"
                    ></textarea>
                </div>

                <!-- SOAP Section: Assessment -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Assessment (Diagnosis):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">your impression</span>
                    </div>
                    <textarea
                        id="soapAssessment"
                        class="soap-textarea"
                        placeholder="Enter diagnosis/impression, e.g.:&#10;‚Ä¢ C5-6 foraminal stenosis with left C6 radiculopathy"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 60px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: vertical;"
                    ></textarea>
                </div>

                <!-- SOAP Section: Plan -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Plan (Management):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">treatment & follow-up</span>
                    </div>
                    <textarea
                        id="soapPlan"
                        class="soap-textarea"
                        placeholder="Enter management plan, e.g.:&#10;‚Ä¢ MRI cervical spine&#10;‚Ä¢ Continue NSAIDs&#10;‚Ä¢ PT for cervical strengthening&#10;‚Ä¢ F/U 4 weeks with MRI"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: vertical;"
                    ></textarea>
                </div>
                </div>
                <!-- End of Advanced Mode Container -->

                <!-- Stats -->
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="soapTotalWords">0</div>
                        <div class="stat-label">Total Words</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="soapSectionCount">0/4</div>
                        <div class="stat-label">Sections</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="soapMode">Expand</div>
                        <div class="stat-label">Mode</div>
                    </div>
                </div>
                </div>
            </div>

            <!-- Right Panel: Output with Tabs -->
            <div class="panel">
                <h2>ü§ñ AI-Generated Documentation</h2>

                <button onclick="generate()" class="success" id="generateBtn" style="width: 100%; margin-bottom: 15px;">
                    ‚ö° Generate Clinical Note
                </button>

                <!-- Tab Navigation -->
                <div class="tab-buttons">
                    <button class="tab-button active" onclick="switchTab('formatted')">
                        üìÑ Formatted Note
                    </button>
                    <button class="tab-button" onclick="switchTab('raw')">
                        üìù Raw Output
                    </button>
                    <button class="tab-button" onclick="switchTab('scales')">
                        üìä Clinical Scales
                    </button>
                    <button class="tab-button" onclick="switchTab('export')">
                        üíæ Export Options
                    </button>
                    <button class="tab-button" onclick="switchTab('review')" id="review-tab-button" style="display: none;">
                        üîç Review Suggestions
                    </button>
                    <button class="tab-button" onclick="switchTab('attending')" id="attending-tab-button" style="display: none;">
                        üìä Attending Summary
                    </button>
                    <button class="tab-button" onclick="switchTab('validation')" id="validation-tab-button" style="display: none;">
                        üîç Quality Report
                    </button>
                </div>

                <!-- Tab 1: Formatted Note -->
                <div class="tab-content active" id="tab-formatted">
                    <div class="formatted-output" id="formattedOutput">
                        <p style="color: #999; text-align: center; padding: 50px;">
                            Generate documentation to see formatted output here
                        </p>
                    </div>
                    <div class="buttons" style="margin-top: 15px;">
                        <button onclick="copyFormatted()">üìã Copy</button>
                        <button onclick="printFormatted()">üñ®Ô∏è Print</button>
                    </div>
                </div>

                <!-- Tab 2: Raw Output -->
                <div class="tab-content" id="tab-raw">
                    <textarea
                        id="output"
                        placeholder="Raw markdown output will appear here..."
                        readonly
                    ></textarea>
                    <div class="buttons" style="margin-top: 15px;">
                        <button onclick="copyOutput()">üìã Copy</button>
                        <button onclick="downloadOutput()">üíæ Download TXT</button>
                    </div>
                </div>

                <!-- Tab 3: Clinical Scales -->
                <div class="tab-content" id="tab-scales">
                    <div class="scales-container">
                        <div class="scale-selector" style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 10px; font-weight: 600; color: #333;">
                                Select Clinical Scale:
                            </label>
                            <select id="scaleSelect" onchange="loadScaleForm()" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem; margin-bottom: 15px;">
                                <option value="">-- Select a Scale --</option>
                            </select>
                        </div>

                        <div id="scaleFormContainer" style="display: none;">
                            <div id="scaleDescription" style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #0066CC;">
                            </div>

                            <div id="scaleQuestions" style="margin-bottom: 20px;">
                            </div>

                            <button onclick="calculateScale()" class="success" style="width: 100%; margin-bottom: 15px;">
                                üßÆ Calculate Score
                            </button>

                            <div id="scaleResults" style="display: none; background: #f9f9f9; padding: 20px; border-radius: 8px; border: 2px solid #ddd;">
                            </div>
                        </div>

                        <div id="scalesPlaceholder" style="text-align: center; padding: 50px; color: #999;">
                            <p>Select a clinical scale to begin assessment</p>
                            <p style="font-size: 0.9rem; margin-top: 10px;">Scales will be automatically suggested based on selected pathology</p>
                        </div>
                    </div>
                </div>

                <!-- Tab 4: Export Options -->
                <div class="tab-content" id="tab-export">
                    <div class="export-options">
                        <div class="export-row">
                            <label>Format:</label>
                            <select id="exportFormat">
                                <option value="txt">Plain Text (.txt)</option>
                                <option value="docx">Word Document (.docx)</option>
                                <option value="pdf">PDF Document (.pdf)</option>
                                <option value="json">JSON Data (.json)</option>
                                <option value="html">HTML Page (.html)</option>
                            </select>
                        </div>
                        <div class="export-row">
                            <label>Include:</label>
                            <select id="exportIncludes">
                                <option value="full">Full Documentation</option>
                                <option value="summary">Summary Only</option>
                                <option value="plan">Assessment & Plan Only</option>
                            </select>
                        </div>
                        <button onclick="doExport()" class="success" style="width: 100%;">
                            üì• Export Document
                        </button>
                    </div>
                </div>

                <!-- Tab: Review AI Suggestions (V6) -->
                <div class="tab-content" id="tab-review" style="display: none;">
                    <div style="background: #FFF3CD; padding: 14px; border-radius: 6px; margin-bottom: 20px; border-left: 4px solid #FFC107;">
                        <strong>üìã Review AI Suggestions:</strong> Check items to keep in your final note, or uncheck to discard.
                        Linked suggestions have dependencies on other items.
                    </div>

                    <div id="reviewInterface" style="margin-bottom: 20px;">
                        <p style="color: #666; text-align: center; padding: 40px; font-style: italic;">
                            Generate a note with Enhanced Mode to see AI suggestions here.
                        </p>
                    </div>

                    <div style="margin-top: 20px; display: flex; gap: 12px; padding: 15px; background: #f6f8fa; border-radius: 6px;">
                        <button onclick="selectAllSuggestions()" class="success" style="flex: 1; padding: 12px;">
                            ‚úÖ Keep All
                        </button>
                        <button onclick="deselectAllSuggestions()" class="warning" style="flex: 1; padding: 12px;">
                            ‚ùå Discard All
                        </button>
                        <button onclick="generateFinalNote()" class="success" style="flex: 2; padding: 12px; font-weight: 600;">
                            üìÑ Generate Final Note
                        </button>
                    </div>
                </div>

                <!-- Tab: Validation Quality Report (V8) -->
                <div class="tab-content" id="tab-validation" style="display: none;">
                    <!-- Validation Header -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 8px; margin-bottom: 20px; color: white;">
                        <h2 style="margin: 0 0 10px 0; font-size: 1.5rem; color: white;">üîç Quality Validation Report</h2>
                        <p style="margin: 0; opacity: 0.9; font-size: 0.9rem;">6-Layer Industrial-Grade Validation Analysis</p>
                    </div>

                    <!-- Overall Quality Score -->
                    <div id="validationOverallScore" style="background: #f9f9f9; padding: 25px; border-radius: 8px; margin-bottom: 20px; text-align: center; border: 2px solid #ddd;">
                        <div style="font-size: 0.9rem; color: #666; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Overall Quality Score</div>
                        <div id="qualityScoreDisplay" style="font-size: 3.5rem; font-weight: bold; margin: 15px 0; color: #999;">--</div>
                        <div id="qualityBadgeDisplay" style="display: inline-block; padding: 8px 20px; border-radius: 20px; font-weight: 600; font-size: 0.9rem; background: #e0e0e0; color: #666;">
                            ‚è≥ Awaiting Validation
                        </div>
                    </div>

                    <!-- 6-Layer Breakdown -->
                    <div id="validationLayersBreakdown" style="margin-bottom: 20px;">
                        <h3 style="font-size: 1.2rem; margin-bottom: 15px; color: #333;">üìä Validation Layers Breakdown</h3>

                        <!-- Layer 1: Grounding -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">üéØ Layer 1: Source Grounding</div>
                                <div id="grounding-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">--</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">Ensures generated content is grounded in source material</div>
                            <div id="grounding-progress" style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: #999; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="grounding-details" style="margin-top: 10px; font-size: 0.85rem; color: #666; display: none;"></div>
                        </div>

                        <!-- Layer 2: Fabrication Detection -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">ü§ñ Layer 2: Fabrication Detection</div>
                                <div id="fabrication-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">--</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">AI-powered hallucination detection (semantic + term-based)</div>
                            <div id="fabrication-progress" style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: #999; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="fabrication-details" style="margin-top: 10px; font-size: 0.85rem; color: #666; display: none;"></div>
                        </div>

                        <!-- Layer 3: Completeness -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">‚úÖ Layer 3: Completeness Check</div>
                                <div id="completeness-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">--</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">Bidirectional validation (notes‚Üíextraction & extraction‚Üínotes)</div>
                            <div id="completeness-progress" style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: #999; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="completeness-details" style="margin-top: 10px; font-size: 0.85rem; color: #666; display: none;"></div>
                        </div>

                        <!-- Layer 4: Consistency -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">üî¨ Layer 4: Consistency Validation</div>
                                <div id="consistency-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">--</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">Medical logic checks (functional scores, anatomical rules, cross-field validation)</div>
                            <div id="consistency-progress" style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: #999; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="consistency-details" style="margin-top: 10px; font-size: 0.85rem; color: #666; display: none;"></div>
                        </div>

                        <!-- Layer 5: Proportionality -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">üìè Layer 5: Proportionality Check</div>
                                <div id="proportionality-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">--</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">Output sizing appropriateness (not too short/long for input)</div>
                            <div id="proportionality-progress" style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: #999; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="proportionality-details" style="margin-top: 10px; font-size: 0.85rem; color: #666; display: none;"></div>
                        </div>

                        <!-- Layer 6: Confidence Calibration -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">üéöÔ∏è Layer 6: Confidence Calibration</div>
                                <div id="confidence-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">N/A</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">Multi-source confidence adjustment based on validation findings</div>
                            <div style="margin-top: 10px; font-size: 0.85rem; color: #666;">
                                Applied to extracted data (not applicable to generated notes)
                            </div>
                        </div>
                    </div>

                    <!-- Errors & Warnings -->
                    <div id="validationIssues" style="display: none; margin-bottom: 20px;">
                        <h3 style="font-size: 1.2rem; margin-bottom: 15px; color: #333;">‚ö†Ô∏è Issues & Warnings</h3>
                        <div id="validationIssuesList" style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px;">
                            <!-- Issues will be dynamically inserted here -->
                        </div>
                    </div>

                    <!-- Placeholder (shown when no validation results) -->
                    <div id="validationPlaceholder" style="text-align: center; padding: 60px 20px; color: #999;">
                        <div style="font-size: 4rem; margin-bottom: 20px; opacity: 0.3;">üîç</div>
                        <p style="font-size: 1.1rem; margin-bottom: 10px;">No validation data available</p>
                        <p style="font-size: 0.9rem;">Generate a clinical note to see quality validation results here</p>
                    </div>
                </div>

                <!-- Tab: Attending Summary (Ultra Summarizer) -->
                <div class="tab-content" id="tab-attending">
                    <!-- Compression Mode Selector -->
                    <div style="background: #f5f5f5; padding: 16px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #ddd;">
                        <strong style="color: #333; font-size: 1.1rem;">‚ö° Compression Mode:</strong>
                        <div style="display: flex; gap: 15px; margin-top: 12px; flex-wrap: wrap;">
                            <label style="flex: 1; min-width: 200px; cursor: pointer; background: white; padding: 12px; border-radius: 6px; border: 2px solid #4CAF50; transition: all 0.2s;">
                                <input type="radio" name="compressionMode" value="standard" checked onchange="updateCompressionInfo()">
                                <strong style="color: #4CAF50;">üìä Standard DOAP</strong>
                                <span id="status-standard" style="margin-left: 8px; font-size: 0.75rem; padding: 2px 6px; border-radius: 3px; background: #e0e0e0; color: #666;">‚è≥ Pending</span>
                                <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">45 seconds (~120-140 words)</div>
                            </label>
                            <label style="flex: 1; min-width: 200px; cursor: pointer; background: white; padding: 12px; border-radius: 6px; border: 2px solid #FF5722; transition: all 0.2s;">
                                <input type="radio" name="compressionMode" value="ultra" onchange="updateCompressionInfo()">
                                <strong style="color: #FF5722;">‚ö° ULTRATHINK</strong>
                                <span id="status-ultra" style="margin-left: 8px; font-size: 0.75rem; padding: 2px 6px; border-radius: 3px; background: #e0e0e0; color: #666;">‚è≥ Pending</span>
                                <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">15 seconds (~35-50 words)</div>
                            </label>
                            <label style="flex: 1; min-width: 200px; cursor: pointer; background: white; padding: 12px; border-radius: 6px; border: 2px solid #9C27B0; transition: all 0.2s;">
                                <input type="radio" name="compressionMode" value="telegram" onchange="updateCompressionInfo()">
                                <strong style="color: #9C27B0;">üì± Telegram</strong>
                                <span id="status-telegram" style="margin-left: 8px; font-size: 0.75rem; padding: 2px 6px; border-radius: 3px; background: #e0e0e0; color: #666;">‚è≥ Pending</span>
                                <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">5 seconds (~15-25 words)</div>
                            </label>
                        </div>
                    </div>

                    <!-- Framework Info Display (changes based on mode) -->
                    <div id="compressionInfoBox" style="background: #e3f2fd; padding: 14px; border-radius: 6px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                        <strong>üìä DOAP Framework for Attending Presentation:</strong>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                            <li><strong>D</strong> - Diagnosis (5 sec): Age, Sex, PMHx, Primary diagnosis</li>
                            <li><strong>O</strong> - One-liner (10 sec): Exam findings + Imaging results</li>
                            <li><strong>A</strong> - Assessment (10 sec): Severity + Candidacy</li>
                            <li><strong>P</strong> - Plan (20 sec): Intervention + Timing + Main concern</li>
                        </ul>
                        <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 45-second presentation to impress attending staff</p>
                    </div>

                    <textarea id="attendingSummaryText"
                              style="width: 100%; min-height: 300px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 1rem; padding: 15px; border: 2px solid #2196F3; border-radius: 6px; line-height: 1.8; resize: vertical;"
                              placeholder="Attending summary will appear here after note generation..."></textarea>

                    <!-- Stats Display -->
                    <div style="display: flex; justify-content: space-around; margin-top: 12px; padding: 12px; background: #f9f9f9; border-radius: 6px;">
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #2196F3;" id="summaryWordCount">0</div>
                            <div style="font-size: 12px; color: #666;">Words</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #4CAF50;" id="summarySeconds">0</div>
                            <div style="font-size: 12px; color: #666;">Seconds</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #FF9800;" id="compressionRatio">0%</div>
                            <div style="font-size: 12px; color: #666;">Compression</div>
                        </div>
                    </div>

                    <div style="margin-top: 15px; display: flex; gap: 12px;">
                        <button onclick="testAttendingSummary()" style="flex: 1; padding: 12px; background: #FF9800; color: white;">
                            üß™ Test (Use Current Note)
                        </button>
                        <button onclick="copyAttendingSummary()" class="success" style="flex: 1; padding: 12px;">
                            üìã Copy Summary
                        </button>
                        <button onclick="regenerateAttendingSummary()" style="flex: 1; padding: 12px; background: #2196F3; color: white;">
                            üîÑ Regenerate
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Clinical Scales Database -->
    <script>
        // ============================================================
        // EMBEDDED CLINICAL SCALES DATABASE
        // ============================================================
        /**
         * Clinical Scales Database for NeuroScribe
         * Comprehensive collection of neurosurgical assessment scales
         */

const ClinicalScalesDatabase = {

    // ============================================================
    // SPINE SCALES (PRIORITY IMPLEMENTATION)
    // ============================================================

    'mjoa': {
        id: 'mjoa',
        name: 'Modified Japanese Orthopedic Association (mJOA) Score',
        shortName: 'mJOA',
        category: 'spine',
        pathologies: ['spine-degenerative'],
        description: 'Assessment scale for cervical myelopathy severity. Evaluates motor and sensory function in upper/lower extremities and bladder function.',
        questions: [
            {
                id: 'motor_upper',
                section: 'Motor Function',
                text: 'Motor dysfunction of the upper extremity',
                options: [
                    {value: 0, label: 'Unable to feed oneself', description: 'Severe impairment - cannot use utensils'},
                    {value: 1, label: 'Unable to handle chopsticks but able to eat with spoon', description: 'Significant impairment'},
                    {value: 2, label: 'Handles chopsticks with difficulty', description: 'Moderate impairment'},
                    {value: 3, label: 'Handles chopsticks with slight difficulty', description: 'Mild impairment'},
                    {value: 4, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['hand function', 'fine motor', 'buttons', 'writing', 'feeding', 'utensils', 'chopsticks', 'dropping objects']
            },
            {
                id: 'motor_lower',
                section: 'Motor Function',
                text: 'Motor dysfunction of the lower extremity',
                options: [
                    {value: 0, label: 'Unable to walk', description: 'Complete loss of ambulation'},
                    {value: 1, label: 'Needs cane or aid on flat ground', description: 'Significant assistance required'},
                    {value: 2, label: 'Needs cane or aid on stairs', description: 'Limited assistance'},
                    {value: 3, label: 'Lacks smooth reciprocation or speed', description: 'Mild gait abnormality'},
                    {value: 4, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['walking', 'gait', 'stairs', 'climbing', 'balance', 'cane', 'walker', 'ambulation', 'legs']
            },
            {
                id: 'sensory_upper',
                section: 'Sensory Function',
                text: 'Sensory dysfunction of the upper extremity',
                options: [
                    {value: 0, label: 'Severe sensory loss or pain', description: 'Marked impairment'},
                    {value: 1, label: 'Mild sensory loss or pain', description: 'Slight impairment'},
                    {value: 2, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['numbness', 'tingling', 'sensation', 'arms', 'hands', 'fingers', 'upper extremity', 'paresthesia']
            },
            {
                id: 'sensory_lower',
                section: 'Sensory Function',
                text: 'Sensory dysfunction of the lower extremity',
                options: [
                    {value: 0, label: 'Severe sensory loss or pain', description: 'Marked impairment'},
                    {value: 1, label: 'Mild sensory loss or pain', description: 'Slight impairment'},
                    {value: 2, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['numbness', 'tingling', 'sensation', 'legs', 'feet', 'toes', 'lower extremity', 'paresthesia']
            },
            {
                id: 'sensory_trunk',
                section: 'Sensory Function',
                text: 'Sensory dysfunction of the trunk',
                options: [
                    {value: 0, label: 'Severe sensory loss or pain', description: 'Marked impairment'},
                    {value: 1, label: 'Mild sensory loss or pain', description: 'Slight impairment'},
                    {value: 2, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['trunk', 'chest', 'abdomen', 'torso', 'body', 'sensory level']
            },
            {
                id: 'bladder',
                section: 'Bladder Function',
                text: 'Sphincter dysfunction (Bladder function)',
                options: [
                    {value: 0, label: 'Urinary retention and/or incontinence', description: 'Complete dysfunction'},
                    {value: 1, label: 'Sense of retention and/or incomplete continence', description: 'Moderate dysfunction'},
                    {value: 2, label: 'Urinary frequency and/or hesitation', description: 'Mild dysfunction'},
                    {value: 3, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['bladder', 'urinary', 'incontinence', 'retention', 'frequency', 'urgency', 'hesitation', 'catheter']
            }
        ],
        scoring: function(responses) {
            let total = 0;
            let answered = 0;
            for (const q of this.questions) {
                if (q.value !== null && q.value !== undefined) {
                    total += q.value;
                    answered++;
                }
            }
            return {
                total: total,
                max: this.maxScore,
                answered: answered,
                totalQuestions: this.questions.length,
                percentage: answered > 0 ? Math.round((answered / this.questions.length) * 100) : 0
            };
        },
        interpretation: function(score) {
            if (score >= 15) {
                return {
                    severity: 'Mild Myelopathy',
                    color: '#10b981',
                    description: 'Minimal functional impairment',
                    recommendation: 'Consider conservative management, close monitoring'
                };
            } else if (score >= 12) {
                return {
                    severity: 'Moderate Myelopathy',
                    color: '#f59e0b',
                    description: 'Moderate functional limitations',
                    recommendation: 'Consider surgical intervention if progressive or conservative treatment fails'
                };
            } else {
                return {
                    severity: 'Severe Myelopathy',
                    color: '#dc2626',
                    description: 'Significant functional impairment',
                    recommendation: 'Surgical intervention strongly recommended'
                };
            }
        },
        minScore: 0,
        maxScore: 17,
        ranges: [
            {min: 0, max: 11, severity: 'Severe', color: '#dc2626'},
            {min: 12, max: 14, severity: 'Moderate', color: '#f59e0b'},
            {min: 15, max: 17, severity: 'Mild', color: '#10b981'}
        ],
        evidenceLevel: 'Level II - Validated outcome measure',
        references: [
            'Benzel EC, et al. Cervical laminectomy and dentate ligament section for cervical spondylotic myelopathy. J Spinal Disord. 1991;4:286-295.',
            'Yonenobu K, et al. Interobserver and intraobserver reliability of the Japanese Orthopaedic Association scoring system. Spine. 2001;26:1890-1894.'
        ]
    },

    'nurick': {
        id: 'nurick',
        name: 'Nurick Classification/Grade',
        shortName: 'Nurick',
        category: 'spine',
        pathologies: ['spine-degenerative'],
        description: 'Classification system for cervical myelopathy based on walking ability and gait disturbance.',
        questions: [
            {
                id: 'grade',
                section: 'Functional Status',
                text: 'Cervical myelopathy grade based on walking ability',
                options: [
                    {value: 0, label: 'Grade 0: No signs or symptoms of cord involvement', description: 'Root signs only'},
                    {value: 1, label: 'Grade 1: Signs of cord involvement but no difficulty walking', description: 'Myelopathy present, ambulation normal'},
                    {value: 2, label: 'Grade 2: Slight difficulty walking, able to work', description: 'Mild gait impairment, employment maintained'},
                    {value: 3, label: 'Grade 3: Difficulty walking prevents work or full-time employment', description: 'Moderate impairment'},
                    {value: 4, label: 'Grade 4: Able to walk only with assistance', description: 'Severe impairment, requires aid'},
                    {value: 5, label: 'Grade 5: Wheelchair bound or bedridden', description: 'Non-ambulatory'}
                ],
                value: null,
                keywords: ['walking', 'gait', 'wheelchair', 'assistance', 'cane', 'walker', 'bedridden', 'employment', 'work']
            }
        ],
        scoring: function(responses) {
            const grade = this.questions[0].value;
            return {
                total: grade !== null ? grade : null,
                max: 5,
                answered: grade !== null ? 1 : 0,
                totalQuestions: 1,
                percentage: grade !== null ? 100 : 0
            };
        },
        interpretation: function(grade) {
            const interpretations = {
                0: {severity: 'Grade 0 - No Myelopathy', color: '#10b981', description: 'Radiculopathy only', recommendation: 'Conservative management typically appropriate'},
                1: {severity: 'Grade 1 - Very Mild', color: '#10b981', description: 'Signs present, no functional limitation', recommendation: 'Monitor, consider intervention if progressive'},
                2: {severity: 'Grade 2 - Mild', color: '#84cc16', description: 'Slight gait difficulty, maintains employment', recommendation: 'Consider surgical intervention, discuss risks/benefits'},
                3: {severity: 'Grade 3 - Moderate', color: '#f59e0b', description: 'Cannot work due to gait impairment', recommendation: 'Surgical intervention recommended'},
                4: {severity: 'Grade 4 - Severe', color: '#ef4444', description: 'Requires assistive device', recommendation: 'Surgical intervention strongly recommended'},
                5: {severity: 'Grade 5 - Very Severe', color: '#dc2626', description: 'Non-ambulatory', recommendation: 'Surgery indicated, but outcomes may be limited'}
            };
            return interpretations[grade] || {severity: 'Unknown', color: '#6b7280', description: 'Grade not assessed', recommendation: 'Complete assessment'};
        },
        minScore: 0,
        maxScore: 5,
        ranges: [
            {min: 0, max: 1, severity: 'No/Minimal', color: '#10b981'},
            {min: 2, max: 3, severity: 'Mild-Moderate', color: '#f59e0b'},
            {min: 4, max: 5, severity: 'Severe', color: '#dc2626'}
        ],
        evidenceLevel: 'Level II - Widely accepted classification',
        references: [
            'Nurick S. The pathogenesis of the spinal cord disorder associated with cervical spondylosis. Brain. 1972;95:87-100.'
        ]
    },

    'ndi': {
        id: 'ndi',
        name: 'Neck Disability Index (NDI)',
        shortName: 'NDI',
        category: 'spine',
        pathologies: ['spine-degenerative', 'spine-trauma'],
        description: 'Patient-reported outcome measure for neck pain and disability. 10 sections, each scored 0-5.',
        questions: [
            {
                id: 'pain_intensity',
                section: 'Section 1',
                text: 'Pain Intensity',
                options: [
                    {value: 0, label: 'I have no pain at the moment'},
                    {value: 1, label: 'The pain is very mild at the moment'},
                    {value: 2, label: 'The pain is moderate at the moment'},
                    {value: 3, label: 'The pain is fairly severe at the moment'},
                    {value: 4, label: 'The pain is very severe at the moment'},
                    {value: 5, label: 'The pain is the worst imaginable at the moment'}
                ],
                value: null,
                keywords: ['neck pain', 'pain intensity', 'pain level', 'how much pain']
            },
            {
                id: 'personal_care',
                section: 'Section 2',
                text: 'Personal Care (washing, dressing, etc.)',
                options: [
                    {value: 0, label: 'I can look after myself normally without causing extra pain'},
                    {value: 1, label: 'I can look after myself normally but it causes extra pain'},
                    {value: 2, label: 'It is painful to look after myself and I am slow and careful'},
                    {value: 3, label: 'I need some help but manage most of my personal care'},
                    {value: 4, label: 'I need help every day in most aspects of self care'},
                    {value: 5, label: 'I do not get dressed, wash with difficulty, and stay in bed'}
                ],
                value: null,
                keywords: ['dressing', 'washing', 'bathing', 'grooming', 'personal care', 'self care']
            },
            {
                id: 'lifting',
                section: 'Section 3',
                text: 'Lifting',
                options: [
                    {value: 0, label: 'I can lift heavy weights without extra pain'},
                    {value: 1, label: 'I can lift heavy weights but it gives extra pain'},
                    {value: 2, label: 'Pain prevents me from lifting heavy weights off the floor, but I can if items are conveniently positioned'},
                    {value: 3, label: 'Pain prevents me from lifting heavy weights, but I can manage light to medium weights'},
                    {value: 4, label: 'I can lift only very light weights'},
                    {value: 5, label: 'I cannot lift or carry anything at all'}
                ],
                value: null,
                keywords: ['lifting', 'carrying', 'heavy objects', 'weights']
            },
            {
                id: 'reading',
                section: 'Section 4',
                text: 'Reading',
                options: [
                    {value: 0, label: 'I can read as much as I want with no pain in my neck'},
                    {value: 1, label: 'I can read as much as I want with slight pain in my neck'},
                    {value: 2, label: 'I can read as much as I want with moderate pain in my neck'},
                    {value: 3, label: 'I cannot read as much as I want because of moderate pain in my neck'},
                    {value: 4, label: 'I can hardly read at all because of severe pain in my neck'},
                    {value: 5, label: 'I cannot read at all'}
                ],
                value: null,
                keywords: ['reading', 'looking down', 'neck flexion', 'computer work', 'phone use']
            },
            {
                id: 'headaches',
                section: 'Section 5',
                text: 'Headaches',
                options: [
                    {value: 0, label: 'I have no headaches at all'},
                    {value: 1, label: 'I have slight headaches which come infrequently'},
                    {value: 2, label: 'I have moderate headaches which come infrequently'},
                    {value: 3, label: 'I have moderate headaches which come frequently'},
                    {value: 4, label: 'I have severe headaches which come frequently'},
                    {value: 5, label: 'I have headaches almost all the time'}
                ],
                value: null,
                keywords: ['headache', 'head pain', 'cervicogenic headache', 'occipital pain']
            },
            {
                id: 'concentration',
                section: 'Section 6',
                text: 'Concentration',
                options: [
                    {value: 0, label: 'I can concentrate fully when I want with no difficulty'},
                    {value: 1, label: 'I can concentrate fully when I want with slight difficulty'},
                    {value: 2, label: 'I have a fair degree of difficulty concentrating when I want'},
                    {value: 3, label: 'I have a lot of difficulty concentrating when I want'},
                    {value: 4, label: 'I have a great deal of difficulty concentrating when I want'},
                    {value: 5, label: 'I cannot concentrate at all'}
                ],
                value: null,
                keywords: ['concentration', 'focus', 'attention', 'mental clarity', 'cognitive']
            },
            {
                id: 'work',
                section: 'Section 7',
                text: 'Work',
                options: [
                    {value: 0, label: 'I can do as much work as I want'},
                    {value: 1, label: 'I can only do my usual work but no more'},
                    {value: 2, label: 'I can do most of my usual work but no more'},
                    {value: 3, label: 'I cannot do my usual work'},
                    {value: 4, label: 'I can hardly do any work at all'},
                    {value: 5, label: 'I cannot do any work at all'}
                ],
                value: null,
                keywords: ['work', 'job', 'employment', 'occupation', 'working']
            },
            {
                id: 'driving',
                section: 'Section 8',
                text: 'Driving',
                options: [
                    {value: 0, label: 'I can drive my car without any neck pain'},
                    {value: 1, label: 'I can drive my car as long as I want with slight pain in my neck'},
                    {value: 2, label: 'I can drive my car as long as I want with moderate pain in my neck'},
                    {value: 3, label: 'I cannot drive my car as long as I want because of moderate pain in my neck'},
                    {value: 4, label: 'I can hardly drive at all because of severe pain in my neck'},
                    {value: 5, label: 'I cannot drive my car at all'}
                ],
                value: null,
                keywords: ['driving', 'car', 'vehicle', 'turning head', 'looking over shoulder']
            },
            {
                id: 'sleeping',
                section: 'Section 9',
                text: 'Sleeping',
                options: [
                    {value: 0, label: 'I have no trouble sleeping'},
                    {value: 1, label: 'My sleep is slightly disturbed (less than 1 hour sleepless)'},
                    {value: 2, label: 'My sleep is mildly disturbed (1-2 hours sleepless)'},
                    {value: 3, label: 'My sleep is moderately disturbed (2-3 hours sleepless)'},
                    {value: 4, label: 'My sleep is greatly disturbed (3-5 hours sleepless)'},
                    {value: 5, label: 'My sleep is completely disturbed (5-7 hours sleepless)'}
                ],
                value: null,
                keywords: ['sleep', 'sleeping', 'night pain', 'insomnia', 'rest']
            },
            {
                id: 'recreation',
                section: 'Section 10',
                text: 'Recreation',
                options: [
                    {value: 0, label: 'I am able to engage in all recreational activities with no neck pain'},
                    {value: 1, label: 'I am able to engage in all recreational activities with some pain in my neck'},
                    {value: 2, label: 'I am able to engage in most but not all recreational activities because of pain in my neck'},
                    {value: 3, label: 'I am able to engage in a few recreational activities because of pain in my neck'},
                    {value: 4, label: 'I can hardly do any recreational activities because of pain in my neck'},
                    {value: 5, label: 'I cannot do any recreational activities at all'}
                ],
                value: null,
                keywords: ['recreation', 'hobbies', 'activities', 'sports', 'exercise', 'leisure']
            }
        ],
        scoring: function(responses) {
            let total = 0;
            let answered = 0;
            for (const q of this.questions) {
                if (q.value !== null && q.value !== undefined) {
                    total += q.value;
                    answered++;
                }
            }
            // NDI is reported as percentage: (total score / max possible score) √ó 100
            const percentage = answered > 0 ? Math.round((total / (answered * 5)) * 100) : 0;
            return {
                total: total,
                max: this.maxScore,
                percentage: percentage,
                answered: answered,
                totalQuestions: this.questions.length,
                completionPercentage: Math.round((answered / this.questions.length) * 100)
            };
        },
        interpretation: function(percentage) {
            if (percentage <= 8) {
                return {
                    severity: 'No Disability',
                    color: '#10b981',
                    description: 'No significant neck-related functional impairment',
                    recommendation: 'Continue current management, reassess if symptoms change'
                };
            } else if (percentage <= 28) {
                return {
                    severity: 'Mild Disability',
                    color: '#84cc16',
                    description: 'Mild neck-related functional limitations',
                    recommendation: 'Conservative management: PT, medications, activity modification'
                };
            } else if (percentage <= 48) {
                return {
                    severity: 'Moderate Disability',
                    color: '#f59e0b',
                    description: 'Moderate functional limitations affecting daily activities',
                    recommendation: 'Consider advanced imaging, interventional options if conservative treatment fails'
                };
            } else if (percentage <= 68) {
                return {
                    severity: 'Severe Disability',
                    color: '#ef4444',
                    description: 'Severe functional impairment',
                    recommendation: 'Comprehensive evaluation, consider surgical consultation'
                };
            } else {
                return {
                    severity: 'Complete Disability',
                    color: '#dc2626',
                    description: 'Complete or near-complete disability',
                    recommendation: 'Urgent evaluation, multidisciplinary approach'
                };
            }
        },
        minScore: 0,
        maxScore: 50,
        ranges: [
            {min: 0, max: 8, severity: 'No Disability', color: '#10b981'},
            {min: 9, max: 28, severity: 'Mild', color: '#84cc16'},
            {min: 29, max: 48, severity: 'Moderate', color: '#f59e0b'},
            {min: 49, max: 68, severity: 'Severe', color: '#ef4444'},
            {min: 69, max: 100, severity: 'Complete', color: '#dc2626'}
        ],
        evidenceLevel: 'Level I - Validated, widely used outcome measure',
        references: [
            'Vernon H, Mior S. The Neck Disability Index: a study of reliability and validity. J Manipulative Physiol Ther. 1991;14:409-415.',
            'MacDermid JC, et al. Measurement properties of the neck disability index. J Orthop Sports Phys Ther. 2009;39:400-417.'
        ]
    },

    'odi': {
        id: 'odi',
        name: 'Oswestry Disability Index (ODI)',
        shortName: 'ODI',
        category: 'spine',
        pathologies: ['spine-degenerative', 'spine-trauma'],
        description: 'Patient-reported outcome measure for lower back pain and disability. 10 sections, each scored 0-5.',
        questions: [
            {
                id: 'pain_intensity',
                section: 'Section 1',
                text: 'Pain Intensity',
                options: [
                    {value: 0, label: 'I have no pain at the moment'},
                    {value: 1, label: 'The pain is very mild at the moment'},
                    {value: 2, label: 'The pain is moderate at the moment'},
                    {value: 3, label: 'The pain is fairly severe at the moment'},
                    {value: 4, label: 'The pain is very severe at the moment'},
                    {value: 5, label: 'The pain is the worst imaginable at the moment'}
                ],
                value: null,
                keywords: ['back pain', 'low back pain', 'pain intensity', 'pain level']
            },
            {
                id: 'personal_care',
                section: 'Section 2',
                text: 'Personal Care (washing, dressing, etc.)',
                options: [
                    {value: 0, label: 'I can look after myself normally without causing extra pain'},
                    {value: 1, label: 'I can look after myself normally but it causes extra pain'},
                    {value: 2, label: 'It is painful to look after myself and I am slow and careful'},
                    {value: 3, label: 'I need some help but manage most of my personal care'},
                    {value: 4, label: 'I need help every day in most aspects of self care'},
                    {value: 5, label: 'I do not get dressed, I wash with difficulty and stay in bed'}
                ],
                value: null,
                keywords: ['dressing', 'washing', 'bathing', 'grooming', 'personal care']
            },
            {
                id: 'lifting',
                section: 'Section 3',
                text: 'Lifting',
                options: [
                    {value: 0, label: 'I can lift heavy weights without extra pain'},
                    {value: 1, label: 'I can lift heavy weights but it gives extra pain'},
                    {value: 2, label: 'Pain prevents me lifting heavy weights off the floor, but I can if they are conveniently positioned'},
                    {value: 3, label: 'Pain prevents me from lifting heavy weights but I can manage light to medium weights'},
                    {value: 4, label: 'I can only lift very light weights'},
                    {value: 5, label: 'I cannot lift or carry anything'}
                ],
                value: null,
                keywords: ['lifting', 'carrying', 'heavy objects', 'weights']
            },
            {
                id: 'walking',
                section: 'Section 4',
                text: 'Walking',
                options: [
                    {value: 0, label: 'Pain does not prevent me walking any distance'},
                    {value: 1, label: 'Pain prevents me from walking more than 1 mile'},
                    {value: 2, label: 'Pain prevents me from walking more than 1/2 mile'},
                    {value: 3, label: 'Pain prevents me from walking more than 100 yards'},
                    {value: 4, label: 'I can only walk using a stick or crutches'},
                    {value: 5, label: 'I am in bed most of the time'}
                ],
                value: null,
                keywords: ['walking', 'ambulation', 'distance', 'mobility', 'gait']
            },
            {
                id: 'sitting',
                section: 'Section 5',
                text: 'Sitting',
                options: [
                    {value: 0, label: 'I can sit in any chair as long as I like'},
                    {value: 1, label: 'I can only sit in my favorite chair as long as I like'},
                    {value: 2, label: 'Pain prevents me sitting more than one hour'},
                    {value: 3, label: 'Pain prevents me from sitting more than 30 minutes'},
                    {value: 4, label: 'Pain prevents me from sitting more than 10 minutes'},
                    {value: 5, label: 'Pain prevents me from sitting at all'}
                ],
                value: null,
                keywords: ['sitting', 'prolonged sitting', 'desk work', 'chair']
            },
            {
                id: 'standing',
                section: 'Section 6',
                text: 'Standing',
                options: [
                    {value: 0, label: 'I can stand as long as I want without extra pain'},
                    {value: 1, label: 'I can stand as long as I want but it gives me extra pain'},
                    {value: 2, label: 'Pain prevents me from standing for more than 1 hour'},
                    {value: 3, label: 'Pain prevents me from standing for more than 30 minutes'},
                    {value: 4, label: 'Pain prevents me from standing for more than 10 minutes'},
                    {value: 5, label: 'Pain prevents me from standing at all'}
                ],
                value: null,
                keywords: ['standing', 'prolonged standing', 'upright posture']
            },
            {
                id: 'sleeping',
                section: 'Section 7',
                text: 'Sleeping',
                options: [
                    {value: 0, label: 'My sleep is never disturbed by pain'},
                    {value: 1, label: 'My sleep is occasionally disturbed by pain'},
                    {value: 2, label: 'Because of pain I have less than 6 hours sleep'},
                    {value: 3, label: 'Because of pain I have less than 4 hours sleep'},
                    {value: 4, label: 'Because of pain I have less than 2 hours sleep'},
                    {value: 5, label: 'Pain prevents me from sleeping at all'}
                ],
                value: null,
                keywords: ['sleep', 'sleeping', 'night pain', 'insomnia', 'rest']
            },
            {
                id: 'sex_life',
                section: 'Section 8',
                text: 'Sex Life (if applicable)',
                options: [
                    {value: 0, label: 'My sex life is normal and causes no extra pain'},
                    {value: 1, label: 'My sex life is normal but causes some extra pain'},
                    {value: 2, label: 'My sex life is nearly normal but is very painful'},
                    {value: 3, label: 'My sex life is severely restricted by pain'},
                    {value: 4, label: 'My sex life is nearly absent because of pain'},
                    {value: 5, label: 'Pain prevents any sex life at all'}
                ],
                value: null,
                keywords: ['sexual function', 'intimacy', 'sex life']
            },
            {
                id: 'social_life',
                section: 'Section 9',
                text: 'Social Life',
                options: [
                    {value: 0, label: 'My social life is normal and gives me no extra pain'},
                    {value: 1, label: 'My social life is normal but increases the degree of pain'},
                    {value: 2, label: 'Pain has no significant effect on my social life apart from limiting my more energetic interests'},
                    {value: 3, label: 'Pain has restricted my social life and I do not go out as often'},
                    {value: 4, label: 'Pain has restricted my social life to my home'},
                    {value: 5, label: 'I have no social life because of pain'}
                ],
                value: null,
                keywords: ['social life', 'socializing', 'going out', 'activities', 'friends']
            },
            {
                id: 'traveling',
                section: 'Section 10',
                text: 'Travelling',
                options: [
                    {value: 0, label: 'I can travel anywhere without pain'},
                    {value: 1, label: 'I can travel anywhere but it gives me extra pain'},
                    {value: 2, label: 'Pain is bad but I manage journeys over two hours'},
                    {value: 3, label: 'Pain restricts me to journeys of less than one hour'},
                    {value: 4, label: 'Pain restricts me to short necessary journeys under 30 minutes'},
                    {value: 5, label: 'Pain prevents me from travelling except to receive treatment'}
                ],
                value: null,
                keywords: ['traveling', 'driving', 'car rides', 'trips', 'journeys']
            }
        ],
        scoring: function(responses) {
            let total = 0;
            let answered = 0;
            for (const q of this.questions) {
                if (q.value !== null && q.value !== undefined) {
                    total += q.value;
                    answered++;
                }
            }
            // ODI is reported as percentage: (total score / max possible score) √ó 100
            const percentage = answered > 0 ? Math.round((total / (answered * 5)) * 100) : 0;
            return {
                total: total,
                max: this.maxScore,
                percentage: percentage,
                answered: answered,
                totalQuestions: this.questions.length,
                completionPercentage: Math.round((answered / this.questions.length) * 100)
            };
        },
        interpretation: function(percentage) {
            if (percentage <= 20) {
                return {
                    severity: 'Minimal Disability',
                    color: '#10b981',
                    description: 'Can cope with most activities of daily living',
                    recommendation: 'Continue activity, no treatment indicated'
                };
            } else if (percentage <= 40) {
                return {
                    severity: 'Moderate Disability',
                    color: '#84cc16',
                    description: 'Experiencing more pain, difficulty with sitting, lifting, standing',
                    recommendation: 'Conservative treatment: PT, pain management'
                };
            } else if (percentage <= 60) {
                return {
                    severity: 'Severe Disability',
                    color: '#f59e0b',
                    description: 'Pain remains main problem, interfering with all aspects of life',
                    recommendation: 'Detailed investigation, may require advanced treatment'
                };
            } else if (percentage <= 80) {
                return {
                    severity: 'Crippled',
                    color: '#ef4444',
                    description: 'Back pain impinging on all aspects of life',
                    recommendation: 'Active intervention required, consider surgical consultation'
                };
            } else {
                return {
                    severity: 'Bed-bound or Exaggerating',
                    color: '#dc2626',
                    description: 'Confined to bed or exaggerating symptoms',
                    recommendation: 'Careful reassessment, multidisciplinary evaluation'
                };
            }
        },
        minScore: 0,
        maxScore: 50,
        ranges: [
            {min: 0, max: 20, severity: 'Minimal', color: '#10b981'},
            {min: 21, max: 40, severity: 'Moderate', color: '#84cc16'},
            {min: 41, max: 60, severity: 'Severe', color: '#f59e0b'},
            {min: 61, max: 80, severity: 'Crippled', color: '#ef4444'},
            {min: 81, max: 100, severity: 'Bed-bound', color: '#dc2626'}
        ],
        evidenceLevel: 'Level I - Gold standard for low back disability',
        references: [
            'Fairbank JC, Pynsent PB. The Oswestry Disability Index. Spine. 2000;25:2940-2952.',
            'Ostelo RW, et al. Interpreting change scores for pain and functional status in low back pain. Spine. 2008;33:90-94.'
        ]
    },

    'vas_pain': {
        id: 'vas_pain',
        name: 'Visual Analog Scale (VAS) for Pain',
        shortName: 'VAS Pain',
        category: 'pain',
        pathologies: ['spine-degenerative', 'spine-trauma', 'brain-tumor', 'vascular', 'functional'],
        description: 'Simple pain intensity rating scale from 0-10. 0 = no pain, 10 = worst pain imaginable.',
        questions: [
            {
                id: 'current_pain',
                section: 'Pain Assessment',
                text: 'Current Pain Level (0-10)',
                type: 'slider',
                options: [], // Slider from 0-10
                value: null,
                keywords: ['pain', 'pain level', 'how much pain', 'pain intensity', 'hurts']
            },
            {
                id: 'worst_pain',
                section: 'Pain Assessment',
                text: 'Worst Pain in Last 24 Hours (0-10)',
                type: 'slider',
                options: [],
                value: null,
                keywords: ['worst pain', 'maximum pain', 'peak pain']
            },
            {
                id: 'average_pain',
                section: 'Pain Assessment',
                text: 'Average Pain Level (0-10)',
                type: 'slider',
                options: [],
                value: null,
                keywords: ['average pain', 'typical pain', 'usual pain']
            }
        ],
        scoring: function(responses) {
            const current = this.questions[0].value;
            const worst = this.questions[1].value;
            const average = this.questions[2].value;
            let answered = 0;
            let total = 0;

            if (current !== null) { answered++; total += current; }
            if (worst !== null) { answered++; total += worst; }
            if (average !== null) { answered++; total += average; }

            const avgScore = answered > 0 ? Math.round(total / answered) : null;

            return {
                current: current,
                worst: worst,
                average: average,
                overallAverage: avgScore,
                answered: answered,
                totalQuestions: this.questions.length,
                percentage: Math.round((answered / this.questions.length) * 100)
            };
        },
        interpretation: function(score) {
            if (score === null || score === undefined) {
                return {severity: 'Not Assessed', color: '#6b7280', description: 'Pain not evaluated', recommendation: 'Complete pain assessment'};
            }
            if (score <= 2) {
                return {severity: 'Mild Pain', color: '#10b981', description: 'Minimal pain, no/minimal functional impact', recommendation: 'No intervention or simple analgesics prn'};
            } else if (score <= 5) {
                return {severity: 'Moderate Pain', color: '#f59e0b', description: 'Noticeable pain affecting some activities', recommendation: 'Regular analgesics, consider PT or other modalities'};
            } else if (score <= 7) {
                return {severity: 'Severe Pain', color: '#ef4444', description: 'Significant pain interfering with daily function', recommendation: 'Multimodal pain management, consider advanced therapies'};
            } else {
                return {severity: 'Very Severe Pain', color: '#dc2626', description: 'Worst possible pain, unable to function', recommendation: 'Urgent pain management, evaluate for acute intervention'};
            }
        },
        minScore: 0,
        maxScore: 10,
        ranges: [
            {min: 0, max: 2, severity: 'Mild', color: '#10b981'},
            {min: 3, max: 5, severity: 'Moderate', color: '#f59e0b'},
            {min: 6, max: 7, severity: 'Severe', color: '#ef4444'},
            {min: 8, max: 10, severity: 'Very Severe', color: '#dc2626'}
        ],
        evidenceLevel: 'Level I - Universally accepted pain measure',
        references: [
            'Hawker GA, et al. Measures of adult pain. Arthritis Care Res. 2011;63(S11):S240-252.'
        ]
    },

    // ============================================================
    // FUNCTIONAL SCALES
    // ============================================================

    'gcs': {
        id: 'gcs',
        name: 'Glasgow Coma Scale (GCS)',
        shortName: 'GCS',
        category: 'functional',
        pathologies: ['spine-trauma', 'brain-tumor', 'vascular', 'hydrocephalus'],
        description: 'Neurological scale to assess consciousness level. Evaluates eye, verbal, and motor responses.',
        questions: [
            {
                id: 'eye',
                section: 'Eye Opening Response',
                text: 'Eye Opening',
                options: [
                    {value: 4, label: 'Spontaneous - Opens eyes spontaneously'},
                    {value: 3, label: 'To verbal command - Opens eyes to verbal stimulation'},
                    {value: 2, label: 'To pain - Opens eyes to painful stimulus'},
                    {value: 1, label: 'No response - Does not open eyes'}
                ],
                value: null,
                keywords: ['eye opening', 'opens eyes', 'spontaneous', 'to voice', 'to pain']
            },
            {
                id: 'verbal',
                section: 'Verbal Response',
                text: 'Verbal Response',
                options: [
                    {value: 5, label: 'Oriented - Oriented to person, place, time'},
                    {value: 4, label: 'Confused - Disoriented conversation'},
                    {value: 3, label: 'Inappropriate words - Intelligible but inappropriate'},
                    {value: 2, label: 'Incomprehensible sounds - Moaning/groaning only'},
                    {value: 1, label: 'No response - No verbal response'}
                ],
                value: null,
                keywords: ['speaking', 'talking', 'oriented', 'confused', 'verbal', 'speech', 'alert']
            },
            {
                id: 'motor',
                section: 'Motor Response',
                text: 'Best Motor Response',
                options: [
                    {value: 6, label: 'Obeys commands - Follows simple commands'},
                    {value: 5, label: 'Localizes pain - Purposeful movement to painful stimulus'},
                    {value: 4, label: 'Withdraws from pain - Pulls limb away from pain'},
                    {value: 3, label: 'Flexion to pain - Abnormal flexion (decorticate)'},
                    {value: 2, label: 'Extension to pain - Abnormal extension (decerebrate)'},
                    {value: 1, label: 'No response - No motor response'}
                ],
                value: null,
                keywords: ['motor', 'movement', 'follows commands', 'localizes', 'withdraws', 'flexion', 'extension', 'posturing']
            }
        ],
        scoring: function(responses) {
            let total = 0;
            let answered = 0;
            for (const q of this.questions) {
                if (q.value !== null && q.value !== undefined) {
                    total += q.value;
                    answered++;
                }
            }
            return {
                total: total,
                eye: this.questions[0].value,
                verbal: this.questions[1].value,
                motor: this.questions[2].value,
                answered: answered,
                totalQuestions: this.questions.length,
                percentage: Math.round((answered / this.questions.length) * 100)
            };
        },
        interpretation: function(score) {
            if (score >= 14) {
                return {severity: 'Mild TBI', color: '#10b981', description: 'Minimal neurological impairment', recommendation: 'Observation, may not require admission'};
            } else if (score >= 9) {
                return {severity: 'Moderate TBI', color: '#f59e0b', description: 'Moderate neurological impairment', recommendation: 'Admission, close monitoring, CT scan'};
            } else if (score >= 3) {
                return {severity: 'Severe TBI', color: '#dc2626', description: 'Severe neurological impairment', recommendation: 'ICU admission, intubation consideration, neurosurgical consultation'};
            } else {
                return {severity: 'Unknown', color: '#6b7280', description: 'Not assessed', recommendation: 'Complete GCS assessment'};
            }
        },
        minScore: 3,
        maxScore: 15,
        ranges: [
            {min: 3, max: 8, severity: 'Severe', color: '#dc2626'},
            {min: 9, max: 13, severity: 'Moderate', color: '#f59e0b'},
            {min: 14, max: 15, severity: 'Mild', color: '#10b981'}
        ],
        evidenceLevel: 'Level I - Gold standard for consciousness assessment',
        references: [
            'Teasdale G, Jennett B. Assessment of coma and impaired consciousness. Lancet. 1974;2:81-84.'
        ]
    }

    // Additional scales to be implemented in future iterations:
    // - KPS (Karnofsky Performance Scale)
    // - mRS (Modified Rankin Scale)
    // - NIHSS (NIH Stroke Scale)
    // - ASIA (Spinal Cord Injury)
    // - Hunt-Hess (SAH grading)
    // - Fisher Scale (SAH)
    // - WFNS (SAH)
    // - Spetzler-Martin (AVM)
    // - TLICS/SLIC (Spine trauma)
    // - Frankel Grade
    // - UPDRS (Parkinson's)
    // - etc.
};

// Export for use in main application
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ClinicalScalesDatabase;
}

        // ============================================================
        // GLOBAL ERROR HANDLER
        // ============================================================
        window.addEventListener('error', function(e) {
            console.error('üö® JavaScript Error:', e.message, 'at', e.filename, ':', e.lineno);
            console.error('Stack:', e.error?.stack);
        });

        window.addEventListener('unhandledrejection', function(e) {
            console.error('üö® Unhandled Promise Rejection:', e.reason);
        });

        console.log('üöÄ NeuroScribe Unified - V7 + Industrial-Grade Validation');
        console.log('üìÖ Loading at:', new Date().toLocaleString());

        // ============================================================
        // GLOBAL VARIABLES
        // ============================================================

        // Get API key from localStorage
        let API_KEY = null;
        let recognition = null;
        let isRecording = false;
        let isPaused = false;
        let startTime = null;
        let timerInterval = null;
        let confidenceScores = [];
        let selectedPathology = null;
        let activeRedFlags = [];

        // V5 Expert Analysis Variables
        let customPathology = '';
        let generatedBriefing = null;  // Stores full briefing text
        let briefingChecklist = null;  // Stores structured checklist
        let briefingUsed = false;      // Tracks if briefing was integrated

        // Clinical Scales Variables
        let currentScale = null;       // Currently selected scale object
        let scaleResponses = {};       // Stores all scale responses {scaleId: {questionId: value}}
        let calculatedScores = {};     // Stores calculated scores {scaleId: scoreObject}

        // Expert Document Upload Variables
        let uploadedDocuments = [];    // Stores uploaded document content
        let uploadedDocText = '';      // Combined text from all uploaded documents

        // Consultation Type Variable
        let consultationType = 'new';  // 'new' or 'followup'

        // SOAP Quick-Entry Variables
        let soapQuickEntry = {
            subjective: '',
            objective: '',
            assessment: '',
            plan: ''
        };
        let soapEnhanceMode = false;  // false = expand only, true = expand + analysis
        let activeInputPanel = 'transcript';  // 'transcript' or 'soap'

        // Transcript Enhancement Variable
        let transcriptEnhanceMode = false;  // false = expand only, true = enhanced with briefing

        // V6 Interactive Review System Variables
        let currentSuggestions = [];  // Stores parsed AI suggestions for review

        // Attending Summary Variables
        let lastGeneratedNote = '';  // Stores last generated note for attending summary

        // Compression Versions Storage (for auto-generated compressed/ultracompressed notes)
        let currentNoteVersions = {
            full: '',           // Full finalized note
            standard: '',       // Compressed: Standard DOAP (45 sec, ~120-140 words)
            ultra: '',          // Ultracompressed: ULTRATHINK (15 sec, ~35-50 words)
            telegram: '',       // Super-compressed: Telegram (5 sec, ~15-25 words)
            // Status tracking for UI indicators
            status: {
                standard: 'pending',  // 'pending', 'generating', 'ready', 'failed'
                ultra: 'pending',     // 'pending', 'generating', 'ready', 'failed'
                telegram: 'pending'   // 'pending', 'generating', 'ready', 'failed'
            }
        };

        // V8 Validation Results Storage
        let lastValidationResult = null;  // Stores most recent validation analysis

        class GroundingValidator {
            constructor(sourceText) {
                this.sourceText = sourceText;
                this.lastValidation = null;
            }

            /**
             * Validate grounding quality of extracted data
             */
            async validate(extractedData) {
                if (!extractedData || !this.sourceText) {
                    throw new Error('Both extracted data and source text are required');
                }

                console.log('üîç [Grounding] Starting validation...');

                try {
                    const warnings = [];
                    const errors = [];
                    const fieldValidations = [];

                    // Traverse extraction and validate each grounded field
                    const groundingAnalysis = this.analyzeGrounding(
                        extractedData,
                        '',
                        fieldValidations
                    );

                    console.log(`   [Grounding] Fields analyzed: ${groundingAnalysis.totalFields}`);
                    console.log(`   [Grounding] Grounded fields: ${groundingAnalysis.groundedFields}`);
                    console.log(`   [Grounding] Orphaned fields: ${groundingAnalysis.orphanedFields.length}`);

                    // Validate orphaned fields (no sourceQuote)
                    if (groundingAnalysis.orphanedFields.length > 0) {
                        groundingAnalysis.orphanedFields.forEach(field => {
                            errors.push({
                                type: 'orphaned_field',
                                field: field.path,
                                value: field.value,
                                message: `Field "${field.path}" has no sourceQuote - possible fabrication`,
                                severity: 'CRITICAL'
                            });
                        });
                    }

                    // Validate sourceQuote quality
                    const qualityIssues = this.validateSourceQuoteQuality(fieldValidations);
                    qualityIssues.errors.forEach(err => errors.push(err));
                    qualityIssues.warnings.forEach(warn => warnings.push(warn));

                    // Calculate grounding quality scores
                    const scores = this.calculateGroundingScores(fieldValidations, groundingAnalysis);

                    console.log(`   [Grounding] Quality score: ${scores.overall}/100`);
                    console.log(`   [Grounding] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastValidation = {
                        valid: errors.length === 0,
                        passed: scores.coverage >= (CONFIG.validation.groundingCoverageMinimum * 100),
                        errors: errors,
                        warnings: warnings,
                        scores: scores,
                        fieldValidations: fieldValidations,
                        groundingAnalysis: groundingAnalysis,
                        validatedAt: new Date().toISOString()
                    };

                    console.log(this.lastValidation.passed ?
                        '‚úÖ [Grounding] Validation PASSED' :
                        '‚ö†Ô∏è  [Grounding] Validation FAILED'
                    );

                    return this.lastValidation;

                } catch (error) {
                    console.error('‚ùå [Grounding] Validation error:', error);
                    return {
                        valid: false,
                        passed: false,
                        error: error.message,
                        scores: { overall: 0 }
                    };
                }
            }

            /**
             * Analyze grounding coverage recursively
             */
            analyzeGrounding(data, path = '', fieldValidations = []) {
                const analysis = {
                    totalFields: 0,
                    groundedFields: 0,
                    orphanedFields: [],
                    inferredFields: [],
                    calculatedFields: []
                };

                if (!data || typeof data !== 'object') {
                    return analysis;
                }

                for (const [key, value] of Object.entries(data)) {
                    const currentPath = path ? `${path}.${key}` : key;

                    if (value === null || value === undefined) {
                        continue;
                    }

                    // Check if this is a grounded field
                    if (this.isGroundedField(value)) {
                        analysis.totalFields++;

                        const validation = {
                            path: currentPath,
                            value: value.value,
                            sourceQuote: value.sourceQuote,
                            confidence: value.confidence,
                            quoteExists: false,
                            quoteQuality: 'NONE',
                            wordCount: 0,
                            deduced: value.deductionMetadata?.deduced || false,
                            calculated: value.calculationMetadata?.method ? true : false
                        };

                        // Check if sourceQuote exists
                        if (value.sourceQuote && value.sourceQuote.trim().length > 0) {
                            analysis.groundedFields++;

                            validation.quoteExists = this.quoteExistsInText(value.sourceQuote);
                            validation.wordCount = value.sourceQuote.split(/\s+/).length;
                            validation.quoteQuality = this.assessQuoteQuality(
                                value.sourceQuote,
                                value.value
                            );
                        } else {
                            analysis.orphanedFields.push({
                                path: currentPath,
                                value: value.value
                            });
                        }

                        if (validation.deduced) {
                            analysis.inferredFields.push(currentPath);
                        }
                        if (validation.calculated) {
                            analysis.calculatedFields.push(currentPath);
                        }

                        fieldValidations.push(validation);

                    } else if (typeof value === 'object' && !Array.isArray(value)) {
                        // Recurse into nested objects
                        const nestedAnalysis = this.analyzeGrounding(value, currentPath, fieldValidations);
                        analysis.totalFields += nestedAnalysis.totalFields;
                        analysis.groundedFields += nestedAnalysis.groundedFields;
                        analysis.orphanedFields.push(...nestedAnalysis.orphanedFields);
                        analysis.inferredFields.push(...nestedAnalysis.inferredFields);
                        analysis.calculatedFields.push(...nestedAnalysis.calculatedFields);
                    }
                }

                return analysis;
            }

            /**
             * Check if field has grounding metadata
             */
            isGroundedField(value) {
                if (typeof value !== 'object' || value === null) {
                    return false;
                }
                return (
                    value.hasOwnProperty('value') &&
                    value.hasOwnProperty('sourceQuote') &&
                    value.hasOwnProperty('confidence')
                );
            }

            /**
             * Check if sourceQuote exists in original text
             */
            quoteExistsInText(sourceQuote) {
                if (!sourceQuote || !this.sourceText) {
                    return false;
                }
                const normalizedQuote = sourceQuote.trim().toLowerCase().replace(/\s+/g, ' ');
                const normalizedText = this.sourceText.toLowerCase().replace(/\s+/g, ' ');
                return normalizedText.includes(normalizedQuote);
            }

            /**
             * Assess sourceQuote quality
             */
            assessQuoteQuality(sourceQuote, extractedValue) {
                if (!sourceQuote || sourceQuote.trim().length === 0) {
                    return 'NONE';
                }

                const wordCount = sourceQuote.split(/\s+/).length;
                const exists = this.quoteExistsInText(sourceQuote);

                let score = 0;

                // Factor 1: Quote exists in text
                if (exists) score += 40;

                // Factor 2: Quote length (3-10 words ideal)
                if (wordCount >= 3 && wordCount <= 10) {
                    score += 30;
                } else if (wordCount >= 2) {
                    score += 15;
                }

                // Factor 3: Quote relevance
                const relevance = this.assessQuoteRelevance(sourceQuote, extractedValue);
                score += relevance * 30;

                // Map to quality tier
                if (score >= 85) return 'EXCELLENT';
                if (score >= 70) return 'GOOD';
                if (score >= 50) return 'ACCEPTABLE';
                if (score >= 25) return 'POOR';
                return 'VERY_POOR';
            }

            /**
             * Assess relevance of sourceQuote to extracted value
             */
            assessQuoteRelevance(sourceQuote, extractedValue) {
                if (!sourceQuote || !extractedValue) return 0.0;

                const quoteLower = sourceQuote.toLowerCase();
                const valueLower = String(extractedValue).toLowerCase();

                if (quoteLower.includes(valueLower)) return 1.0;

                const valueTerms = valueLower.split(/\s+/).filter(t => t.length > 3);
                const quoteTerms = quoteLower.split(/\s+/);

                if (valueTerms.length === 0) return 0.5;

                const foundTerms = valueTerms.filter(term =>
                    quoteTerms.some(qt => qt.includes(term) || term.includes(qt))
                );

                return foundTerms.length / valueTerms.length;
            }

            /**
             * Validate sourceQuote quality and generate errors/warnings
             */
            validateSourceQuoteQuality(fieldValidations) {
                const errors = [];
                const warnings = [];

                fieldValidations.forEach(field => {
                    // Error: SourceQuote doesn't exist in text
                    if (field.sourceQuote && !field.quoteExists) {
                        errors.push({
                            type: 'quote_not_found',
                            field: field.path,
                            sourceQuote: field.sourceQuote,
                            message: `SourceQuote not found: "${field.sourceQuote.substring(0, 50)}..."`,
                            severity: 'CRITICAL'
                        });
                    }

                    // Error: SourceQuote too short
                    if (field.sourceQuote && field.wordCount < 2) {
                        errors.push({
                            type: 'quote_too_short',
                            field: field.path,
                            wordCount: field.wordCount,
                            message: `SourceQuote too short (${field.wordCount} words)`,
                            severity: 'HIGH'
                        });
                    }

                    // Warning: Poor quality
                    if (['POOR', 'VERY_POOR'].includes(field.quoteQuality)) {
                        warnings.push({
                            type: 'poor_quote_quality',
                            field: field.path,
                            quality: field.quoteQuality,
                            message: `Poor sourceQuote quality (${field.quoteQuality})`
                        });
                    }

                    // Warning: Quote too long
                    if (field.wordCount > 15) {
                        warnings.push({
                            type: 'quote_too_long',
                            field: field.path,
                            wordCount: field.wordCount,
                            message: `SourceQuote very long (${field.wordCount} words)`
                        });
                    }
                });

                return { errors, warnings };
            }

            /**
             * Calculate comprehensive grounding scores
             */
            calculateGroundingScores(fieldValidations, groundingAnalysis) {
                const scores = {
                    overall: 0,
                    coverage: 0,
                    averageQuoteQuality: 0,
                    existenceRate: 0,
                    relevanceAverage: 0
                };

                if (groundingAnalysis.totalFields === 0) {
                    return scores;
                }

                // Coverage score (0-100)
                scores.coverage = Math.round(
                    (groundingAnalysis.groundedFields / groundingAnalysis.totalFields) * 100
                );

                // Average quote quality
                const qualityMap = {
                    'EXCELLENT': 100,
                    'GOOD': 80,
                    'ACCEPTABLE': 60,
                    'POOR': 40,
                    'VERY_POOR': 20,
                    'NONE': 0
                };

                const qualityScores = fieldValidations.map(f => qualityMap[f.quoteQuality] || 0);
                scores.averageQuoteQuality = qualityScores.length > 0
                    ? Math.round(qualityScores.reduce((a, b) => a + b, 0) / qualityScores.length)
                    : 0;

                // Existence rate
                const existingQuotes = fieldValidations.filter(f => f.quoteExists).length;
                scores.existenceRate = fieldValidations.length > 0
                    ? Math.round((existingQuotes / fieldValidations.length) * 100)
                    : 0;

                // Relevance average
                const relevances = fieldValidations
                    .filter(f => f.sourceQuote)
                    .map(f => this.assessQuoteRelevance(f.sourceQuote, f.value));

                scores.relevanceAverage = relevances.length > 0
                    ? Math.round((relevances.reduce((a, b) => a + b, 0) / relevances.length) * 100)
                    : 0;

                // Overall score (weighted)
                scores.overall = Math.round(
                    scores.coverage * 0.3 +
                    scores.averageQuoteQuality * 0.3 +
                    scores.existenceRate * 0.25 +
                    scores.relevanceAverage * 0.15
                );

                return scores;
            }
        }

        console.log('‚úÖ GroundingValidator loaded');

        // ============================================================
        // SECTION 9: FABRICATION DETECTOR
        // ============================================================

        /**
         * FabricationDetector Class
         * Detects fabricated, unsupported, or over-elaborated content using semantic analysis
         * Ported from NeuroScribe V8
         */
        class FabricationDetector {
            constructor(apiClient) {
                this.apiClient = apiClient;
                this.lastDetection = null;
            }

            /**
             * Detect fabrications in generated text
             * @param {string} generatedText - Generated output text
             * @param {object} extractedData - Source extraction with grounded fields
             * @param {string} originalText - Original clinical notes
             * @param {object} options - Detection options
             * @returns {Promise<object>} - Detection result with fabricated statements
             */
            async detect(generatedText, extractedData, originalText, options = {}) {
                if (!generatedText || !extractedData) {
                    throw new Error('Generated text and extracted data are required');
                }

                console.log('üîç [Fabrication] Starting detection...');

                try {
                    const warnings = [];
                    const errors = [];

                    // Extract all sourceQuotes from extraction
                    const sourceQuotes = this.extractAllSourceQuotes(extractedData);
                    const sourceCorpus = sourceQuotes.join(' ');

                    console.log(`   [Fabrication] Source quotes collected: ${sourceQuotes.length}`);

                    // Split generated text into checkable statements
                    const statements = this.extractStatements(generatedText);
                    console.log(`   [Fabrication] Statements to validate: ${statements.length}`);

                    // Method 1: Term-based detection (fast, preliminary)
                    const termBasedResults = this.detectFabricationsByTerms(
                        statements,
                        sourceCorpus
                    );

                    // Method 2: Semantic AI detection (accurate, comprehensive)
                    const semanticResults = await this.detectFabricationsBySemantic(
                        statements,
                        sourceQuotes,
                        originalText,
                        options
                    );

                    // Merge results (semantic takes precedence)
                    const fabrications = this.mergeDetectionResults(
                        termBasedResults,
                        semanticResults,
                        statements
                    );

                    console.log(`   [Fabrication] Detected: ${fabrications.length}`);

                    // Generate errors for fabrications
                    fabrications.forEach(fab => {
                        if (fab.confidence >= 0.7) {
                            errors.push({
                                type: 'fabricated_content',
                                statement: fab.statement,
                                confidence: fab.confidence,
                                reason: fab.reason,
                                correction: fab.suggestedCorrection,
                                message: `Fabricated content detected: "${fab.statement.substring(0, 100)}..." (confidence: ${(fab.confidence * 100).toFixed(0)}%)`,
                                severity: 'CRITICAL'
                            });
                        } else if (fab.confidence >= 0.4) {
                            warnings.push({
                                type: 'possible_fabrication',
                                statement: fab.statement,
                                confidence: fab.confidence,
                                reason: fab.reason,
                                message: `Possible unsupported content: "${fab.statement.substring(0, 100)}..." (confidence: ${(fab.confidence * 100).toFixed(0)}%)`
                            });
                        }
                    });

                    // Check for over-elaboration
                    const elaborationCheck = this.checkOverElaboration(
                        generatedText,
                        sourceQuotes,
                        statements.length
                    );

                    if (elaborationCheck.overElaborated) {
                        warnings.push({
                            type: 'over_elaboration',
                            message: elaborationCheck.message,
                            details: elaborationCheck.details
                        });
                    }

                    // Calculate fabrication score
                    const fabricationScore = this.calculateFabricationScore(
                        fabrications,
                        statements.length,
                        elaborationCheck
                    );

                    console.log(`   [Fabrication] Score: ${fabricationScore}/100`);
                    console.log(`   [Fabrication] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastDetection = {
                        passed: errors.length === 0,
                        errors: errors,
                        warnings: warnings,
                        fabrications: fabrications,
                        fabricationScore: fabricationScore,
                        statementsChecked: statements.length,
                        detectedAt: new Date().toISOString()
                    };

                    console.log(errors.length === 0 ? '‚úÖ [Fabrication] Passed' : '‚ùå [Fabrication] Failed');

                    return {
                        success: true,
                        validation: this.lastDetection,
                        metadata: {
                            statementsChecked: statements.length,
                            fabricationsFound: fabrications.length,
                            fabricationScore: fabricationScore
                        }
                    };

                } catch (error) {
                    console.error('‚ùå [Fabrication] Detection error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        metadata: null
                    };
                }
            }

            /**
             * Extract all sourceQuotes from extracted data recursively
             */
            extractAllSourceQuotes(data, quotes = []) {
                if (!data || typeof data !== 'object') {
                    return quotes;
                }

                // Check if this is a grounded field
                if (data.hasOwnProperty('sourceQuote') && data.sourceQuote) {
                    quotes.push(data.sourceQuote.trim());
                }

                // Recurse into nested structures
                for (const value of Object.values(data)) {
                    if (typeof value === 'object' && value !== null) {
                        this.extractAllSourceQuotes(value, quotes);
                    }
                }

                return quotes;
            }

            /**
             * Extract checkable statements from generated text
             */
            extractStatements(text) {
                // Split by sentence boundaries
                const sentences = text
                    .split(/[.!?]\s+/)
                    .map(s => s.trim())
                    .filter(s => s.length > 10); // Ignore very short fragments

                return sentences;
            }

            /**
             * Term-based fabrication detection (fast, preliminary)
             */
            detectFabricationsByTerms(statements, sourceCorpus) {
                const results = [];
                const corpusLower = sourceCorpus.toLowerCase();

                statements.forEach(statement => {
                    // Extract medical terms (>3 chars, not common words)
                    const terms = statement.toLowerCase()
                        .split(/\s+/)
                        .filter(word =>
                            word.length > 3 &&
                            !/^(the|and|with|for|from|that|this|have|been|were|was)$/.test(word)
                        );

                    if (terms.length === 0) {
                        return; // Skip statements with no medical terms
                    }

                    // Check how many terms exist in source corpus
                    const foundTerms = terms.filter(term => corpusLower.includes(term));
                    const foundRatio = foundTerms.length / terms.length;

                    // If <50% of terms found, possible fabrication
                    if (foundRatio < 0.5) {
                        results.push({
                            statement: statement,
                            foundRatio: foundRatio,
                            method: 'term-based',
                            confidence: 1.0 - foundRatio // Low foundRatio = high fabrication confidence
                        });
                    }
                });

                return results;
            }

            /**
             * Semantic AI-based fabrication detection (accurate, comprehensive)
             */
            async detectFabricationsBySemantic(statements, sourceQuotes, originalText, options = {}) {
                if (statements.length === 0) {
                    return [];
                }

                console.log('   [Fabrication] Running semantic analysis...');

                // Prepare prompt for AI analysis
                const prompt = this.buildSemanticDetectionPrompt(
                    statements,
                    sourceQuotes,
                    originalText
                );

                try {
                    // Use validation temperature (0.1)
                    const response = await this.apiClient.generate(
                        prompt,
                        {
                            temperature: CONFIG.temperature.validation,
                            maxOutputTokens: 4096
                        }
                    );

                    if (!response) {
                        console.warn('‚ö†Ô∏è [Fabrication] Semantic detection failed, using term-based only');
                        return [];
                    }

                    // Parse AI response
                    const analysisResults = this.parseSemanticDetectionResponse(response);

                    console.log(`   [Fabrication] Semantic analysis complete: ${analysisResults.length} potential fabrications`);

                    return analysisResults;

                } catch (error) {
                    console.warn('‚ö†Ô∏è [Fabrication] Semantic detection error:', error.message);
                    return [];
                }
            }

            /**
             * Build prompt for semantic fabrication detection
             */
            buildSemanticDetectionPrompt(statements, sourceQuotes, originalText) {
                return `You are a medical documentation validator. Your task is to identify fabricated, unsupported, or over-elaborated statements.

**ORIGINAL CLINICAL NOTES:**
${originalText.substring(0, 2000)}...

**EXTRACTED SOURCE QUOTES (Ground Truth):**
${sourceQuotes.slice(0, 30).map((q, i) => `${i + 1}. "${q}"`).join('\n')}

**STATEMENTS TO VALIDATE:**
${statements.slice(0, 50).map((s, i) => `[${i + 1}] ${s}`).join('\n\n')}

**TASK:**
For each statement, determine if it is:
1. **SUPPORTED**: Directly supported by source quotes or original notes
2. **FABRICATED**: Contains information not in source material
3. **OVER-ELABORATED**: Contains source information but with added interpretation/detail

**RULES:**
- A statement is SUPPORTED if its key medical facts appear in source quotes
- A statement is FABRICATED if it introduces new medical facts not documented
- Paraphrasing is acceptable IF the medical meaning is preserved
- Clinical terminology changes (e.g., "SAH" ‚Üí "subarachnoid hemorrhage") are acceptable
- Added interpretations, assumptions, or explanations = FABRICATION

**OUTPUT FORMAT (JSON):**
\`\`\`json
{
  "fabrications": [
    {
      "statementIndex": <number>,
      "statement": "<full statement text>",
      "status": "FABRICATED" | "OVER_ELABORATED",
      "confidence": <0.0-1.0>,
      "reason": "<why this is fabricated>",
      "missingSupport": "<what information lacks grounding>",
      "suggestedCorrection": "<how to fix, or null if should be removed>"
    }
  ]
}
\`\`\`

Analyze all statements and return ONLY the JSON object.`;
            }

            /**
             * Parse AI response for semantic detection
             */
            parseSemanticDetectionResponse(responseText) {
                try {
                    // Extract JSON from response
                    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    if (!jsonMatch) {
                        console.warn('‚ö†Ô∏è [Fabrication] No JSON found in semantic detection response');
                        return [];
                    }

                    const parsed = JSON.parse(jsonMatch[0]);

                    if (!parsed.fabrications || !Array.isArray(parsed.fabrications)) {
                        console.warn('‚ö†Ô∏è [Fabrication] Invalid response format');
                        return [];
                    }

                    return parsed.fabrications.map(fab => ({
                        statement: fab.statement,
                        confidence: fab.confidence || 0.5,
                        reason: fab.reason,
                        missingSupport: fab.missingSupport,
                        suggestedCorrection: fab.suggestedCorrection,
                        method: 'semantic-ai',
                        status: fab.status
                    }));

                } catch (error) {
                    console.warn('‚ö†Ô∏è [Fabrication] Failed to parse response:', error.message);
                    return [];
                }
            }

            /**
             * Merge term-based and semantic detection results
             */
            mergeDetectionResults(termBased, semantic, allStatements) {
                const merged = [];
                const processedStatements = new Set();

                // Add semantic results (higher priority)
                semantic.forEach(result => {
                    merged.push(result);
                    processedStatements.add(result.statement);
                });

                // Add term-based results not caught by semantic
                termBased.forEach(result => {
                    if (!processedStatements.has(result.statement)) {
                        merged.push({
                            statement: result.statement,
                            confidence: result.confidence,
                            reason: `Low source term coverage (${(result.foundRatio * 100).toFixed(0)}%)`,
                            method: result.method,
                            suggestedCorrection: null
                        });
                    }
                });

                return merged;
            }

            /**
             * Check for over-elaboration
             */
            checkOverElaboration(generatedText, sourceQuotes, statementCount) {
                const generatedWordCount = generatedText.split(/\s+/).length;
                const sourceWordCount = sourceQuotes.join(' ').split(/\s+/).length;

                // Calculate expansion ratio
                const expansionRatio = sourceWordCount > 0 ? generatedWordCount / sourceWordCount : 0;

                let overElaborated = false;
                let message = '';
                let details = {};

                if (expansionRatio > 3.0 && sourceQuotes.length < 10) {
                    // More than 3x expansion with sparse source data
                    overElaborated = true;
                    message = `Generated text (${generatedWordCount} words) is ${expansionRatio.toFixed(1)}x longer than source material (${sourceWordCount} words) - possible over-elaboration`;
                    details = {
                        generatedWords: generatedWordCount,
                        sourceWords: sourceWordCount,
                        expansionRatio: expansionRatio.toFixed(2),
                        sourceQuoteCount: sourceQuotes.length
                    };
                } else if (statementCount > sourceQuotes.length * 2) {
                    // More than 2x statements compared to source quotes
                    overElaborated = true;
                    message = `Generated ${statementCount} statements from ${sourceQuotes.length} source quotes - possible over-elaboration`;
                    details = {
                        statementsGenerated: statementCount,
                        sourceQuotes: sourceQuotes.length,
                        ratio: (statementCount / sourceQuotes.length).toFixed(2)
                    };
                }

                return {
                    overElaborated: overElaborated,
                    message: message,
                    details: details
                };
            }

            /**
             * Calculate fabrication score (0-100, higher is better)
             */
            calculateFabricationScore(fabrications, totalStatements, elaborationCheck) {
                if (totalStatements === 0) {
                    return 100;
                }

                let score = 100;

                // Deduct for fabrications
                const criticalFabrications = fabrications.filter(f => f.confidence >= 0.7).length;
                const possibleFabrications = fabrications.filter(f => f.confidence >= 0.4 && f.confidence < 0.7).length;

                score -= criticalFabrications * 15; // -15 per critical fabrication
                score -= possibleFabrications * 5;  // -5 per possible fabrication

                // Deduct for over-elaboration
                if (elaborationCheck.overElaborated) {
                    score -= 10;
                }

                // Calculate fabrication rate
                const fabricationRate = fabrications.length / totalStatements;
                if (fabricationRate > 0.3) {
                    score -= 20; // High fabrication rate penalty
                }

                return Math.max(0, Math.min(100, score));
            }

            /**
             * Get last detection result
             */
            getLastDetection() {
                return this.lastDetection;
            }

            /**
             * Get fabricated statements only
             */
            getFabricatedStatements() {
                if (!this.lastDetection) {
                    return [];
                }
                return this.lastDetection.fabrications;
            }
        }

        console.log('‚úÖ FabricationDetector loaded');

        // ============================================================
        // SECTION 10: COMPLETENESS CHECKER
        // ============================================================

        /**
         * CompletenessChecker Class
         * Bidirectional validation to ensure all documented facts are extracted
         * Ported from NeuroScribe V8
         */
        class CompletenessChecker {
            constructor(apiClient) {
                this.apiClient = apiClient;
                this.lastCheck = null;
            }

            /**
             * Check completeness of extraction
             * @param {object} extractedData - Extraction result
             * @param {string} originalText - Original clinical text
             * @param {object} options - Check options
             * @returns {Promise<object>} - Completeness validation result
             */
            async check(extractedData, originalText, options = {}) {
                if (!extractedData || !originalText) {
                    throw new Error('Both extracted data and original text are required');
                }

                console.log('üîç [Completeness] Starting check...');

                try {
                    const warnings = [];
                    const errors = [];

                    // 1. Backward validation: Extraction ‚Üí Notes
                    console.log('   [Completeness] Backward validation (extraction ‚Üí notes)...');
                    const backwardCheck = this.checkBackwardCompleteness(extractedData, originalText);

                    // 2. Forward validation: Notes ‚Üí Extraction (AI-powered)
                    console.log('   [Completeness] Forward validation (notes ‚Üí extraction)...');
                    const forwardCheck = await this.checkForwardCompleteness(
                        originalText,
                        extractedData,
                        options
                    );

                    // 3. Section coverage analysis
                    console.log('   [Completeness] Analyzing section coverage...');
                    const sectionCoverage = this.analyzeSectionCoverage(extractedData, originalText);

                    // 4. Critical field coverage
                    const criticalFieldsCheck = this.checkCriticalFields(extractedData);

                    // Generate warnings and errors
                    if (backwardCheck.unmatchedFields.length > 0) {
                        backwardCheck.unmatchedFields.forEach(field => {
                            warnings.push({
                                type: 'ungrounded_extraction',
                                field: field.path,
                                value: field.value,
                                message: `Extracted field not found in original text: ${field.path}`
                            });
                        });
                    }

                    // Forward completeness issues
                    if (forwardCheck.missingExtractions.length > 0) {
                        forwardCheck.missingExtractions.forEach(missing => {
                            if (missing.importance === 'CRITICAL') {
                                errors.push({
                                    type: 'missing_critical_extraction',
                                    category: missing.category,
                                    information: missing.information,
                                    sourceQuote: missing.sourceQuote,
                                    message: `Critical information not extracted: ${missing.information}`,
                                    severity: 'HIGH'
                                });
                            } else {
                                warnings.push({
                                    type: 'missing_extraction',
                                    category: missing.category,
                                    information: missing.information,
                                    sourceQuote: missing.sourceQuote,
                                    message: `Information may not be extracted: ${missing.information}`
                                });
                            }
                        });
                    }

                    // Section coverage issues
                    if (sectionCoverage.missingImportantSections.length > 0) {
                        sectionCoverage.missingImportantSections.forEach(section => {
                            warnings.push({
                                type: 'missing_section',
                                section: section.name,
                                message: `Important section "${section.name}" mentioned in notes but not extracted`
                            });
                        });
                    }

                    // Critical field issues
                    if (criticalFieldsCheck.missingCritical.length > 0) {
                        criticalFieldsCheck.missingCritical.forEach(field => {
                            errors.push({
                                type: 'missing_critical_field',
                                field: field,
                                message: `Critical required field missing: ${field}`,
                                severity: 'CRITICAL'
                            });
                        });
                    }

                    // Calculate completeness scores
                    const scores = this.calculateCompletenessScores(
                        backwardCheck,
                        forwardCheck,
                        sectionCoverage,
                        criticalFieldsCheck
                    );

                    console.log(`   [Completeness] Score: ${scores.overall}/100`);
                    console.log(`   [Completeness] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastCheck = {
                        passed: errors.length === 0,
                        errors: errors,
                        warnings: warnings,
                        scores: scores,
                        backwardCheck: backwardCheck,
                        forwardCheck: forwardCheck,
                        sectionCoverage: sectionCoverage,
                        criticalFieldsCheck: criticalFieldsCheck,
                        checkedAt: new Date().toISOString()
                    };

                    console.log(errors.length === 0 ? '‚úÖ [Completeness] Passed' : '‚ùå [Completeness] Issues detected');

                    return {
                        success: true,
                        validation: this.lastCheck,
                        metadata: {
                            extractedFields: backwardCheck.totalFields,
                            groundedFields: backwardCheck.matchedFields,
                            missingExtractions: forwardCheck.missingExtractions.length,
                            sectionsCovered: sectionCoverage.coveredSections.length,
                            completenessScore: scores.overall
                        }
                    };

                } catch (error) {
                    console.error('‚ùå [Completeness] Check error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        metadata: null
                    };
                }
            }

            /**
             * Backward completeness: Extraction ‚Üí Notes
             */
            checkBackwardCompleteness(extractedData, originalText) {
                const normalizedText = originalText.toLowerCase().replace(/\s+/g, ' ');
                const unmatchedFields = [];
                let totalFields = 0;
                let matchedFields = 0;

                this.traverseExtraction(extractedData, '', (path, field) => {
                    totalFields++;

                    if (field.sourceQuote) {
                        const normalizedQuote = field.sourceQuote.toLowerCase().replace(/\s+/g, ' ');

                        if (normalizedText.includes(normalizedQuote)) {
                            matchedFields++;
                        } else {
                            unmatchedFields.push({
                                path: path,
                                value: field.value,
                                sourceQuote: field.sourceQuote
                            });
                        }
                    } else {
                        unmatchedFields.push({
                            path: path,
                            value: field.value,
                            sourceQuote: null
                        });
                    }
                });

                return {
                    totalFields: totalFields,
                    matchedFields: matchedFields,
                    unmatchedFields: unmatchedFields,
                    backwardCompleteness: totalFields > 0 ? matchedFields / totalFields : 1.0
                };
            }

            /**
             * Forward completeness: Notes ‚Üí Extraction
             */
            async checkForwardCompleteness(originalText, extractedData, options = {}) {
                console.log('   [Completeness] Running AI-powered forward analysis...');

                const extractedSummary = this.buildExtractionSummary(extractedData);
                const prompt = this.buildForwardCompletenessPrompt(originalText, extractedSummary);

                try {
                    const response = await this.apiClient.generate(
                        prompt,
                        {
                            temperature: CONFIG.temperature.extraction,
                            maxOutputTokens: 3072
                        }
                    );

                    if (!response) {
                        console.warn('‚ö†Ô∏è [Completeness] Forward check failed');
                        return { missingExtractions: [], forwardCompleteness: 1.0 };
                    }

                    const missingExtractions = this.parseForwardCompletenessResponse(response);

                    console.log(`   [Completeness] Missing extractions: ${missingExtractions.length}`);

                    const totalMentioned = extractedSummary.fieldCount + missingExtractions.length;
                    const forwardCompleteness = totalMentioned > 0
                        ? extractedSummary.fieldCount / totalMentioned
                        : 1.0;

                    return {
                        missingExtractions: missingExtractions,
                        forwardCompleteness: forwardCompleteness
                    };

                } catch (error) {
                    console.warn('‚ö†Ô∏è [Completeness] Forward check error:', error.message);
                    return { missingExtractions: [], forwardCompleteness: 1.0 };
                }
            }

            /**
             * Build summary of what was extracted
             */
            buildExtractionSummary(data) {
                const summary = {
                    fields: [],
                    fieldCount: 0,
                    sections: new Set()
                };

                this.traverseExtraction(data, '', (path, field) => {
                    summary.fieldCount++;
                    summary.fields.push({
                        path: path,
                        value: field.value,
                        sourceQuote: field.sourceQuote
                    });

                    const topSection = path.split('.')[0];
                    summary.sections.add(topSection);
                });

                return summary;
            }

            /**
             * Build prompt for forward completeness check
             */
            buildForwardCompletenessPrompt(originalText, extractedSummary) {
                return `You are a medical documentation completeness auditor. Identify clinical information in notes NOT captured in extraction.

**ORIGINAL CLINICAL NOTES:**
${originalText.substring(0, 3000)}

**WHAT WAS EXTRACTED:**
${extractedSummary.fields.slice(0, 50).map(f => `- ${f.path}: ${f.value}`).join('\n')}

**SECTIONS COVERED:** ${Array.from(extractedSummary.sections).join(', ')}

**TASK:**
Identify clinically significant information NOT extracted. Focus on:

1. **Patient demographics** (age, sex, medical history)
2. **Symptoms and presentation**
3. **Physical exam findings** (neurological)
4. **Imaging findings** (measurements, locations)
5. **Diagnoses** (primary and secondary)
6. **Procedures** (past, current, planned)
7. **Medications**
8. **Clinical scores** (GCS, mRS, KPS, etc.)
9. **Plans and follow-up**

**RULES:**
- Only flag EXPLICIT mentions
- Medical measurements, scores, laterality are CRITICAL
- Vague references don't need extraction
- Background context is acceptable to omit

**OUTPUT FORMAT (JSON):**
\`\`\`json
{
  "missingExtractions": [
    {
      "category": "imaging|diagnosis|procedure|medication|symptoms|scores|demographics",
      "information": "<what information is missing>",
      "sourceQuote": "<exact quote from notes>",
      "importance": "CRITICAL" | "IMPORTANT" | "MINOR",
      "suggestedField": "<where this should be extracted>"
    }
  ]
}
\`\`\`

Return ONLY JSON. If nothing missing, return empty array.`;
            }

            /**
             * Parse AI response for forward completeness
             */
            parseForwardCompletenessResponse(responseText) {
                try {
                    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    if (!jsonMatch) {
                        console.warn('‚ö†Ô∏è [Completeness] No JSON in response');
                        return [];
                    }

                    const parsed = JSON.parse(jsonMatch[0]);

                    if (!parsed.missingExtractions || !Array.isArray(parsed.missingExtractions)) {
                        console.warn('‚ö†Ô∏è [Completeness] Invalid response format');
                        return [];
                    }

                    return parsed.missingExtractions;

                } catch (error) {
                    console.warn('‚ö†Ô∏è [Completeness] Parse error:', error.message);
                    return [];
                }
            }

            /**
             * Analyze section coverage
             */
            analyzeSectionCoverage(extractedData, originalText) {
                const expectedSections = [
                    { name: 'demographics', keywords: ['age', 'year old', 'male', 'female', 'patient'] },
                    { name: 'symptoms', keywords: ['presents', 'complains', 'symptoms', 'history of present'] },
                    { name: 'examination', keywords: ['exam', 'examination', 'neurological', 'motor', 'sensory'] },
                    { name: 'imaging', keywords: ['MRI', 'CT', 'CTA', 'scan', 'imaging', 'shows'] },
                    { name: 'diagnosis', keywords: ['diagnosis', 'impression', 'assessment'] },
                    { name: 'procedures', keywords: ['surgery', 'procedure', 'operation', 'craniotomy', 'laminectomy'] },
                    { name: 'medications', keywords: ['medication', 'drug', 'prescribed', 'started'] },
                    { name: 'plan', keywords: ['plan', 'will', 'scheduled', 'follow-up'] }
                ];

                const textLower = originalText.toLowerCase();
                const coveredSections = [];
                const missingImportantSections = [];

                expectedSections.forEach(section => {
                    const mentioned = section.keywords.some(keyword => textLower.includes(keyword));

                    if (mentioned) {
                        const extracted = this.sectionHasData(extractedData, section.name);

                        if (extracted) {
                            coveredSections.push(section.name);
                        } else {
                            missingImportantSections.push({
                                name: section.name,
                                keywords: section.keywords
                            });
                        }
                    }
                });

                return {
                    coveredSections: coveredSections,
                    missingImportantSections: missingImportantSections,
                    coverageRatio: expectedSections.length > 0
                        ? coveredSections.length / expectedSections.length
                        : 1.0
                };
            }

            /**
             * Check if section has extracted data
             */
            sectionHasData(data, sectionName) {
                if (!data || typeof data !== 'object') {
                    return false;
                }

                const section = data[sectionName] || data[sectionName + 's'];
                if (!section) {
                    return false;
                }

                let hasData = false;
                this.traverseExtraction(section, '', (path, field) => {
                    if (field.sourceQuote && field.sourceQuote.trim().length > 0) {
                        hasData = true;
                    }
                });

                return hasData;
            }

            /**
             * Check critical required fields
             */
            checkCriticalFields(extractedData) {
                const criticalFields = [
                    'demographics.age',
                    'pathology.primaryDiagnosis.name'
                ];

                const missingCritical = [];

                criticalFields.forEach(fieldPath => {
                    const value = this.getFieldByPath(extractedData, fieldPath);
                    if (!value || (value.value === null || value.value === undefined || value.value === '')) {
                        missingCritical.push(fieldPath);
                    }
                });

                return {
                    missingCritical: missingCritical,
                    criticalFieldsPresent: criticalFields.length - missingCritical.length,
                    totalCriticalFields: criticalFields.length
                };
            }

            /**
             * Get field value by path
             */
            getFieldByPath(data, path) {
                const parts = path.split('.');
                let current = data;

                for (const part of parts) {
                    if (!current || typeof current !== 'object') {
                        return null;
                    }
                    current = current[part];
                }

                return current;
            }

            /**
             * Traverse extraction and call callback for each grounded field
             */
            traverseExtraction(data, path = '', callback) {
                if (!data || typeof data !== 'object') {
                    return;
                }

                for (const [key, value] of Object.entries(data)) {
                    if (value === null || value === undefined) {
                        continue;
                    }

                    const currentPath = path ? `${path}.${key}` : key;

                    // Check if grounded field
                    if (typeof value === 'object' &&
                        value.hasOwnProperty('value') &&
                        value.hasOwnProperty('sourceQuote') &&
                        value.hasOwnProperty('confidence')) {

                        callback(currentPath, value);

                    } else if (typeof value === 'object' && !Array.isArray(value)) {
                        this.traverseExtraction(value, currentPath, callback);
                    } else if (Array.isArray(value)) {
                        value.forEach((item, index) => {
                            this.traverseExtraction(item, `${currentPath}[${index}]`, callback);
                        });
                    }
                }
            }

            /**
             * Calculate completeness scores
             */
            calculateCompletenessScores(backwardCheck, forwardCheck, sectionCoverage, criticalFieldsCheck) {
                const scores = {
                    overall: 0,
                    backwardCompleteness: Math.round(backwardCheck.backwardCompleteness * 100),
                    forwardCompleteness: Math.round(forwardCheck.forwardCompleteness * 100),
                    sectionCoverage: Math.round(sectionCoverage.coverageRatio * 100),
                    criticalFields: Math.round(
                        (criticalFieldsCheck.criticalFieldsPresent / criticalFieldsCheck.totalCriticalFields) * 100
                    )
                };

                // Overall score (weighted average)
                scores.overall = Math.round(
                    scores.backwardCompleteness * 0.25 +
                    scores.forwardCompleteness * 0.40 + // Most important
                    scores.sectionCoverage * 0.20 +
                    scores.criticalFields * 0.15
                );

                return scores;
            }

            /**
             * Get last check result
             */
            getLastCheck() {
                return this.lastCheck;
            }

            /**
             * Get missing extractions
             */
            getMissingExtractions() {
                if (!this.lastCheck) {
                    return [];
                }
                return this.lastCheck.forwardCheck.missingExtractions;
            }
        }

        console.log('‚úÖ CompletenessChecker loaded');

        // ============================================================
        // SECTION 11: CONSISTENCY VALIDATOR
        // ============================================================

        /**
         * ConsistencyValidator Class
         * Medical knowledge-based consistency checking
         * CRITICAL: Detects medically implausible or contradictory information
         * Ported from NeuroScribe V8
         */
        class ConsistencyValidator {
            constructor(apiClient) {
                this.apiClient = apiClient;
                this.lastValidation = null;
                this.medicalKnowledge = this.initializeMedicalKnowledge();
            }

            /**
             * Initialize medical knowledge base
             */
            initializeMedicalKnowledge() {
                return {
                    // Spinal levels
                    spinalLevels: {
                        cervical: ['C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7'],
                        thoracic: ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12'],
                        lumbar: ['L1', 'L2', 'L3', 'L4', 'L5'],
                        sacral: ['S1', 'S2', 'S3', 'S4', 'S5']
                    },

                    // GCS score ranges
                    gcsScores: {
                        severe: { range: [3, 8], meaning: 'severe impairment' },
                        moderate: { range: [9, 12], meaning: 'moderate impairment' },
                        mild: { range: [13, 14], meaning: 'mild impairment' },
                        normal: { range: [15, 15], meaning: 'fully alert' }
                    },

                    // mRS score meanings
                    mrsScores: {
                        0: 'no symptoms',
                        1: 'no significant disability',
                        2: 'slight disability',
                        3: 'moderate disability',
                        4: 'moderately severe disability',
                        5: 'severe disability',
                        6: 'dead'
                    },

                    // KPS score ranges
                    kpsScores: {
                        high: { range: [80, 100], meaning: 'normal activity' },
                        moderate: { range: [50, 70], meaning: 'requires assistance' },
                        low: { range: [10, 40], meaning: 'disabled, requires care' }
                    },

                    // Laterality rules (neuroanatomical decussation)
                    lateralityRules: {
                        cerebral: 'contralateral',  // Right brain ‚Üí Left body
                        cerebellar: 'ipsilateral',  // Right cerebellum ‚Üí Right body
                        spinal: 'ipsilateral'       // Right spinal ‚Üí Right symptoms
                    },

                    // Pathology keywords
                    pathologyKeywords: {
                        vascular: ['hemorrhage', 'aneurysm', 'stroke', 'ischemia', 'SAH', 'ICH', 'infarct'],
                        tumor: ['glioblastoma', 'meningioma', 'tumor', 'mass', 'neoplasm', 'metastasis'],
                        degenerative: ['stenosis', 'spondylosis', 'herniation', 'disc', 'DDD'],
                        trauma: ['fracture', 'TBI', 'SCI', 'contusion', 'hematoma'],
                        infection: ['abscess', 'meningitis', 'osteomyelitis', 'infection']
                    }
                };
            }

            /**
             * Validate consistency of extracted data
             */
            async validate(extractedData, originalText, options = {}) {
                if (!extractedData) {
                    throw new Error('Extracted data is required');
                }

                console.log('üîç [Consistency] Starting validation...');

                try {
                    const warnings = [];
                    const errors = [];

                    // 1. Laterality consistency
                    console.log('   [Consistency] Checking laterality...');
                    const lateralityIssues = this.checkLateralityConsistency(extractedData);
                    lateralityIssues.forEach(issue => {
                        errors.push({
                            type: 'laterality_inconsistency',
                            ...issue,
                            severity: 'HIGH'
                        });
                    });

                    // 2. Anatomical level consistency
                    console.log('   [Consistency] Checking anatomical levels...');
                    const anatomicalIssues = this.checkAnatomicalConsistency(extractedData);
                    anatomicalIssues.forEach(issue => {
                        errors.push({
                            type: 'anatomical_inconsistency',
                            ...issue,
                            severity: 'HIGH'
                        });
                    });

                    // 3. Clinical score consistency
                    console.log('   [Consistency] Checking clinical scores...');
                    const scoreIssues = this.checkScoreConsistency(extractedData);
                    scoreIssues.forEach(issue => {
                        if (issue.severity === 'HIGH') {
                            errors.push({
                                type: 'score_inconsistency',
                                ...issue
                            });
                        } else {
                            warnings.push({
                                type: 'score_warning',
                                ...issue
                            });
                        }
                    });

                    // 4. Temporal consistency
                    console.log('   [Consistency] Checking temporal order...');
                    const temporalIssues = this.checkTemporalConsistency(extractedData);
                    temporalIssues.forEach(issue => {
                        errors.push({
                            type: 'temporal_inconsistency',
                            ...issue,
                            severity: 'MEDIUM'
                        });
                    });

                    // 5. Pathology consistency
                    console.log('   [Consistency] Checking pathology-procedure match...');
                    const pathologyIssues = this.checkPathologyConsistency(extractedData);
                    pathologyIssues.forEach(issue => {
                        warnings.push({
                            type: 'pathology_mismatch',
                            ...issue
                        });
                    });

                    // Calculate consistency score
                    const consistencyScore = this.calculateConsistencyScore(
                        errors.length,
                        warnings.length
                    );

                    console.log(`   [Consistency] Score: ${consistencyScore}/100`);
                    console.log(`   [Consistency] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastValidation = {
                        passed: errors.length === 0,
                        errors: errors,
                        warnings: warnings,
                        consistencyScore: consistencyScore,
                        validatedAt: new Date().toISOString()
                    };

                    console.log(errors.length === 0 ? '‚úÖ [Consistency] Passed' : '‚ùå [Consistency] Issues detected');

                    return {
                        success: true,
                        validation: this.lastValidation,
                        metadata: {
                            totalIssues: errors.length + warnings.length,
                            criticalIssues: errors.length,
                            consistencyScore: consistencyScore
                        }
                    };

                } catch (error) {
                    console.error('‚ùå [Consistency] Validation error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        metadata: null
                    };
                }
            }

            /**
             * Check laterality consistency (neuroanatomical decussation rules)
             */
            checkLateralityConsistency(data) {
                const issues = [];

                // Extract lateralized findings
                const lesionSide = this.extractLaterality(data, 'imaging.findings', 'lesion');
                const symptomSide = this.extractLaterality(data, 'symptoms', 'symptom');
                const diagnosisSide = this.extractLaterality(data, 'pathology', 'diagnosis');

                // Determine pathology location
                const pathologyLocation = this.determinePathologyLocation(data);

                // Apply decussation rules
                if (pathologyLocation === 'cerebral') {
                    // Cerebral lesions: contralateral symptoms
                    if (lesionSide && symptomSide && lesionSide === symptomSide) {
                        issues.push({
                            field1: 'imaging.findings (lesion)',
                            field2: 'symptoms',
                            value1: `${lesionSide} sided lesion`,
                            value2: `${symptomSide} sided symptoms`,
                            message: `${lesionSide} cerebral lesion should cause contralateral (${this.oppositeSide(lesionSide)}) symptoms, not ${symptomSide}-sided`,
                            expectedValue: `${this.oppositeSide(lesionSide)} sided symptoms`
                        });
                    }

                } else if (pathologyLocation === 'spinal') {
                    // Spinal lesions: ipsilateral symptoms
                    if (lesionSide && symptomSide && lesionSide !== symptomSide) {
                        issues.push({
                            field1: 'imaging.findings (lesion)',
                            field2: 'symptoms',
                            value1: `${lesionSide} sided lesion`,
                            value2: `${symptomSide} sided symptoms`,
                            message: `${lesionSide} spinal lesion should cause ipsilateral (${lesionSide}) symptoms, not ${symptomSide}-sided`,
                            expectedValue: `${lesionSide} sided symptoms`
                        });
                    }
                }

                return issues;
            }

            /**
             * Extract laterality from data section
             */
            extractLaterality(data, sectionPath, context) {
                const section = this.getFieldByPath(data, sectionPath);
                if (!section) return null;

                const lateralityKeywords = {
                    left: /\b(left|l(?:eft)?)\b/i,
                    right: /\b(right|r(?:ight)?)\b/i
                };

                let foundSide = null;
                this.traverseSection(section, (field) => {
                    if (!foundSide && field.value) {
                        const valueStr = String(field.value).toLowerCase();
                        if (lateralityKeywords.left.test(valueStr)) {
                            foundSide = 'left';
                        } else if (lateralityKeywords.right.test(valueStr)) {
                            foundSide = 'right';
                        }
                    }

                    if (!foundSide && field.sourceQuote) {
                        const quoteStr = field.sourceQuote.toLowerCase();
                        if (lateralityKeywords.left.test(quoteStr)) {
                            foundSide = 'left';
                        } else if (lateralityKeywords.right.test(quoteStr)) {
                            foundSide = 'right';
                        }
                    }
                });

                return foundSide;
            }

            /**
             * Determine pathology location
             */
            determinePathologyLocation(data) {
                const diagnosis = this.getFieldValue(data, 'pathology.primaryDiagnosis.name');
                const imagingFindings = this.getAllSourceQuotes(data.imaging);

                const allText = `${diagnosis} ${imagingFindings}`.toLowerCase();

                if (/\b(cervical|thoracic|lumbar|sacral|spine|spinal|vertebra|disc)\b/i.test(allText)) {
                    return 'spinal';
                } else if (/\b(cerebellar|cerebellum)\b/i.test(allText)) {
                    return 'cerebellar';
                } else if (/\b(cerebral|brain|frontal|parietal|temporal|occipital|hemisphere)\b/i.test(allText)) {
                    return 'cerebral';
                }

                return 'unknown';
            }

            /**
             * Get opposite side for laterality
             */
            oppositeSide(side) {
                if (side === 'left') return 'right';
                if (side === 'right') return 'left';
                return null;
            }

            /**
             * Check anatomical level consistency
             */
            checkAnatomicalConsistency(data) {
                const issues = [];

                const diagnosisLevel = this.extractSpinalLevel(data, 'pathology');
                const procedureLevel = this.extractSpinalLevel(data, 'procedures');

                if (diagnosisLevel && procedureLevel) {
                    const diagnosisRegion = this.getSpinalRegion(diagnosisLevel);
                    const procedureRegion = this.getSpinalRegion(procedureLevel);

                    if (diagnosisRegion !== procedureRegion && diagnosisRegion !== 'unknown' && procedureRegion !== 'unknown') {
                        issues.push({
                            field1: 'pathology (diagnosis level)',
                            field2: 'procedures (procedure level)',
                            value1: `${diagnosisLevel} (${diagnosisRegion})`,
                            value2: `${procedureLevel} (${procedureRegion})`,
                            message: `Diagnosis at ${diagnosisLevel} (${diagnosisRegion}) but procedure at ${procedureLevel} (${procedureRegion}) - region mismatch`,
                            expectedValue: `Procedure should be in ${diagnosisRegion} region`
                        });
                    }
                }

                return issues;
            }

            /**
             * Extract spinal level from section
             */
            extractSpinalLevel(data, sectionPath) {
                const section = this.getFieldByPath(data, sectionPath);
                if (!section) return null;

                const levelPattern = /\b([CTLS])(\d{1,2})(?:-([CTLS])?(\d{1,2}))?\b/gi;

                let foundLevel = null;
                this.traverseSection(section, (field) => {
                    if (!foundLevel) {
                        const text = `${field.value} ${field.sourceQuote}`;
                        const match = levelPattern.exec(text);
                        if (match) {
                            foundLevel = match[0].toUpperCase();
                        }
                    }
                });

                return foundLevel;
            }

            /**
             * Get spinal region from level
             */
            getSpinalRegion(level) {
                if (!level) return 'unknown';

                const levelUpper = level.toUpperCase();

                for (const [region, levels] of Object.entries(this.medicalKnowledge.spinalLevels)) {
                    if (levels.some(l => levelUpper.includes(l))) {
                        return region;
                    }
                }

                return 'unknown';
            }

            /**
             * Check clinical score consistency
             */
            checkScoreConsistency(data) {
                const issues = [];

                // Check GCS consistency
                const gcs = this.getFieldValue(data, 'clinicalScores.gcs.total');
                if (gcs !== null && gcs !== undefined) {
                    const gcsNum = parseInt(gcs);

                    // Validate GCS range (3-15)
                    if (gcsNum < 3 || gcsNum > 15) {
                        issues.push({
                            field: 'clinicalScores.gcs.total',
                            value: gcs,
                            message: `GCS score ${gcs} is outside valid range (3-15)`,
                            severity: 'HIGH'
                        });
                    }

                    // Check GCS components
                    const gcsComponents = this.getFieldValue(data, 'clinicalScores.gcs.components');
                    if (gcsComponents) {
                        const componentMatch = gcsComponents.match(/E(\d+)V(\d+)M(\d+)/i);
                        if (componentMatch) {
                            const e = parseInt(componentMatch[1]);
                            const v = parseInt(componentMatch[2]);
                            const m = parseInt(componentMatch[3]);
                            const calculatedTotal = e + v + m;

                            if (calculatedTotal !== gcsNum) {
                                issues.push({
                                    field: 'clinicalScores.gcs',
                                    value: `Total: ${gcs}, Components: ${gcsComponents}`,
                                    message: `GCS components (E${e}V${v}M${m}) sum to ${calculatedTotal}, but total is ${gcs}`,
                                    severity: 'HIGH'
                                });
                            }
                        }
                    }
                }

                // Check mRS consistency
                const mrs = this.getFieldValue(data, 'outcomes.functionalStatus.mRS');
                if (mrs !== null && mrs !== undefined) {
                    const mrsNum = parseInt(mrs);

                    if (mrsNum < 0 || mrsNum > 6) {
                        issues.push({
                            field: 'outcomes.functionalStatus.mRS',
                            value: mrs,
                            message: `mRS score ${mrs} is outside valid range (0-6)`,
                            severity: 'HIGH'
                        });
                    }
                }

                // Check KPS consistency
                const kps = this.getFieldValue(data, 'outcomes.functionalStatus.KPS');
                if (kps !== null && kps !== undefined) {
                    const kpsNum = parseInt(kps);

                    if (kpsNum < 0 || kpsNum > 100 || kpsNum % 10 !== 0) {
                        issues.push({
                            field: 'outcomes.functionalStatus.KPS',
                            value: kps,
                            message: `KPS score ${kps} should be 0-100 in increments of 10`,
                            severity: 'HIGH'
                        });
                    }
                }

                return issues;
            }

            /**
             * Check temporal consistency (dates in logical order)
             */
            checkTemporalConsistency(data) {
                const issues = [];

                const dob = this.parseDate(this.getFieldValue(data, 'demographics.dateOfBirth'));
                const admission = this.parseDate(this.getFieldValue(data, 'timeline.admissionDate'));
                const discharge = this.parseDate(this.getFieldValue(data, 'timeline.dischargeDate'));

                // Check chronological order
                if (dob && admission && dob > admission) {
                    issues.push({
                        field1: 'demographics.dateOfBirth',
                        field2: 'timeline.admissionDate',
                        value1: this.getFieldValue(data, 'demographics.dateOfBirth'),
                        value2: this.getFieldValue(data, 'timeline.admissionDate'),
                        message: 'Date of birth is after admission date - impossible'
                    });
                }

                if (admission && discharge && admission > discharge) {
                    issues.push({
                        field1: 'timeline.admissionDate',
                        field2: 'timeline.dischargeDate',
                        value1: this.getFieldValue(data, 'timeline.admissionDate'),
                        value2: this.getFieldValue(data, 'timeline.dischargeDate'),
                        message: 'Admission date is after discharge date - impossible'
                    });
                }

                return issues;
            }

            /**
             * Check pathology-procedure consistency
             */
            checkPathologyConsistency(data) {
                const issues = [];

                const diagnosis = this.getFieldValue(data, 'pathology.primaryDiagnosis.name');
                const procedures = this.getAllFieldValues(data, 'procedures');

                if (!diagnosis || procedures.length === 0) {
                    return issues;
                }

                const diagnosisLower = diagnosis.toLowerCase();
                const pathologyType = this.classifyPathology(diagnosisLower);
                const procedureTypes = procedures.map(p => this.classifyProcedure(p.toLowerCase()));

                if (pathologyType && !procedureTypes.includes(pathologyType) && procedureTypes.length > 0) {
                    issues.push({
                        field1: 'pathology.primaryDiagnosis.name',
                        field2: 'procedures',
                        value1: diagnosis,
                        value2: procedures.join(', '),
                        message: `Diagnosis suggests ${pathologyType} pathology but procedures suggest ${procedureTypes.join('/')} approach`
                    });
                }

                return issues;
            }

            /**
             * Classify pathology type
             */
            classifyPathology(diagnosisText) {
                for (const [type, keywords] of Object.entries(this.medicalKnowledge.pathologyKeywords)) {
                    if (keywords.some(keyword => diagnosisText.includes(keyword.toLowerCase()))) {
                        return type;
                    }
                }
                return null;
            }

            /**
             * Classify procedure type
             */
            classifyProcedure(procedureText) {
                if (/clip|coil|embolization|aneurysm|vascular/.test(procedureText)) {
                    return 'vascular';
                } else if (/resection|craniotomy|tumor|mass/.test(procedureText)) {
                    return 'tumor';
                } else if (/fusion|laminectomy|discectomy|decompress/.test(procedureText)) {
                    return 'degenerative';
                } else if (/evacuation|hematoma|hemorrhage/.test(procedureText)) {
                    return 'trauma';
                }
                return null;
            }

            /**
             * Parse date string to Date object
             */
            parseDate(dateStr) {
                if (!dateStr) return null;
                const parsed = new Date(dateStr);
                return isNaN(parsed.getTime()) ? null : parsed;
            }

            /**
             * Calculate consistency score
             */
            calculateConsistencyScore(errorCount, warningCount) {
                let score = 100;
                score -= errorCount * 20;   // -20 per error
                score -= warningCount * 5;  // -5 per warning
                return Math.max(0, Math.min(100, score));
            }

            /**
             * Helper: Get field value by path
             */
            getFieldValue(data, path) {
                const field = this.getFieldByPath(data, path);
                return field?.value ?? null;
            }

            /**
             * Helper: Get field by path
             */
            getFieldByPath(data, path) {
                const parts = path.split('.');
                let current = data;

                for (const part of parts) {
                    if (!current || typeof current !== 'object') {
                        return null;
                    }
                    current = current[part];
                }

                return current;
            }

            /**
             * Helper: Get all field values from section
             */
            getAllFieldValues(data, sectionPath) {
                const section = this.getFieldByPath(data, sectionPath);
                if (!section) return [];

                const values = [];
                this.traverseSection(section, (field) => {
                    if (field.value) {
                        values.push(String(field.value));
                    }
                });

                return values;
            }

            /**
             * Helper: Get all source quotes from section
             */
            getAllSourceQuotes(section) {
                const quotes = [];
                this.traverseSection(section, (field) => {
                    if (field.sourceQuote) {
                        quotes.push(field.sourceQuote);
                    }
                });
                return quotes.join(' ');
            }

            /**
             * Helper: Traverse section
             */
            traverseSection(section, callback) {
                if (!section || typeof section !== 'object') {
                    return;
                }

                for (const value of Object.values(section)) {
                    if (value && typeof value === 'object') {
                        if (value.hasOwnProperty('value') && value.hasOwnProperty('sourceQuote')) {
                            callback(value);
                        } else {
                            this.traverseSection(value, callback);
                        }
                    }
                }
            }

            /**
             * Get last validation result
             */
            getLastValidation() {
                return this.lastValidation;
            }
        }

        console.log('‚úÖ ConsistencyValidator loaded');

        // ============================================================
        // SECTION 12: PROPORTIONALITY VALIDATOR
        // ============================================================

        /**
         * ProportionalityValidator Class
         * Dynamic output sizing validation based on data richness
         * CRITICAL: Ensures output length matches data density (no padding in sparse cases)
         * Ported from NeuroScribe V8
         */
        class ProportionalityValidator {
            constructor(apiClient) {
                this.apiClient = apiClient;
                this.lastValidation = null;
            }

            /**
             * Validate output proportionality
             * @param {string} generatedOutput - Generated text
             * @param {object} extractedData - Source extraction data
             * @param {string} outputType - 'ultrathink', 'doap', 'narrative'
             * @param {object} options - Validation options
             * @returns {Promise<object>} - Validation result
             */
            async validate(generatedOutput, extractedData, outputType, options = {}) {
                if (!generatedOutput || !extractedData || !outputType) {
                    throw new Error('Generated output, extracted data, and output type are required');
                }

                console.log(`üîç [Proportionality] Starting validation (${outputType})...`);

                try {
                    const warnings = [];
                    const errors = [];

                    // Analyze data richness
                    const dataAnalysis = this.analyzeDataRichness(extractedData);
                    console.log(`   [Proportionality] Data richness: ${dataAnalysis.richness} (${dataAnalysis.totalFacts} facts)`);

                    // Calculate output metrics
                    const outputMetrics = this.calculateOutputMetrics(generatedOutput);
                    console.log(`   [Proportionality] Output length: ${outputMetrics.wordCount} words`);

                    // Get expected range
                    const expectedRange = this.getExpectedRange(outputType, dataAnalysis);
                    console.log(`   [Proportionality] Expected range: ${expectedRange.min}-${expectedRange.max} words`);

                    // Check if output is within expected range
                    const withinRange = outputMetrics.wordCount >= expectedRange.min &&
                                       outputMetrics.wordCount <= expectedRange.max;

                    if (!withinRange) {
                        if (outputMetrics.wordCount < expectedRange.min) {
                            warnings.push({
                                type: 'output_too_brief',
                                wordCount: outputMetrics.wordCount,
                                expectedMin: expectedRange.min,
                                expectedMax: expectedRange.max,
                                message: `Output too brief (${outputMetrics.wordCount} words) for ${dataAnalysis.richness} data. Expected ${expectedRange.min}-${expectedRange.max} words.`
                            });
                        } else {
                            if (dataAnalysis.richness === 'sparse') {
                                // Sparse data + verbose output = padding (ERROR)
                                errors.push({
                                    type: 'output_padding',
                                    wordCount: outputMetrics.wordCount,
                                    expectedMax: expectedRange.max,
                                    dataRichness: dataAnalysis.richness,
                                    message: `Output too verbose (${outputMetrics.wordCount} words) for sparse data (${dataAnalysis.totalFacts} facts). Expected ‚â§${expectedRange.max} words. Possible padding.`,
                                    severity: 'HIGH'
                                });
                            } else {
                                warnings.push({
                                    type: 'output_too_verbose',
                                    wordCount: outputMetrics.wordCount,
                                    expectedMax: expectedRange.max,
                                    message: `Output verbose (${outputMetrics.wordCount} words). Expected ‚â§${expectedRange.max} words.`
                                });
                            }
                        }
                    }

                    // Check information density
                    const densityCheck = this.checkInformationDensity(
                        outputMetrics,
                        dataAnalysis,
                        outputType
                    );

                    if (!densityCheck.adequate) {
                        if (densityCheck.density < densityCheck.expectedMin) {
                            errors.push({
                                type: 'low_information_density',
                                density: densityCheck.density.toFixed(2),
                                expectedMin: densityCheck.expectedMin,
                                message: `Low information density (${densityCheck.density.toFixed(2)} facts/100 words). Expected ‚â•${densityCheck.expectedMin}. Possible padding.`,
                                severity: 'MEDIUM'
                            });
                        }
                    }

                    // Check for repetition
                    const repetitionCheck = this.checkRepetition(generatedOutput);
                    if (repetitionCheck.hasRepetition) {
                        warnings.push({
                            type: 'content_repetition',
                            repetitionScore: repetitionCheck.score,
                            examples: repetitionCheck.examples.slice(0, 3),
                            message: `Content repetition detected (score: ${repetitionCheck.score.toFixed(2)}). May indicate padding.`
                        });
                    }

                    // Check section balance (for narratives)
                    if (outputType === 'narrative') {
                        const balanceCheck = this.checkSectionBalance(generatedOutput, dataAnalysis);
                        balanceCheck.imbalances.forEach(imbalance => {
                            warnings.push({
                                type: 'section_imbalance',
                                ...imbalance
                            });
                        });
                    }

                    // Calculate proportionality score
                    const proportionalityScore = this.calculateProportionalityScore(
                        outputMetrics,
                        dataAnalysis,
                        expectedRange,
                        densityCheck,
                        repetitionCheck
                    );

                    console.log(`   [Proportionality] Score: ${proportionalityScore}/100`);
                    console.log(`   [Proportionality] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastValidation = {
                        passed: errors.length === 0,
                        errors: errors,
                        warnings: warnings,
                        proportionalityScore: proportionalityScore,
                        dataAnalysis: dataAnalysis,
                        outputMetrics: outputMetrics,
                        expectedRange: expectedRange,
                        densityCheck: densityCheck,
                        validatedAt: new Date().toISOString()
                    };

                    console.log(errors.length === 0 ? '‚úÖ [Proportionality] Passed' : '‚ùå [Proportionality] Issues detected');

                    return {
                        success: true,
                        validation: this.lastValidation,
                        metadata: {
                            outputType: outputType,
                            wordCount: outputMetrics.wordCount,
                            dataRichness: dataAnalysis.richness,
                            proportionalityScore: proportionalityScore
                        }
                    };

                } catch (error) {
                    console.error('‚ùå [Proportionality] Validation error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        metadata: null
                    };
                }
            }

            /**
             * Analyze data richness from extraction
             */
            analyzeDataRichness(data) {
                const analysis = {
                    totalFacts: 0,
                    sectionsPopulated: [],
                    sectionFactCounts: {},
                    richness: 'sparse',
                    criticalFactsPresent: 0
                };

                // Count facts in each section
                const topLevelSections = ['demographics', 'symptoms', 'examination', 'imaging',
                                           'pathology', 'procedures', 'medications', 'outcomes', 'timeline'];

                topLevelSections.forEach(section => {
                    if (data[section]) {
                        const factCount = this.countFacts(data[section]);
                        if (factCount > 0) {
                            analysis.sectionsPopulated.push(section);
                            analysis.sectionFactCounts[section] = factCount;
                            analysis.totalFacts += factCount;
                        }
                    }
                });

                // Check critical facts
                const criticalFields = [
                    'demographics.age',
                    'pathology.primaryDiagnosis.name'
                ];

                criticalFields.forEach(field => {
                    if (this.hasValue(data, field)) {
                        analysis.criticalFactsPresent++;
                    }
                });

                // Classify richness
                if (analysis.totalFacts < 10) {
                    analysis.richness = 'sparse';
                } else if (analysis.totalFacts < 25) {
                    analysis.richness = 'moderate';
                } else if (analysis.totalFacts < 50) {
                    analysis.richness = 'rich';
                } else {
                    analysis.richness = 'very_rich';
                }

                return analysis;
            }

            /**
             * Count facts in section
             */
            countFacts(section, count = 0) {
                if (!section || typeof section !== 'object') {
                    return count;
                }

                for (const value of Object.values(section)) {
                    if (value && typeof value === 'object') {
                        if (value.hasOwnProperty('value') && value.hasOwnProperty('sourceQuote')) {
                            if (value.value !== null && value.value !== undefined && value.value !== '') {
                                count++;
                            }
                        } else {
                            count = this.countFacts(value, count);
                        }
                    }
                }

                return count;
            }

            /**
             * Check if field has value
             */
            hasValue(data, path) {
                const parts = path.split('.');
                let current = data;

                for (const part of parts) {
                    if (!current || typeof current !== 'object') {
                        return false;
                    }
                    current = current[part];
                }

                if (current && typeof current === 'object' && current.value) {
                    return current.value !== null && current.value !== undefined && current.value !== '';
                }

                return false;
            }

            /**
             * Calculate output metrics
             */
            calculateOutputMetrics(output) {
                const words = output.split(/\s+/).filter(w => w.length > 0);
                const sentences = output.split(/[.!?]+/).filter(s => s.trim().length > 0);

                return {
                    wordCount: words.length,
                    sentenceCount: sentences.length,
                    averageSentenceLength: sentences.length > 0 ? words.length / sentences.length : 0,
                    characterCount: output.length
                };
            }

            /**
             * Get expected word range
             */
            getExpectedRange(outputType, dataAnalysis) {
                const ranges = {
                    ultrathink: {
                        sparse: { min: 25, max: 40 },
                        moderate: { min: 35, max: 50 },
                        rich: { min: 40, max: 50 },
                        very_rich: { min: 45, max: 50 }
                    },
                    doap: {
                        sparse: { min: 50, max: 100 },
                        moderate: { min: 80, max: 150 },
                        rich: { min: 120, max: 180 },
                        very_rich: { min: 150, max: 200 }
                    },
                    narrative: {
                        sparse: { min: 100, max: 300 },
                        moderate: { min: 400, max: 800 },
                        rich: { min: 1000, max: 2000 },
                        very_rich: { min: 1500, max: 3000 }
                    }
                };

                const typeRanges = ranges[outputType] || ranges.narrative;
                return typeRanges[dataAnalysis.richness] || typeRanges.moderate;
            }

            /**
             * Check information density
             */
            checkInformationDensity(outputMetrics, dataAnalysis, outputType) {
                const actualDensity = outputMetrics.wordCount > 0
                    ? (dataAnalysis.totalFacts / outputMetrics.wordCount) * 100
                    : 0;

                const expectedMinDensity = {
                    ultrathink: 8,   // ~8 facts per 100 words
                    doap: 5,         // ~5 facts per 100 words
                    narrative: 2     // ~2 facts per 100 words
                };

                const minDensity = expectedMinDensity[outputType] || 2;

                return {
                    density: actualDensity,
                    expectedMin: minDensity,
                    adequate: actualDensity >= minDensity
                };
            }

            /**
             * Check for content repetition
             */
            checkRepetition(output) {
                const sentences = output.split(/[.!?]+/).map(s => s.trim().toLowerCase()).filter(s => s.length > 10);

                if (sentences.length < 2) {
                    return { hasRepetition: false, score: 0, examples: [] };
                }

                let repetitionCount = 0;
                const repetitions = [];

                // Check for similar sentences (>70% word overlap)
                for (let i = 0; i < sentences.length; i++) {
                    for (let j = i + 1; j < sentences.length; j++) {
                        const similarity = this.calculateSentenceSimilarity(sentences[i], sentences[j]);
                        if (similarity > 0.7) {
                            repetitionCount++;
                            repetitions.push({
                                sentence1: sentences[i].substring(0, 100),
                                sentence2: sentences[j].substring(0, 100),
                                similarity: similarity.toFixed(2)
                            });
                        }
                    }
                }

                const repetitionScore = sentences.length > 0 ? repetitionCount / sentences.length : 0;

                return {
                    hasRepetition: repetitionScore > 0.1,
                    score: repetitionScore,
                    examples: repetitions
                };
            }

            /**
             * Calculate sentence similarity (Jaccard coefficient)
             */
            calculateSentenceSimilarity(sent1, sent2) {
                const words1 = new Set(sent1.split(/\s+/));
                const words2 = new Set(sent2.split(/\s+/));

                const intersection = new Set([...words1].filter(w => words2.has(w)));
                const union = new Set([...words1, ...words2]);

                return union.size > 0 ? intersection.size / union.size : 0;
            }

            /**
             * Check section balance
             */
            checkSectionBalance(output, dataAnalysis) {
                const imbalances = [];
                const outputLower = output.toLowerCase();

                dataAnalysis.sectionsPopulated.forEach(section => {
                    const factCount = dataAnalysis.sectionFactCounts[section];
                    const sectionKeywords = this.getSectionKeywords(section);
                    const mentioned = sectionKeywords.some(keyword => outputLower.includes(keyword));

                    if (!mentioned && factCount > 2) {
                        imbalances.push({
                            section: section,
                            factCount: factCount,
                            message: `Section "${section}" has ${factCount} facts but is not covered in narrative`
                        });
                    }
                });

                return { imbalances };
            }

            /**
             * Get section keywords
             */
            getSectionKeywords(section) {
                const keywords = {
                    demographics: ['age', 'patient', 'year old'],
                    symptoms: ['presents', 'symptoms', 'complains'],
                    examination: ['exam', 'examination', 'neurological'],
                    imaging: ['imaging', 'mri', 'ct', 'scan'],
                    pathology: ['diagnosis', 'pathology'],
                    procedures: ['surgery', 'procedure', 'operation'],
                    medications: ['medication', 'drug'],
                    outcomes: ['outcome', 'discharge', 'functional'],
                    timeline: ['admission', 'discharge', 'hospital']
                };

                return keywords[section] || [section];
            }

            /**
             * Calculate proportionality score
             */
            calculateProportionalityScore(outputMetrics, dataAnalysis, expectedRange, densityCheck, repetitionCheck) {
                let score = 100;

                // Factor 1: Length appropriateness (40 points)
                const withinRange = outputMetrics.wordCount >= expectedRange.min &&
                                   outputMetrics.wordCount <= expectedRange.max;

                if (withinRange) {
                    score += 0;
                } else if (outputMetrics.wordCount < expectedRange.min) {
                    const shortfall = (expectedRange.min - outputMetrics.wordCount) / expectedRange.min;
                    score -= Math.min(20, shortfall * 40);
                } else {
                    const excess = (outputMetrics.wordCount - expectedRange.max) / expectedRange.max;
                    score -= Math.min(40, excess * 60);
                }

                // Factor 2: Information density (30 points)
                if (densityCheck.adequate) {
                    score += 0;
                } else {
                    const densityShortfall = (densityCheck.expectedMin - densityCheck.density) / densityCheck.expectedMin;
                    score -= Math.min(30, densityShortfall * 30);
                }

                // Factor 3: Repetition (20 points)
                if (repetitionCheck.hasRepetition) {
                    score -= Math.min(20, repetitionCheck.score * 100);
                }

                return Math.max(0, Math.min(100, Math.round(score)));
            }

            /**
             * Get last validation result
             */
            getLastValidation() {
                return this.lastValidation;
            }

            /**
             * Get data richness analysis
             */
            getDataAnalysis() {
                if (!this.lastValidation) {
                    return null;
                }
                return this.lastValidation.dataAnalysis;
            }
        }

        console.log('‚úÖ ProportionalityValidator loaded');

        // ==================================================================================
        // SECTION 13: CONFIDENCE CALIBRATOR
        // ==================================================================================
        // Re-calibrates AI-reported confidence scores based on validation results
        // CRITICAL: Ensures confidence scores accurately reflect data quality
        //
        // Key Features:
        // - Grounding-based calibration (quote quality adjustments)
        // - Fabrication-based calibration (reduces confidence for related fields)
        // - Consistency-based calibration (penalizes inconsistent data)
        // - Completeness-based calibration (overall reduction for low completeness)
        // - Inference constraint validation (inferred fields must be <0.8)
        // - Over-confidence detection (flags high confidence despite validation issues)
        //
        // Ported from: /Users/ramihatoum/Downloads/neuroscribe-v8/src/validation/confidence-calibrator.js
        // ==================================================================================

        /**
         * Confidence Calibrator
         * Adjusts extraction confidence scores based on validation findings
         */
        class ConfidenceCalibrator {
            constructor(apiClient) {
                this.apiClient = apiClient;
                this.lastCalibration = null;
            }

            /**
             * Calibrate confidence scores
             * @param {object} extractedData - Extraction with confidence scores
             * @param {object} validationResults - Results from validators
             * @param {object} options - Calibration options
             * @returns {Promise<object>} - Calibration result with adjusted confidences
             */
            async calibrate(extractedData, validationResults, options = {}) {
                if (!extractedData || !validationResults) {
                    throw new Error('Extracted data and validation results are required');
                }

                console.log('üîç [Confidence] Starting confidence calibration...');

                try {
                    const warnings = [];
                    const errors = [];
                    const adjustments = [];

                    // Create calibrated copy of extraction data
                    const calibratedData = JSON.parse(JSON.stringify(extractedData));

                    // 1. Apply grounding-based adjustments
                    if (validationResults.grounding) {
                        console.log('   [Confidence] Applying grounding-based calibration...');
                        const groundingAdjustments = this.applyGroundingCalibration(
                            calibratedData,
                            validationResults.grounding
                        );
                        adjustments.push(...groundingAdjustments);
                    }

                    // 2. Apply fabrication-based adjustments
                    if (validationResults.fabrication) {
                        console.log('   [Confidence] Applying fabrication-based calibration...');
                        const fabricationAdjustments = this.applyFabricationCalibration(
                            calibratedData,
                            validationResults.fabrication
                        );
                        adjustments.push(...fabricationAdjustments);
                    }

                    // 3. Apply consistency-based adjustments
                    if (validationResults.consistency) {
                        console.log('   [Confidence] Applying consistency-based calibration...');
                        const consistencyAdjustments = this.applyConsistencyCalibration(
                            calibratedData,
                            validationResults.consistency
                        );
                        adjustments.push(...consistencyAdjustments);
                    }

                    // 4. Apply completeness-based adjustments
                    if (validationResults.completeness) {
                        console.log('   [Confidence] Applying completeness-based calibration...');
                        const completenessAdjustments = this.applyCompletenessCalibration(
                            calibratedData,
                            validationResults.completeness
                        );
                        adjustments.push(...completenessAdjustments);
                    }

                    // 5. Validate inference constraints (inferred fields must have confidence <0.8)
                    console.log('   [Confidence] Validating inference constraints...');
                    const inferenceViolations = this.validateInferenceConstraints(calibratedData);
                    inferenceViolations.forEach(violation => {
                        errors.push({
                            type: 'inference_constraint_violation',
                            ...violation,
                            severity: 'HIGH'
                        });
                    });

                    // 6. Check for over-confident extractions
                    console.log('   [Confidence] Checking for over-confidence...');
                    const overconfidentFields = this.detectOverconfidence(calibratedData, validationResults);
                    overconfidentFields.forEach(field => {
                        warnings.push({
                            type: 'overconfident_extraction',
                            ...field
                        });
                    });

                    // Calculate calibration metrics
                    const metrics = this.calculateCalibrationMetrics(
                        extractedData,
                        calibratedData,
                        adjustments
                    );

                    console.log(`   [Confidence] Total adjustments: ${adjustments.length}`);
                    console.log(`   [Confidence] Average confidence change: ${metrics.averageChange.toFixed(3)}`);
                    console.log(`   [Confidence] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastCalibration = {
                        valid: errors.length === 0,
                        errors: errors,
                        warnings: warnings,
                        calibratedData: calibratedData,
                        adjustments: adjustments,
                        metrics: metrics,
                        calibratedAt: new Date().toISOString()
                    };

                    console.log(errors.length === 0 ? '‚úÖ [Confidence] Calibration complete' : '‚ùå [Confidence] Issues detected');

                    return {
                        success: true,
                        validation: this.lastCalibration,
                        calibratedData: calibratedData,
                        metadata: {
                            adjustmentCount: adjustments.length,
                            averageChange: metrics.averageChange,
                            fieldsAdjusted: metrics.fieldsAdjusted
                        }
                    };

                } catch (error) {
                    console.error('‚ùå [Confidence] Calibration error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        calibratedData: null,
                        metadata: null
                    };
                }
            }

            /**
             * Apply grounding-based confidence adjustments
             */
            applyGroundingCalibration(data, groundingValidation) {
                const adjustments = [];

                if (!groundingValidation.fieldValidations) {
                    return adjustments;
                }

                // Traverse data and adjust based on grounding quality
                this.traverseAndAdjust(data, '', (path, field, parent, key) => {
                    // Find corresponding grounding validation
                    const validation = groundingValidation.fieldValidations.find(v => v.path === path);

                    if (!validation) {
                        return;
                    }

                    const originalConfidence = field.confidence;
                    let adjustedConfidence = originalConfidence;
                    const reasons = [];

                    // Adjust based on quote quality
                    switch (validation.quoteQuality) {
                        case 'EXCELLENT':
                            // No adjustment needed
                            break;

                        case 'GOOD':
                            // Minor adjustment down
                            adjustedConfidence = Math.min(adjustedConfidence, 0.95);
                            reasons.push('Good grounding (capped at 0.95)');
                            break;

                        case 'ACCEPTABLE':
                            // Moderate adjustment down
                            adjustedConfidence = Math.min(adjustedConfidence, 0.85);
                            reasons.push('Acceptable grounding (capped at 0.85)');
                            break;

                        case 'POOR':
                            // Significant adjustment down
                            adjustedConfidence = Math.min(adjustedConfidence, 0.60);
                            reasons.push('Poor grounding quality (capped at 0.60)');
                            break;

                        case 'VERY_POOR':
                            // Severe adjustment
                            adjustedConfidence = Math.min(adjustedConfidence, 0.40);
                            reasons.push('Very poor grounding (capped at 0.40)');
                            break;

                        case 'NONE':
                            // No grounding = very low confidence
                            adjustedConfidence = 0.20;
                            reasons.push('No grounding (set to 0.20)');
                            break;
                    }

                    // Additional adjustment if quote doesn't exist in text
                    if (!validation.quoteExists && validation.sourceQuote) {
                        adjustedConfidence = Math.min(adjustedConfidence, 0.30);
                        reasons.push('Source quote not found in text');
                    }

                    // Apply adjustment
                    if (Math.abs(adjustedConfidence - originalConfidence) > 0.01) {
                        field.confidence = parseFloat(adjustedConfidence.toFixed(3));

                        adjustments.push({
                            path: path,
                            originalConfidence: originalConfidence,
                            adjustedConfidence: adjustedConfidence,
                            change: adjustedConfidence - originalConfidence,
                            reasons: reasons,
                            source: 'grounding'
                        });
                    }
                });

                return adjustments;
            }

            /**
             * Apply fabrication-based confidence adjustments
             */
            applyFabricationCalibration(data, fabricationValidation) {
                const adjustments = [];

                if (!fabricationValidation.fabrications || fabricationValidation.fabrications.length === 0) {
                    return adjustments;
                }

                // For each fabrication, find and adjust related fields
                fabricationValidation.fabrications.forEach(fab => {
                    // Extract key terms from fabricated statement
                    const keyTerms = this.extractKeyTerms(fab.statement);

                    // Find fields that might be related to this fabrication
                    this.traverseAndAdjust(data, '', (path, field) => {
                        const fieldText = `${field.value} ${field.sourceQuote}`.toLowerCase();

                        // Check if this field is related to the fabrication
                        const related = keyTerms.some(term => fieldText.includes(term.toLowerCase()));

                        if (related) {
                            const originalConfidence = field.confidence;

                            // Reduce confidence based on fabrication confidence
                            const reduction = fab.confidence * 0.5; // Reduce by up to 50%
                            const adjustedConfidence = Math.max(0.10, originalConfidence * (1 - reduction));

                            if (Math.abs(adjustedConfidence - originalConfidence) > 0.01) {
                                field.confidence = parseFloat(adjustedConfidence.toFixed(3));

                                adjustments.push({
                                    path: path,
                                    originalConfidence: originalConfidence,
                                    adjustedConfidence: adjustedConfidence,
                                    change: adjustedConfidence - originalConfidence,
                                    reasons: [`Related to fabricated content: "${fab.statement.substring(0, 50)}..."`],
                                    source: 'fabrication'
                                });
                            }
                        }
                    });
                });

                return adjustments;
            }

            /**
             * Apply consistency-based confidence adjustments
             */
            applyConsistencyCalibration(data, consistencyValidation) {
                const adjustments = [];

                if (!consistencyValidation.errors || consistencyValidation.errors.length === 0) {
                    return adjustments;
                }

                // For each consistency error, reduce confidence of involved fields
                consistencyValidation.errors.forEach(error => {
                    if (error.field1) {
                        this.adjustFieldConfidence(data, error.field1, 0.5, `Consistency issue: ${error.message}`, adjustments);
                    }
                    if (error.field2) {
                        this.adjustFieldConfidence(data, error.field2, 0.5, `Consistency issue: ${error.message}`, adjustments);
                    }
                    if (error.field && !error.field1) {
                        this.adjustFieldConfidence(data, error.field, 0.5, `Consistency issue: ${error.message}`, adjustments);
                    }
                });

                return adjustments;
            }

            /**
             * Apply completeness-based confidence adjustments
             */
            applyCompletenessCalibration(data, completenessValidation) {
                const adjustments = [];

                // If overall completeness is low, reduce all confidences slightly
                if (completenessValidation.scores && completenessValidation.scores.overall < 70) {
                    const reductionFactor = 0.9; // 10% reduction

                    this.traverseAndAdjust(data, '', (path, field) => {
                        const originalConfidence = field.confidence;
                        const adjustedConfidence = originalConfidence * reductionFactor;

                        if (Math.abs(adjustedConfidence - originalConfidence) > 0.01) {
                            field.confidence = parseFloat(adjustedConfidence.toFixed(3));

                            adjustments.push({
                                path: path,
                                originalConfidence: originalConfidence,
                                adjustedConfidence: adjustedConfidence,
                                change: adjustedConfidence - originalConfidence,
                                reasons: [`Low overall completeness (${completenessValidation.scores.overall}%)`],
                                source: 'completeness'
                            });
                        }
                    });
                }

                return adjustments;
            }

            /**
             * Adjust specific field confidence by path
             */
            adjustFieldConfidence(data, fieldPath, reductionFactor, reason, adjustments) {
                this.traverseAndAdjust(data, '', (path, field) => {
                    if (path === fieldPath || path.includes(fieldPath)) {
                        const originalConfidence = field.confidence;
                        const adjustedConfidence = originalConfidence * reductionFactor;

                        if (Math.abs(adjustedConfidence - originalConfidence) > 0.01) {
                            field.confidence = parseFloat(adjustedConfidence.toFixed(3));

                            adjustments.push({
                                path: path,
                                originalConfidence: originalConfidence,
                                adjustedConfidence: adjustedConfidence,
                                change: adjustedConfidence - originalConfidence,
                                reasons: [reason],
                                source: 'consistency'
                            });
                        }
                    }
                });
            }

            /**
             * Validate inference constraints (inferred fields < 0.8 confidence)
             */
            validateInferenceConstraints(data) {
                const violations = [];

                this.traverseAndAdjust(data, '', (path, field) => {
                    // Check if field is inferred
                    if (field.deductionMetadata && field.deductionMetadata.deduced) {
                        if (field.confidence >= 0.8) {
                            violations.push({
                                field: path,
                                confidence: field.confidence,
                                deductionMethod: field.deductionMetadata.deducedFrom,
                                message: `Inferred field has confidence ‚â•0.8 (${field.confidence}), must be <0.8`
                            });

                            // Auto-correct
                            field.confidence = 0.79;
                        }
                    }
                });

                return violations;
            }

            /**
             * Detect over-confident extractions
             */
            detectOverconfidence(data, validationResults) {
                const overconfident = [];

                // If validation failed but field has high confidence, flag it
                const hasIssues = (validationResults.grounding && !validationResults.grounding.valid) ||
                                 (validationResults.consistency && !validationResults.consistency.valid) ||
                                 (validationResults.completeness && !validationResults.completeness.valid);

                if (hasIssues) {
                    this.traverseAndAdjust(data, '', (path, field) => {
                        if (field.confidence >= 0.95) {
                            overconfident.push({
                                field: path,
                                confidence: field.confidence,
                                message: `Very high confidence (${field.confidence}) despite validation issues`
                            });
                        }
                    });
                }

                return overconfident;
            }

            /**
             * Extract key terms from statement
             */
            extractKeyTerms(statement) {
                return statement
                    .toLowerCase()
                    .split(/\s+/)
                    .filter(word => word.length > 4 && !/^(the|and|with|for|from|that|this)$/.test(word))
                    .slice(0, 5); // Top 5 key terms
            }

            /**
             * Traverse data and apply adjustment callback
             */
            traverseAndAdjust(data, path = '', callback) {
                if (!data || typeof data !== 'object') {
                    return;
                }

                for (const [key, value] of Object.entries(data)) {
                    if (value === null || value === undefined) {
                        continue;
                    }

                    const currentPath = path ? `${path}.${key}` : key;

                    // Check if this is a grounded field
                    if (typeof value === 'object' &&
                        value.hasOwnProperty('value') &&
                        value.hasOwnProperty('sourceQuote') &&
                        value.hasOwnProperty('confidence')) {

                        callback(currentPath, value, data, key);

                    } else if (typeof value === 'object' && !Array.isArray(value)) {
                        // Recurse into nested objects
                        this.traverseAndAdjust(value, currentPath, callback);

                    } else if (Array.isArray(value)) {
                        // Recurse into arrays
                        value.forEach((item, index) => {
                            this.traverseAndAdjust(item, `${currentPath}[${index}]`, callback);
                        });
                    }
                }
            }

            /**
             * Calculate calibration metrics
             */
            calculateCalibrationMetrics(originalData, calibratedData, adjustments) {
                const metrics = {
                    fieldsAdjusted: adjustments.length,
                    averageChange: 0,
                    totalChangeSum: 0,
                    maxIncrease: 0,
                    maxDecrease: 0,
                    adjustmentsBySource: {}
                };

                if (adjustments.length === 0) {
                    return metrics;
                }

                // Calculate average change
                metrics.totalChangeSum = adjustments.reduce((sum, adj) => sum + adj.change, 0);
                metrics.averageChange = metrics.totalChangeSum / adjustments.length;

                // Find max changes
                adjustments.forEach(adj => {
                    if (adj.change > metrics.maxIncrease) {
                        metrics.maxIncrease = adj.change;
                    }
                    if (adj.change < metrics.maxDecrease) {
                        metrics.maxDecrease = adj.change;
                    }

                    // Count by source
                    metrics.adjustmentsBySource[adj.source] = (metrics.adjustmentsBySource[adj.source] || 0) + 1;
                });

                return metrics;
            }

            /**
             * Get last calibration result
             */
            getLastCalibration() {
                return this.lastCalibration;
            }

            /**
             * Get calibrated data
             */
            getCalibratedData() {
                if (!this.lastCalibration) {
                    return null;
                }
                return this.lastCalibration.calibratedData;
            }

            /**
             * Get confidence adjustments
             */
            getAdjustments() {
                if (!this.lastCalibration) {
                    return [];
                }
                return this.lastCalibration.adjustments;
            }
        }

        console.log('‚úÖ ConfidenceCalibrator loaded');

        // ==================================================================================
        // üéâ ALL 6 VALIDATION LAYERS COMPLETE!
        // ==================================================================================
        // ‚úÖ 1. GroundingValidator - Source quote verification
        // ‚úÖ 2. FabricationDetector - AI hallucination detection
        // ‚úÖ 3. CompletenessChecker - Bidirectional extraction validation
        // ‚úÖ 4. ConsistencyValidator - Medical logic & anatomical consistency
        // ‚úÖ 5. ProportionalityValidator - Output sizing & padding detection
        // ‚úÖ 6. ConfidenceCalibrator - Score adjustment based on validation
        //
        // Total validation code: ~2,550 lines
        // Next: ValidationPipeline Orchestrator to coordinate all 6 layers
        // ==================================================================================

        console.log('‚úÖ All 6 validation classes loaded successfully');

        // ==================================================================================
        // SECTION 14: VALIDATION PIPELINE ORCHESTRATOR
        // ==================================================================================
        // Unified validator that orchestrates all 6 validation components
        // CRITICAL: Main validation interface for extraction and generation
        //
        // Validation Workflows:
        // 1. validateExtraction() - Pre-generation validation
        //    ‚Üí Grounding ‚Üí Completeness ‚Üí Consistency ‚Üí Calibration
        // 2. validateGeneration() - Post-generation validation
        //    ‚Üí Fabrication ‚Üí Proportionality
        // 3. validateComplete() - Full pipeline (extraction + all outputs)
        //    ‚Üí All validators + system quality score
        //
        // Ported from: /Users/ramihatoum/Downloads/neuroscribe-v8/src/validation/validator.js
        // ==================================================================================

        /**
         * Unified Validator
         * Comprehensive validation pipeline for extraction and generation
         */
        class ValidationPipeline {
            constructor(apiClient) {
                this.apiClient = apiClient;

                // Initialize all validators (instantiate directly, not via create functions)
                this.groundingValidator = new GroundingValidator(''); // Will receive source text per validation
                this.fabricationDetector = new FabricationDetector(apiClient);
                this.completenessChecker = new CompletenessChecker(apiClient);
                this.consistencyValidator = new ConsistencyValidator(apiClient);
                this.proportionalityValidator = new ProportionalityValidator(apiClient);
                this.confidenceCalibrator = new ConfidenceCalibrator(apiClient);

                this.lastValidation = null;
            }

            /**
             * Validate extraction (pre-generation)
             * @param {object} extractedData - Extraction result
             * @param {string} originalText - Original clinical text
             * @param {object} options - Validation options
             * @returns {Promise<object>} - Comprehensive validation result
             */
            async validateExtraction(extractedData, originalText, options = {}) {
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('PHASE 4: EXTRACTION VALIDATION PIPELINE');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                try {
                    const validationResults = {
                        grounding: null,
                        completeness: null,
                        consistency: null,
                        calibration: null
                    };

                    // Step 1: Grounding Validation
                    console.log('üìã Step 1: Grounding Validation');
                    console.log('‚îÄ'.repeat(60));

                    // Create grounding validator with source text
                    const groundingValidator = new GroundingValidator(originalText);
                    validationResults.grounding = await groundingValidator.validate(extractedData);

                    if (validationResults.grounding.success) {
                        console.log(`‚úÖ Grounding: ${validationResults.grounding.validation.scores.overall}/100`);
                    } else {
                        console.log(`‚ùå Grounding validation failed: ${validationResults.grounding.error}`);
                    }

                    // Step 2: Completeness Check
                    console.log('\nüìã Step 2: Completeness Check');
                    console.log('‚îÄ'.repeat(60));
                    validationResults.completeness = await this.completenessChecker.check(
                        extractedData,
                        originalText,
                        options
                    );

                    if (validationResults.completeness.success) {
                        console.log(`‚úÖ Completeness: ${validationResults.completeness.validation.scores.overall}/100`);
                    } else {
                        console.log(`‚ùå Completeness check failed: ${validationResults.completeness.error}`);
                    }

                    // Step 3: Consistency Validation
                    console.log('\nüìã Step 3: Consistency Validation');
                    console.log('‚îÄ'.repeat(60));
                    validationResults.consistency = await this.consistencyValidator.validate(
                        extractedData,
                        originalText,
                        options
                    );

                    if (validationResults.consistency.success) {
                        console.log(`‚úÖ Consistency: ${validationResults.consistency.validation.consistencyScore}/100`);
                    } else {
                        console.log(`‚ùå Consistency validation failed: ${validationResults.consistency.error}`);
                    }

                    // Step 4: Confidence Calibration
                    console.log('\nüìã Step 4: Confidence Calibration');
                    console.log('‚îÄ'.repeat(60));
                    validationResults.calibration = await this.confidenceCalibrator.calibrate(
                        extractedData,
                        {
                            grounding: validationResults.grounding?.validation,
                            completeness: validationResults.completeness?.validation,
                            consistency: validationResults.consistency?.validation
                        },
                        options
                    );

                    if (validationResults.calibration.success) {
                        console.log(`‚úÖ Calibration: ${validationResults.calibration.metadata.adjustmentCount} adjustments`);
                    } else {
                        console.log(`‚ùå Confidence calibration failed: ${validationResults.calibration.error}`);
                    }

                    // Aggregate results
                    const aggregated = this.aggregateExtractionValidation(validationResults);

                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log('EXTRACTION VALIDATION SUMMARY');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log(`Overall Quality Score: ${aggregated.overallScore}/100`);
                    console.log(`Status: ${aggregated.status}`);
                    console.log(`Critical Issues: ${aggregated.summary.criticalIssues}`);
                    console.log(`Warnings: ${aggregated.summary.warnings}`);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                    return {
                        success: true,
                        validation: aggregated,
                        calibratedData: validationResults.calibration?.calibratedData || extractedData
                    };

                } catch (error) {
                    console.error('‚ùå Extraction validation pipeline error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        calibratedData: extractedData
                    };
                }
            }

            /**
             * Validate generation (post-generation)
             * @param {string} generatedText - Generated output
             * @param {object} extractedData - Source extraction
             * @param {string} originalText - Original clinical text
             * @param {string} outputType - Type of output (ultrathink, doap, narrative)
             * @param {object} options - Validation options
             * @returns {Promise<object>} - Comprehensive validation result
             */
            async validateGeneration(generatedText, extractedData, originalText, outputType, options = {}) {
                console.log(`\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                console.log(`PHASE 4: ${outputType.toUpperCase()} VALIDATION PIPELINE`);
                console.log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);

                try {
                    const validationResults = {
                        fabrication: null,
                        proportionality: null
                    };

                    // Step 1: Fabrication Detection
                    console.log('üìã Step 1: Fabrication Detection');
                    console.log('‚îÄ'.repeat(60));
                    validationResults.fabrication = await this.fabricationDetector.detect(
                        generatedText,
                        extractedData,
                        originalText,
                        options
                    );

                    if (validationResults.fabrication.success) {
                        console.log(`‚úÖ Fabrication: ${validationResults.fabrication.validation.fabricationScore}/100`);
                    } else {
                        console.log(`‚ùå Fabrication detection failed: ${validationResults.fabrication.error}`);
                    }

                    // Step 2: Proportionality Validation
                    console.log('\nüìã Step 2: Proportionality Validation');
                    console.log('‚îÄ'.repeat(60));
                    validationResults.proportionality = await this.proportionalityValidator.validate(
                        generatedText,
                        extractedData,
                        outputType,
                        options
                    );

                    if (validationResults.proportionality.success) {
                        console.log(`‚úÖ Proportionality: ${validationResults.proportionality.validation.proportionalityScore}/100`);
                    } else {
                        console.log(`‚ùå Proportionality validation failed: ${validationResults.proportionality.error}`);
                    }

                    // Aggregate results
                    const aggregated = this.aggregateGenerationValidation(validationResults, outputType);

                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log(`${outputType.toUpperCase()} VALIDATION SUMMARY`);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log(`Overall Quality Score: ${aggregated.overallScore}/100`);
                    console.log(`Status: ${aggregated.status}`);
                    console.log(`Critical Issues: ${aggregated.summary.criticalIssues}`);
                    console.log(`Warnings: ${aggregated.summary.warnings}`);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                    return {
                        success: true,
                        validation: aggregated
                    };

                } catch (error) {
                    console.error(`‚ùå ${outputType} validation pipeline error:`, error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null
                    };
                }
            }

            /**
             * Complete validation pipeline (extraction + all outputs)
             * @param {object} extractedData - Extraction result
             * @param {string} originalText - Original clinical text
             * @param {object} outputs - Generated outputs {ultrathink, doap, narrative}
             * @param {object} options - Validation options
             * @returns {Promise<object>} - Complete validation result
             */
            async validateComplete(extractedData, originalText, outputs = {}, options = {}) {
                console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                console.log('‚ïë        PHASE 4: COMPLETE VALIDATION PIPELINE         ‚ïë');
                console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

                try {
                    // 1. Validate extraction
                    const extractionValidation = await this.validateExtraction(
                        extractedData,
                        originalText,
                        options
                    );

                    // Use calibrated data for generation validation
                    const calibratedData = extractionValidation.calibratedData || extractedData;

                    // 2. Validate each output type
                    const outputValidations = {};

                    if (outputs.ultrathink) {
                        outputValidations.ultrathink = await this.validateGeneration(
                            outputs.ultrathink,
                            calibratedData,
                            originalText,
                            'ultrathink',
                            options
                        );
                    }

                    if (outputs.doap) {
                        outputValidations.doap = await this.validateGeneration(
                            outputs.doap,
                            calibratedData,
                            originalText,
                            'doap',
                            options
                        );
                    }

                    if (outputs.narrative) {
                        outputValidations.narrative = await this.validateGeneration(
                            outputs.narrative,
                            calibratedData,
                            originalText,
                            'narrative',
                            options
                        );
                    }

                    // 3. Aggregate complete validation
                    const completeValidation = this.aggregateCompleteValidation(
                        extractionValidation,
                        outputValidations
                    );

                    console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                    console.log('‚ïë           COMPLETE VALIDATION SUMMARY                ‚ïë');
                    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                    console.log(`\nüìä Overall System Quality: ${completeValidation.systemQualityScore}/100`);
                    console.log(`   Status: ${completeValidation.status}`);
                    console.log(`\nüìã Validation Breakdown:`);
                    console.log(`   Extraction Quality: ${completeValidation.extractionScore}/100`);
                    if (outputValidations.ultrathink) {
                        console.log(`   ULTRATHINK Quality: ${completeValidation.outputScores.ultrathink}/100`);
                    }
                    if (outputValidations.doap) {
                        console.log(`   DOAP Quality: ${completeValidation.outputScores.doap}/100`);
                    }
                    if (outputValidations.narrative) {
                        console.log(`   Narrative Quality: ${completeValidation.outputScores.narrative}/100`);
                    }
                    console.log(`\n‚ö†Ô∏è  Total Issues:`);
                    console.log(`   Critical: ${completeValidation.totalIssues.critical}`);
                    console.log(`   Warnings: ${completeValidation.totalIssues.warnings}`);
                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                    // Store complete validation
                    this.lastValidation = completeValidation;

                    return {
                        success: true,
                        validation: completeValidation,
                        calibratedData: calibratedData
                    };

                } catch (error) {
                    console.error('‚ùå Complete validation pipeline error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        calibratedData: extractedData
                    };
                }
            }

            /**
             * Aggregate extraction validation results
             */
            aggregateExtractionValidation(results) {
                const allErrors = [];
                const allWarnings = [];

                // Collect errors and warnings
                if (results.grounding?.validation) {
                    allErrors.push(...(results.grounding.validation.errors || []));
                    allWarnings.push(...(results.grounding.validation.warnings || []));
                }

                if (results.completeness?.validation) {
                    allErrors.push(...(results.completeness.validation.errors || []));
                    allWarnings.push(...(results.completeness.validation.warnings || []));
                }

                if (results.consistency?.validation) {
                    allErrors.push(...(results.consistency.validation.errors || []));
                    allWarnings.push(...(results.consistency.validation.warnings || []));
                }

                if (results.calibration?.validation) {
                    allErrors.push(...(results.calibration.validation.errors || []));
                    allWarnings.push(...(results.calibration.validation.warnings || []));
                }

                // Calculate overall score (weighted average)
                const groundingScore = results.grounding?.validation?.scores?.overall || 0;
                const completenessScore = results.completeness?.validation?.scores?.overall || 0;
                const consistencyScore = results.consistency?.validation?.consistencyScore || 0;

                const overallScore = Math.round(
                    groundingScore * 0.35 +      // 35% grounding weight
                    completenessScore * 0.35 +   // 35% completeness weight
                    consistencyScore * 0.30      // 30% consistency weight
                );

                // Determine status
                let status = 'EXCELLENT';
                if (allErrors.length > 0) {
                    status = 'FAILED';
                } else if (overallScore < 70) {
                    status = 'POOR';
                } else if (overallScore < 85) {
                    status = 'ACCEPTABLE';
                } else if (overallScore < 95) {
                    status = 'GOOD';
                }

                return {
                    valid: allErrors.length === 0,
                    status: status,
                    overallScore: overallScore,
                    scores: {
                        grounding: groundingScore,
                        completeness: completenessScore,
                        consistency: consistencyScore
                    },
                    errors: allErrors,
                    warnings: allWarnings,
                    summary: {
                        criticalIssues: allErrors.length,
                        warnings: allWarnings.length,
                        totalIssues: allErrors.length + allWarnings.length
                    },
                    detailedResults: results
                };
            }

            /**
             * Aggregate generation validation results
             */
            aggregateGenerationValidation(results, outputType) {
                const allErrors = [];
                const allWarnings = [];

                // Collect errors and warnings
                if (results.fabrication?.validation) {
                    allErrors.push(...(results.fabrication.validation.errors || []));
                    allWarnings.push(...(results.fabrication.validation.warnings || []));
                }

                if (results.proportionality?.validation) {
                    allErrors.push(...(results.proportionality.validation.errors || []));
                    allWarnings.push(...(results.proportionality.validation.warnings || []));
                }

                // Calculate overall score (weighted average)
                const fabricationScore = results.fabrication?.validation?.fabricationScore || 0;
                const proportionalityScore = results.proportionality?.validation?.proportionalityScore || 0;

                const overallScore = Math.round(
                    fabricationScore * 0.60 +        // Fabrication is more critical (60%)
                    proportionalityScore * 0.40      // Proportionality (40%)
                );

                // Determine status
                let status = 'EXCELLENT';
                if (allErrors.length > 0) {
                    status = 'FAILED';
                } else if (overallScore < 70) {
                    status = 'POOR';
                } else if (overallScore < 85) {
                    status = 'ACCEPTABLE';
                } else if (overallScore < 95) {
                    status = 'GOOD';
                }

                return {
                    valid: allErrors.length === 0,
                    status: status,
                    overallScore: overallScore,
                    outputType: outputType,
                    scores: {
                        fabrication: fabricationScore,
                        proportionality: proportionalityScore
                    },
                    errors: allErrors,
                    warnings: allWarnings,
                    summary: {
                        criticalIssues: allErrors.length,
                        warnings: allWarnings.length,
                        totalIssues: allErrors.length + allWarnings.length
                    },
                    detailedResults: results
                };
            }

            /**
             * Aggregate complete validation results
             */
            aggregateCompleteValidation(extractionValidation, outputValidations) {
                // Calculate system quality score
                const extractionScore = extractionValidation.validation?.overallScore || 0;
                const outputScores = {};

                let totalOutputScore = 0;
                let outputCount = 0;

                Object.entries(outputValidations).forEach(([type, validation]) => {
                    if (validation?.validation?.overallScore !== undefined) {
                        outputScores[type] = validation.validation.overallScore;
                        totalOutputScore += validation.validation.overallScore;
                        outputCount++;
                    }
                });

                const avgOutputScore = outputCount > 0 ? totalOutputScore / outputCount : 0;

                // System quality = 60% extraction + 40% outputs
                const systemQualityScore = Math.round(
                    extractionScore * 0.60 +
                    avgOutputScore * 0.40
                );

                // Aggregate all issues
                const totalIssues = {
                    critical: (extractionValidation.validation?.summary?.criticalIssues || 0),
                    warnings: (extractionValidation.validation?.summary?.warnings || 0)
                };

                Object.values(outputValidations).forEach(validation => {
                    if (validation?.validation?.summary) {
                        totalIssues.critical += validation.validation.summary.criticalIssues || 0;
                        totalIssues.warnings += validation.validation.summary.warnings || 0;
                    }
                });

                // Determine overall status
                let status = 'EXCELLENT';
                if (totalIssues.critical > 0) {
                    status = 'FAILED';
                } else if (systemQualityScore < 70) {
                    status = 'POOR';
                } else if (systemQualityScore < 85) {
                    status = 'ACCEPTABLE';
                } else if (systemQualityScore < 95) {
                    status = 'GOOD';
                }

                return {
                    systemQualityScore: systemQualityScore,
                    status: status,
                    extractionScore: extractionScore,
                    outputScores: outputScores,
                    totalIssues: totalIssues,
                    extractionValidation: extractionValidation,
                    outputValidations: outputValidations,
                    timestamp: new Date().toISOString()
                };
            }

            /**
             * Get actionable feedback for regeneration
             */
            getRegenerationFeedback(validation) {
                const feedback = {
                    shouldRegenerate: false,
                    criticalIssues: [],
                    suggestions: []
                };

                if (!validation || validation.valid) {
                    return feedback;
                }

                // Determine if regeneration is needed
                if (validation.errors && validation.errors.length > 0) {
                    feedback.shouldRegenerate = true;

                    // Collect critical issues
                    validation.errors.forEach(error => {
                        feedback.criticalIssues.push({
                            type: error.type,
                            message: error.message,
                            severity: error.severity
                        });

                        // Generate suggestions
                        if (error.type === 'fabricated_content') {
                            feedback.suggestions.push('Remove unsupported statements and stay strictly within documented facts');
                        } else if (error.type === 'laterality_inconsistency') {
                            feedback.suggestions.push('Verify neuroanatomical laterality (cerebral lesions cause contralateral symptoms)');
                        } else if (error.type === 'output_padding') {
                            feedback.suggestions.push('Reduce output length to match sparse data - avoid padding or elaboration');
                        } else if (error.type === 'missing_critical_extraction') {
                            feedback.suggestions.push('Extract all critical clinical information mentioned in the notes');
                        } else if (error.type === 'score_inconsistency') {
                            feedback.suggestions.push('Verify clinical score calculations and ranges');
                        }
                    });

                    // Remove duplicate suggestions
                    feedback.suggestions = [...new Set(feedback.suggestions)];
                }

                return feedback;
            }

            /**
             * Get last validation result
             */
            getLastValidation() {
                return this.lastValidation;
            }

            /**
             * Get individual validator instances (for direct access)
             */
            getValidators() {
                return {
                    grounding: this.groundingValidator,
                    fabrication: this.fabricationDetector,
                    completeness: this.completenessChecker,
                    consistency: this.consistencyValidator,
                    proportionality: this.proportionalityValidator,
                    calibration: this.confidenceCalibrator
                };
            }
        }

        console.log('‚úÖ ValidationPipeline loaded');

        // ==================================================================================
        // üéâüéâüéâ VALIDATION ENGINE 100% COMPLETE! üéâüéâüéâ
        // ==================================================================================
        //
        // ‚úÖ ALL 6 VALIDATION LAYERS:
        //    1. GroundingValidator (375 lines) - Source quote verification
        //    2. FabricationDetector (474 lines) - AI hallucination detection
        //    3. CompletenessChecker (531 lines) - Bidirectional validation
        //    4. ConsistencyValidator (645 lines) - Medical logic validation
        //    5. ProportionalityValidator (489 lines) - Output sizing validation
        //    6. ConfidenceCalibrator (549 lines) - Score adjustment
        //
        // ‚úÖ ORCHESTRATOR:
        //    7. ValidationPipeline (592 lines) - Master coordinator
        //
        // üìä TOTAL VALIDATION CODE: ~3,655 lines
        // üèóÔ∏è  ARCHITECTURE: Browser-compatible, zero dependencies
        // ‚ö° FEATURES:
        //    - Extraction validation (4 layers)
        //    - Generation validation (2 layers)
        //    - Complete pipeline validation
        //    - Weighted scoring algorithms
        //    - Actionable regeneration feedback
        //
        // üéØ NEXT PHASE: Integrate with V7 generate() workflow
        // ==================================================================================

        console.log('üéâ VALIDATION ENGINE 100% COMPLETE!');

        // ============================================================
        // STARTUP VALIDATION
        // ============================================================
        function validateStartup() {
            console.log('üîç Running startup validation...');
            const criticalElements = [
                'settingsModal',
                'apiKeyInput',
                'apiKeyStatus',
                'status',
                'transcript',
                'generateBtn'
            ];

            let missingElements = [];
            for (const id of criticalElements) {
                const el = document.getElementById(id);
                if (!el) {
                    missingElements.push(id);
                    console.error(`‚ùå Missing critical element: #${id}`);
                } else {
                    console.log(`‚úÖ Element found: #${id}`);
                }
            }

            // Check if database loaded
            if (typeof ClinicalScalesDatabase === 'undefined') {
                console.error('‚ùå ClinicalScalesDatabase not loaded!');
                alert('Error: Clinical scales database failed to load. Please refresh the page.');
                return false;
            } else {
                console.log(`‚úÖ ClinicalScalesDatabase loaded (${Object.keys(ClinicalScalesDatabase).length} scales)`);
            }

            if (missingElements.length > 0) {
                console.warn(`‚ö†Ô∏è  ${missingElements.length} elements missing, but continuing...`);
            } else {
                console.log('‚úÖ All critical elements found');
            }

            return true;
        }

        // Pathology-Specific Knowledge Base
        const PathologyDatabase = {
            'spine-degenerative': {
                name: 'Degenerative Spine Disease',
                vocabulary: ['disc herniation', 'stenosis', 'spondylolisthesis', 'facet arthropathy',
                    'ligamentum flavum', 'foramen', 'lateral recess', 'myelopathy', 'radiculopathy',
                    'ACDF', 'TLIF', 'laminectomy', 'foraminotomy', 'corpectomy'],
                redFlags: ['cauda equina syndrome', 'progressive myelopathy', 'bowel/bladder dysfunction',
                    'saddle anesthesia', 'bilateral weakness', 'hyperreflexia', 'clonus',
                    'Hoffman sign positive', 'inverted radial reflex', 'gait instability'],
                examFindings: ['Spurling test', 'straight leg raise', 'crossed straight leg raise',
                    'femoral stretch test', 'Hoffman sign', 'Babinski', 'clonus testing',
                    'tandem gait', 'Romberg test', 'motor strength testing by myotome'],
                differentials: ['Central disc herniation', 'Foraminal stenosis', 'Central canal stenosis',
                    'Spondylolisthesis', 'Facet syndrome', 'SI joint dysfunction',
                    'Piriformis syndrome', 'Peripheral neuropathy', 'Vascular claudication'],
                workup: ['MRI spine without contrast', 'CT myelogram if MRI contraindicated',
                    'Flexion-extension X-rays for instability', 'EMG/NCS for radiculopathy',
                    'DEXA scan if considering fusion'],
                guidelines: ['NASS guidelines for lumbar disc herniation', 'AOSpine classification system',
                    'Meyerding classification for spondylolisthesis', 'Modic changes classification'],
                recommendedScales: ['mjoa', 'nurick', 'ndi', 'odi', 'vas_pain']
            },
            'spine-trauma': {
                name: 'Traumatic Spine Injury',
                vocabulary: ['burst fracture', 'compression fracture', 'chance fracture', 'odontoid fracture',
                    'Jefferson fracture', 'hangman fracture', 'TLICS score', 'SLIC score',
                    'ASIA grade', 'neurogenic shock', 'spinal shock', 'central cord syndrome'],
                redFlags: ['incomplete spinal cord injury', 'neurological deterioration', 'unstable fracture',
                    'epidural hematoma', 'expanding syrinx', 'vascular injury', 'CSF leak', 'autonomic dysreflexia'],
                examFindings: ['ASIA examination', 'rectal tone', 'bulbocavernosus reflex', 'priapism',
                    'diaphragmatic breathing', 'sensory level', 'zone of partial preservation'],
                differentials: ['Complete vs incomplete SCI', 'Central cord syndrome', 'Brown-Sequard syndrome',
                    'Anterior cord syndrome', 'Conus medullaris syndrome', 'Cauda equina syndrome'],
                workup: ['CT spine - urgent', 'MRI for ligamentous injury', 'CT angiogram for vertebral artery',
                    'Upright X-rays when stable', 'Urodynamics if neurogenic bladder'],
                guidelines: ['TLICS scoring system', 'SLIC scoring system', 'AOSpine classification',
                    'NASCIS protocols for steroids', 'ASIA impairment scale'],
                recommendedScales: ['gcs', 'odi', 'vas_pain']
            },
            'brain-tumor': {
                name: 'Brain Tumor',
                vocabulary: ['glioblastoma', 'astrocytoma', 'oligodendroglioma', 'ependymoma', 'meningioma',
                    'schwannoma', 'pituitary adenoma', 'craniopharyngioma', 'medulloblastoma',
                    'IDH mutation', 'MGMT methylation', '1p19q codeletion', 'BRAF mutation',
                    'gross total resection', 'subtotal resection', 'awake craniotomy'],
                redFlags: ['papilledema', 'Cushing triad', 'uncal herniation', 'midline shift',
                    'hydrocephalus', 'seizures', 'rapid neurological decline', 'hemorrhage into tumor'],
                examFindings: ['papilledema', 'visual field defects', 'cranial nerve palsies',
                    'pronator drift', 'aphasia', 'neglect', 'ataxia', 'nystagmus'],
                differentials: ['Primary brain tumor', 'Metastatic disease', 'Abscess', 'Demyelinating disease',
                    'Vascular malformation', 'Radiation necrosis', 'Tumefactive MS'],
                workup: ['MRI brain with and without contrast', 'MR spectroscopy', 'MR perfusion',
                    'PET scan for metastatic workup', 'Lumbar puncture if carcinomatous meningitis',
                    'Neuropsychological testing pre-op', 'fMRI for eloquent area mapping'],
                guidelines: ['WHO 2021 CNS tumor classification', 'RANO criteria', 'Stupp protocol for GBM',
                    'RTOG recursive partitioning analysis', 'Karnofsky performance scale'],
                recommendedScales: ['gcs', 'vas_pain']
            },
            'vascular': {
                name: 'Cerebrovascular Disease',
                vocabulary: ['subarachnoid hemorrhage', 'aneurysm', 'AVM', 'dural AVF', 'cavernoma',
                    'moyamoya', 'vasospasm', 'Hunt-Hess', 'Fisher grade', 'WFNS grade',
                    'coiling', 'clipping', 'flow diverter', 'pipeline', 'WEB device'],
                redFlags: ['thunderclap headache', 'decreased GCS', 'new focal deficit', 'seizure',
                    'vasospasm window day 3-14', 'rebleeding', 'hydrocephalus', 'herniation'],
                examFindings: ['neck stiffness', 'Kernig sign', 'Brudzinski sign', 'cranial nerve palsies',
                    'pupillary changes', 'motor deficits', 'altered mental status'],
                differentials: ['Aneurysmal SAH', 'Perimesencephalic SAH', 'Traumatic SAH', 'AVM rupture',
                    'Reversible cerebral vasoconstriction syndrome', 'Pituitary apoplexy'],
                workup: ['CT head non-contrast - urgent', 'CTA head and neck', 'Lumbar puncture if CT negative',
                    'DSA gold standard', 'Transcranial dopplers for vasospasm', 'EEG if seizure concern'],
                guidelines: ['AHA/ASA guidelines for aneurysmal SAH', 'Hunt-Hess grading', 'Fisher scale',
                    'WFNS grading', 'Spetzler-Martin AVM grading'],
                recommendedScales: ['gcs', 'vas_pain']
            },
            'hydrocephalus': {
                name: 'Hydrocephalus',
                vocabulary: ['communicating', 'non-communicating', 'normal pressure hydrocephalus', 'NPH triad',
                    'ventriculomegaly', 'transependymal flow', 'aqueductal stenosis', 'fourth ventricle outlet obstruction',
                    'VP shunt', 'VA shunt', 'ETV', 'third ventriculostomy', 'programmable valve'],
                redFlags: ['acute mental status change', 'Cushing triad', 'upward gaze palsy', 'papilledema',
                    'bradycardia', 'hypertension', 'irregular respirations', 'seizures'],
                examFindings: ['gait apraxia', 'urinary incontinence', 'cognitive decline', 'papilledema',
                    'sixth nerve palsy', 'Parinaud syndrome', 'setting sun sign'],
                differentials: ['NPH', 'Obstructive hydrocephalus', 'Ex-vacuo changes', 'Cerebral atrophy',
                    'Chronic subdural hematoma', 'Previous SAH', 'Meningitis sequelae'],
                workup: ['MRI brain with CSF flow study', 'High volume lumbar puncture test',
                    'Lumbar drain trial', 'ICP monitoring', 'Neuropsychological testing', 'Gait assessment pre/post LP'],
                guidelines: ['International NPH guidelines', 'ETV success score', 'Evans index',
                    'Callosal angle measurement', 'DESH findings'],
                recommendedScales: ['gcs']
            },
            'functional': {
                name: 'Functional Neurosurgery',
                vocabulary: ['essential tremor', 'Parkinson disease', 'dystonia', 'DBS', 'GPi', 'STN',
                    'VIM nucleus', 'frame-based', 'frameless', 'microelectrode recording',
                    'beta oscillations', 'levodopa response', 'UPDRS score'],
                redFlags: ['atypical parkinsonism', 'cognitive decline', 'psychiatric symptoms',
                    'medication refractory symptoms', 'severe dyskinesias', 'DBS hardware infection'],
                examFindings: ['resting tremor', 'bradykinesia', 'rigidity', 'postural instability',
                    'dystonic posturing', 'action tremor', 'intention tremor', 'pull test'],
                differentials: ['Parkinson disease', 'Essential tremor', 'Multiple system atrophy',
                    'Progressive supranuclear palsy', 'Corticobasal degeneration', 'Dystonia'],
                workup: ['MRI brain for DBS planning', 'DaTscan', 'Neuropsychological evaluation',
                    'Levodopa challenge test', 'UPDRS scoring', 'Video assessment'],
                guidelines: ['MDS clinical diagnostic criteria for PD', 'UPDRS scoring',
                    'Hoehn and Yahr staging', 'CAPSIT-PD protocol'],
                recommendedScales: ['vas_pain']
            },
            'pediatric': {
                name: 'Pediatric Neurosurgery',
                vocabulary: ['myelomeningocele', 'Chiari malformation', 'craniosynostosis', 'tethered cord',
                    'syrinx', 'encephalocele', 'Dandy-Walker', 'arachnoid cyst', 'hypothalamic hamartoma',
                    'cranial vault remodeling', 'duraplasty', 'detethering'],
                redFlags: ['increasing head circumference', 'bulging fontanelle', 'sunset eyes',
                    'developmental delay', 'regression of milestones', 'new onset seizures',
                    'stridor', 'apnea', 'failure to thrive'],
                examFindings: ['head circumference', 'fontanelle assessment', 'cranial sutures', 'primitive reflexes',
                    'developmental milestones', 'cutaneous stigmata', 'scoliosis check'],
                differentials: ['Chiari I vs II', 'Hydrocephalus', 'Benign enlargement of subarachnoid spaces',
                    'Craniosynostosis types', 'Tethered cord syndrome', 'Spinal dysraphism'],
                workup: ['MRI brain and spine', 'Cranial ultrasound if open fontanelle',
                    'CT head for craniosynostosis', 'Urodynamics for tethered cord',
                    'Sleep study for Chiari', 'Genetic testing if syndromic'],
                guidelines: ['Chiari malformation guidelines', 'Craniosynostosis classifications',
                    'Spina bifida management guidelines', 'Pediatric hydrocephalus consensus'],
                recommendedScales: ['gcs']
            },
            'peripheral': {
                name: 'Peripheral Nerve',
                vocabulary: ['carpal tunnel', 'cubital tunnel', 'thoracic outlet syndrome', 'peroneal palsy',
                    'meralgia paresthetica', 'nerve tumor', 'schwannoma', 'neurofibroma',
                    'nerve transfer', 'neurolysis', 'transposition', 'decompression'],
                redFlags: ['rapid progression', 'muscle wasting', 'complete nerve palsy',
                    'multiple nerve involvement', 'associated mass', 'malignant transformation'],
                examFindings: ['Tinel sign', 'Phalen test', 'Froment sign', 'Wartenberg sign',
                    'sensory distribution testing', 'two-point discrimination', 'muscle bulk', 'specific muscle testing'],
                differentials: ['Compression neuropathy', 'Peripheral neuropathy', 'Radiculopathy',
                    'Brachial plexopathy', 'Motor neuron disease', 'Nerve tumor'],
                workup: ['EMG/NCS', 'MRI for nerve visualization', 'Ultrasound for dynamic assessment',
                    'MR neurography', 'Laboratory studies for neuropathy'],
                guidelines: ['AAOS carpal tunnel guidelines', 'Peripheral nerve injury classification',
                    'Seddon and Sunderland classifications'],
                recommendedScales: ['vas_pain']
            }
        };

        // ============================================================
        // API KEY SETTINGS FUNCTIONS
        // ============================================================

        function openSettings() {
            try {
                console.log('üîß Opening settings modal...');
                const modal = document.getElementById('settingsModal');
                const input = document.getElementById('apiKeyInput');
                const statusDiv = document.getElementById('apiKeyStatusModal');

                if (!modal) {
                    console.error('‚ùå Settings modal element not found');
                    alert('Error: Settings modal not found. Please refresh the page.');
                    return;
                }

                if (!input) {
                    console.error('‚ùå API key input element not found');
                    return;
                }

                // Load existing key if available (show masked)
                if (API_KEY) {
                    input.value = API_KEY;
                    input.type = 'password';
                } else {
                    input.value = '';
                }

                if (statusDiv) {
                    statusDiv.style.display = 'none';
                }

                modal.style.display = 'flex';
                console.log('‚úÖ Settings modal opened');
            } catch (error) {
                console.error('‚ùå Error opening settings:', error);
                alert('Error opening settings. Please refresh the page and try again.');
            }
        }

        function closeSettings() {
            try {
                const modal = document.getElementById('settingsModal');
                if (modal) {
                    modal.style.display = 'none';
                    console.log('‚úÖ Settings modal closed');
                } else {
                    console.error('‚ùå Settings modal not found');
                }
            } catch (error) {
                console.error('‚ùå Error closing settings:', error);
            }
        }

        async function saveAPIKey() {
            try {
                console.log('üíæ Attempting to save API key...');
                const input = document.getElementById('apiKeyInput');

                if (!input) {
                    console.error('‚ùå API key input element not found');
                    alert('Error: Could not find API key input field');
                    return;
                }

                const statusDiv = document.getElementById('apiKeyStatusModal');
                const key = input.value.trim();

                // Validate input
                if (!key) {
                    showAPIKeyStatus('error', '‚ùå Please enter an API key');
                    return;
                }

                console.log('üîç Validating API key format...');

                if (!key.startsWith('AIza')) {
                    showAPIKeyStatus('error', '‚ùå Invalid API key format. Key should start with "AIza"');
                    return;
                }

                // Show testing status
                showAPIKeyStatus('info', '‚è≥ Testing API key...');
                console.log('üß™ Testing API key with Gemini API...');

                // Test the API key with a simple request
                const testResponse = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${key}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: 'Test' }]
                            }],
                            generationConfig: {
                                temperature: 0.3,
                                maxOutputTokens: 10
                            }
                        })
                    }
                );

                if (testResponse.ok) {
                    // API key is valid - save it
                    console.log('‚úÖ API key validated successfully');
                    const encrypted = btoa(key.split('').reverse().join(''));
                    localStorage.setItem('neuroscribe_gemini_key', encrypted);
                    localStorage.setItem('neuroscribe_provider', 'gemini');
                    API_KEY = key;

                    showAPIKeyStatus('success', '‚úÖ API key saved and verified! Reloading...');
                    updateAPIKeyStatus(true);

                    // Close modal and reload after 1 second
                    setTimeout(() => {
                        closeSettings();
                        location.reload();
                    }, 1500);

                } else {
                    const errorData = await testResponse.json().catch(() => ({}));
                    const errorMsg = errorData.error?.message || 'Invalid API key';
                    console.error('‚ùå API key test failed:', errorMsg);
                    showAPIKeyStatus('error', `‚ùå API key test failed: ${errorMsg}`);
                }

            } catch (error) {
                console.error('‚ùå Critical error in saveAPIKey:', error);
                showAPIKeyStatus('error', `‚ùå Error testing API key: ${error.message}`);
            }
        }

        function showAPIKeyStatus(type, message) {
            try {
                const statusDiv = document.getElementById('apiKeyStatusModal');

                if (!statusDiv) {
                    console.warn('‚ö†Ô∏è  API key status div not found, using console instead');
                    console.log(`${type.toUpperCase()}: ${message}`);
                    return;
                }

                statusDiv.style.display = 'block';

                const colors = {
                    success: { bg: '#d1fae5', border: '#10b981', color: '#065f46' },
                    error: { bg: '#fee2e2', border: '#dc2626', color: '#991b1b' },
                    info: { bg: '#dbeafe', border: '#4A90E2', color: '#1e40af' }
                };

                const color = colors[type] || colors.info;
                statusDiv.style.background = color.bg;
                statusDiv.style.borderLeft = `3px solid ${color.border}`;
                statusDiv.style.color = color.color;
                statusDiv.textContent = message;
            } catch (error) {
                console.error('‚ùå Error showing API key status:', error);
            }
        }

        function loadAPIKey() {
            try {
                console.log('üîç Checking for API key in localStorage...');
                const encrypted = localStorage.getItem('neuroscribe_gemini_key');
                console.log('Encrypted key:', encrypted ? `Found (${encrypted.length} chars)` : 'NULL');

                const statusEl = document.getElementById('status');

                if (encrypted) {
                    try {
                        API_KEY = atob(encrypted).split('').reverse().join('');
                        if (statusEl) {
                            statusEl.className = 'status connected';
                            statusEl.textContent = '‚úÖ API Key Loaded - Ready to Generate';
                        }
                        console.log('‚úÖ API key loaded:', API_KEY.substring(0, 15) + '...');
                        updateAPIKeyStatus(true);
                        return true;
                    } catch (e) {
                        console.error('‚ùå Failed to decrypt key:', e);
                        if (statusEl) {
                            statusEl.className = 'status disconnected';
                            statusEl.textContent = '‚ùå API Key Error - Click Settings';
                        }
                        updateAPIKeyStatus(false);
                    }
                }

                console.warn('‚ö†Ô∏è  No API key found in localStorage');
                if (statusEl) {
                    statusEl.className = 'status disconnected';
                    statusEl.innerHTML = '‚ùå No API Key - Click <strong>‚öôÔ∏è Settings</strong> to configure';
                }
                updateAPIKeyStatus(false);

                // Auto-open settings modal if no key found
                setTimeout(() => {
                    try {
                        openSettings();
                    } catch (e) {
                        console.error('‚ùå Error opening settings:', e);
                    }
                }, 1500);

                return false;
            } catch (error) {
                console.error('‚ùå Critical error in loadAPIKey:', error);
                return false;
            }
        }

        // Test API Key without saving
        async function testAPIKey() {
            const input = document.getElementById('apiKeyInput');
            const key = input.value.trim();

            if (!key) {
                showAPIKeyStatus('error', '‚ùå Please enter an API key to test');
                return;
            }

            if (!key.startsWith('AIza')) {
                showAPIKeyStatus('error', '‚ùå Invalid API key format');
                return;
            }

            showAPIKeyStatus('info', '‚è≥ Testing API key...');

            try {
                const testResponse = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${key}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: 'Test' }]
                            }],
                            generationConfig: {
                                temperature: 0.3,
                                maxOutputTokens: 10
                            }
                        })
                    }
                );

                if (testResponse.ok) {
                    showAPIKeyStatus('success', '‚úÖ API key is valid!');
                } else {
                    const errorData = await testResponse.json();
                    const errorMsg = errorData.error?.message || 'Invalid API key';
                    showAPIKeyStatus('error', `‚ùå Test failed: ${errorMsg}`);
                }
            } catch (error) {
                showAPIKeyStatus('error', `‚ùå Error: ${error.message}`);
            }
        }

        // Clear API Key from storage
        function clearAPIKey() {
            if (confirm('Are you sure you want to clear the saved API key?')) {
                localStorage.removeItem('neuroscribe_gemini_key');
                localStorage.removeItem('neuroscribe_provider');
                API_KEY = null;
                document.getElementById('apiKeyInput').value = '';
                showAPIKeyStatus('success', 'üóëÔ∏è API key cleared! Please enter a new key.');
                updateAPIKeyStatus(false);
            }
        }

        // Update API Key Status Indicator in Header
        function updateAPIKeyStatus(isValid) {
            const statusDiv = document.getElementById('apiKeyStatus');
            if (!statusDiv) return;

            if (isValid) {
                statusDiv.innerHTML = '‚úÖ <span style="color: #10b981;">API Key Active</span>';
            } else {
                statusDiv.innerHTML = '‚ùå <span style="color: #ef4444;">No API Key</span>';
            }
        }

        // Toggle Panel Collapse
        function togglePanel(panelId) {
            try {
                console.log(`üîÑ Toggling panel: ${panelId}`);
                const content = document.getElementById(`${panelId}-content`);
                const icon = document.getElementById(`${panelId}-icon`);

                if (!content) {
                    console.error(`‚ùå Panel content not found: ${panelId}-content`);
                    return;
                }

                if (!icon) {
                    console.error(`‚ùå Panel icon not found: ${panelId}-icon`);
                    return;
                }

                content.classList.toggle('collapsed');
                icon.classList.toggle('collapsed');

                // Save state to localStorage
                const isCollapsed = content.classList.contains('collapsed');
                localStorage.setItem(`panel_${panelId}_collapsed`, isCollapsed);

                console.log(`‚úÖ Panel ${panelId} is now ${isCollapsed ? 'collapsed' : 'expanded'}`);
            } catch (error) {
                console.error(`‚ùå Error toggling panel ${panelId}:`, error);
            }
        }

        // Restore panel states on load
        function restorePanelStates() {
            try {
                console.log('üîÑ Restoring panel states from localStorage...');
                ['briefing', 'transcript'].forEach(panelId => {
                    try {
                        const isCollapsed = localStorage.getItem(`panel_${panelId}_collapsed`) === 'true';
                        if (isCollapsed) {
                            const content = document.getElementById(`${panelId}-content`);
                            const icon = document.getElementById(`${panelId}-icon`);
                            if (content && icon) {
                                content.classList.add('collapsed');
                                icon.classList.add('collapsed');
                                console.log(`‚úÖ Panel ${panelId} restored as collapsed`);
                            }
                        } else {
                            console.log(`‚ÑπÔ∏è  Panel ${panelId} not collapsed`);
                        }
                    } catch (error) {
                        console.error(`‚ùå Error restoring panel ${panelId}:`, error);
                    }
                });
                console.log('‚úÖ Panel states restored');
            } catch (error) {
                console.error('‚ùå Error in restorePanelStates:', error);
            }
        }

        // Initialize Speech Recognition
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('‚ö†Ô∏è Speech recognition not supported in this browser. Please use Chrome, Edge, or Safari.');
                document.getElementById('startBtn').disabled = true;
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();

            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 3;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                console.log('üé§ Speech recognition started');
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    const confidence = event.results[i][0].confidence;

                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                        if (confidence) {
                            confidenceScores.push(confidence);
                            updateConfidence();
                        }
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (finalTranscript) {
                    const transcriptArea = document.getElementById('transcript');
                    transcriptArea.value += finalTranscript;
                    updateWordCount();

                    // Real-time monitoring
                    checkForRedFlags(finalTranscript);
                    checkForScaleComponents(finalTranscript);
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    alert('‚ùå Microphone access denied. Please allow microphone access in browser settings.');
                } else if (event.error === 'no-speech') {
                    console.log('No speech detected');
                } else {
                    alert(`Speech recognition error: ${event.error}`);
                }
            };

            recognition.onend = () => {
                if (isRecording && !isPaused) {
                    // Restart if still recording
                    recognition.start();
                } else {
                    console.log('üé§ Speech recognition ended');
                }
            };

            console.log('‚úÖ Speech recognition initialized');
        }

        function startRecording() {
            if (!recognition) {
                alert('Speech recognition not initialized');
                return;
            }

            isRecording = true;
            isPaused = false;
            startTime = Date.now();
            confidenceScores = [];

            try {
                recognition.start();
            } catch (e) {
                console.error('Failed to start recognition:', e);
            }

            // Update UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('status').className = 'status recording';
            document.getElementById('status').textContent = 'üî¥ Recording in progress...';

            // Start timer
            timerInterval = setInterval(updateDuration, 1000);
        }

        function stopRecording() {
            isRecording = false;
            isPaused = false;

            if (recognition) {
                recognition.stop();
            }

            // Update UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('status').className = 'status connected';
            document.getElementById('status').textContent = '‚úÖ Recording stopped - Ready to generate';

            // Stop timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function pauseRecording() {
            if (isPaused) {
                // Resume
                isPaused = false;
                recognition.start();
                document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
                document.getElementById('status').textContent = 'üî¥ Recording in progress...';
            } else {
                // Pause
                isPaused = true;
                recognition.stop();
                document.getElementById('pauseBtn').textContent = '‚ñ∂Ô∏è Resume';
                document.getElementById('status').textContent = '‚è∏Ô∏è Recording paused';
            }
        }

        function updateWordCount() {
            const text = document.getElementById('transcript').value;
            const words = text.trim().split(/\s+/).filter(w => w.length > 0);
            document.getElementById('wordCount').textContent = words.length;
        }

        function updateDuration() {
            if (!startTime) return;
            const elapsed = Date.now() - startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('duration').textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateConfidence() {
            if (confidenceScores.length === 0) {
                document.getElementById('confidence').textContent = '--';
                return;
            }
            const avg = confidenceScores.reduce((a, b) => a + b, 0) / confidenceScores.length;
            document.getElementById('confidence').textContent = Math.round(avg * 100) + '%';
        }

        function clearText() {
            if (confirm('Clear transcript?')) {
                document.getElementById('transcript').value = '';
                updateWordCount();
                confidenceScores = [];
                updateConfidence();
            }
        }

        // Pathology Selection
        function selectPathology(pathologyId) {
            selectedPathology = pathologyId;
            customPathology = ''; // Clear custom input when selecting preset
            document.getElementById('customPathology').value = '';

            // Update button states
            document.querySelectorAll('.pathology-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-pathology="${pathologyId}"]`).classList.add('active');

            // Enable briefing button
            document.getElementById('briefingBtn').disabled = false;

            // Update active red flags for monitoring
            if (PathologyDatabase[pathologyId]) {
                activeRedFlags = PathologyDatabase[pathologyId].redFlags;
                console.log(`‚úÖ Selected: ${PathologyDatabase[pathologyId].name}`);
                console.log(`üö® Monitoring ${activeRedFlags.length} red flags`);
            }
        }

        // Custom Pathology Input Handler
        function onCustomPathologyInput() {
            const input = document.getElementById('customPathology');
            customPathology = input.value.trim();

            if (customPathology.length > 3) {
                // Clear preset pathology selection
                selectedPathology = null;
                document.querySelectorAll('.pathology-btn').forEach(btn => {
                    btn.classList.remove('active');
                });

                // Enable briefing button
                document.getElementById('briefingBtn').disabled = false;

                // Clear red flags when using custom (will be generated)
                activeRedFlags = [];

                console.log(`‚úÖ Custom pathology entered: ${customPathology}`);
            } else if (customPathology.length === 0) {
                // Disable button if no input and no selection
                if (!selectedPathology) {
                    document.getElementById('briefingBtn').disabled = true;
                }
            }
        }

        // Generate Deep Briefing with Clinical Checklist
        async function generateDeepBriefing() {
            // Validate inputs
            if (!selectedPathology && !customPathology) {
                alert('Please enter a specific pathology or select a common category');
                return;
            }

            if (!API_KEY) {
                alert('API key not configured.');
                return;
            }

            const depth = document.getElementById('briefingDepth').value;
            const btn = document.getElementById('briefingBtn');
            const output = document.getElementById('briefingOutput');

            btn.disabled = true;
            btn.textContent = '‚è≥ Generating Deep Research...';
            output.innerHTML = '<p style="color: #999; text-align: center; padding: 30px;">Performing deep search and generating clinical checklist...</p>';

            try {
                // Determine pathology context
                let pathologyName, pathologyContext;

                if (customPathology) {
                    // Custom pathology - deep search mode
                    pathologyName = customPathology;
                    pathologyContext = `custom search for: ${customPathology}`;
                } else {
                    // Preset pathology - use database
                    const pathology = PathologyDatabase[selectedPathology];
                    pathologyName = pathology.name;
                    pathologyContext = `database-supported: ${pathology.name}`;
                }

                // Build depth-specific parameters
                const depthConfig = {
                    quick: { tokens: 2048, focus: 'essential checklist items', detail: 'concise' },
                    standard: { tokens: 4096, focus: 'comprehensive checklist with evidence', detail: 'detailed' },
                    comprehensive: { tokens: 8192, focus: 'exhaustive analysis with decision algorithms', detail: 'exhaustive' }
                };

                const config = depthConfig[depth];

                // Build additional context from uploaded documents
                let expertDocContext = '';
                if (uploadedDocText && uploadedDocText.trim().length > 0) {
                    expertDocContext = `\n\n=== UPLOADED EXPERT DOCUMENTS ===\nYou have been provided with ${uploadedDocuments.length} expert document(s) containing additional research, guidelines, or clinical information. Integrate this knowledge into your briefing:\n\n${uploadedDocText}\n\n=== END UPLOADED DOCUMENTS ===\n\nIMPORTANT: Synthesize information from the uploaded documents with your medical knowledge. Cite specific findings from the uploaded documents when relevant.\n\n`;
                }

                // Enhanced prompt for deep research + checklist
                const prompt = `You are a world-class neurosurgical consultant conducting deep research for a patient consultation on: ${pathologyName}
${expertDocContext}
Generate a ${config.detail} clinical briefing with an actionable checklist. Provide ${config.focus}.

${uploadedDocuments.length > 0 ? `üìö INTEGRATION NOTE: ${uploadedDocuments.length} expert document(s) uploaded. Please synthesize this additional information throughout your briefing.\n\n` : ''}Structure your response with these sections:

## üéØ Clinical Overview
- Pathophysiology and clinical significance
- Key anatomical considerations
- Common presentations and variants

## üìã CLINICAL CHECKLIST

### History Questions to Ask:
- [ ] [List 5-10 specific questions organized by system]

### Physical Examination Maneuvers:
- [ ] [List 5-10 specific exam techniques with interpretation]

### Critical Red Flags to Screen:
- [ ] [List 5-10 emergency warning signs requiring urgent intervention]

### Differential Diagnoses to Consider:
- [ ] [List 5-8 alternative diagnoses ranked by likelihood]

## üî¨ Diagnostic Workup

### First-Line Investigations:
- [ ] [List essential studies with rationale]

### Advanced/Specialized Testing:
- [ ] [List additional studies if first-line inconclusive]

### Laboratory Studies:
- [ ] [List relevant lab tests]

## üíé Evidence-Based Management

### Conservative Management Options:
- [Level I-V evidence citations]

### Surgical Indications:
- Absolute indications:
- Relative indications:

### Decision Algorithm:
- If [finding], then [action]
- [Provide step-by-step clinical decision tree]

## üìö Clinical Guidelines & Evidence
- [List relevant Level I-III evidence]
- [Citation to major guidelines]

## ‚ö†Ô∏è Complications & Risk Stratification
- Common complications to discuss
- Risk factors for poor outcomes

Make this actionable and ready to use during the patient consultation. Use checkboxes for items to verify.`;

                // Call Gemini API
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.4,  // Slightly higher for comprehensive research
                                maxOutputTokens: config.tokens
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                const briefingText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No briefing generated';

                // Store briefing data globally for integration
                generatedBriefing = briefingText;
                briefingUsed = false;  // Will be set to true when used in documentation

                // Extract checklist items for later use
                briefingChecklist = extractChecklistItems(briefingText);

                console.log(`‚úÖ Deep briefing generated for: ${pathologyName}`);
                console.log(`üìã Extracted ${briefingChecklist.length} checklist items`);

                // Convert markdown to HTML for display
                let html = briefingText
                    .replace(/^## (.+)$/gm, '<h3 style="color: #0066CC; margin-top: 15px; margin-bottom: 8px; font-size: 1rem;">$1</h3>')
                    .replace(/^### (.+)$/gm, '<h4 style="color: #333; margin-top: 12px; margin-bottom: 6px; font-size: 0.95rem; font-weight: 600;">$1</h4>')
                    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                    .replace(/^- \[ \] (.+)$/gm, '<div style="margin-left: 15px; margin-bottom: 5px;"><input type="checkbox" style="margin-right: 8px;">$1</div>')
                    .replace(/^- (.+)$/gm, '<div style="margin-left: 15px; margin-bottom: 5px;">‚Ä¢ $1</div>')
                    .replace(/\n\n/g, '<br>');

                output.innerHTML = html;

                // Update status to show briefing is ready
                const status = document.getElementById('status');
                status.className = 'status';
                status.style.background = '#d4edda';
                status.style.color = '#155724';
                status.textContent = '‚úÖ Deep briefing ready - Will be integrated with documentation';

                // Enable enhancement toggles now that briefing is available
                updateEnhancementToggles();

            } catch (error) {
                console.error('Deep briefing generation error:', error);
                output.innerHTML = `<p style="color: #DC143C; padding: 20px;">‚ùå Error: ${error.message}</p>`;
                alert(`Deep briefing generation failed: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üéØ Generate Deep Research + Checklist';
            }
        }

        // Extract checklist items from briefing text
        function extractChecklistItems(text) {
            const checklistItems = [];
            const lines = text.split('\n');

            for (const line of lines) {
                // Match checkbox items: - [ ] Item text
                const match = line.match(/^- \[ \] (.+)$/);
                if (match) {
                    checklistItems.push(match[1].trim());
                }
            }

            return checklistItems;
        }

        // Real-time Red Flag Monitoring
        function checkForRedFlags(text) {
            if (activeRedFlags.length === 0) return;

            const lowerText = text.toLowerCase();
            const detectedFlags = [];

            activeRedFlags.forEach(flag => {
                if (lowerText.includes(flag.toLowerCase())) {
                    detectedFlags.push(flag);
                }
            });

            if (detectedFlags.length > 0) {
                const transcriptArea = document.getElementById('transcript');
                const status = document.getElementById('status');

                // Visual alert
                transcriptArea.style.borderColor = '#DC143C';
                transcriptArea.style.borderWidth = '3px';

                // Update status
                status.className = 'status';
                status.style.background = '#f8d7da';
                status.style.color = '#721c24';
                status.textContent = `üö® RED FLAG DETECTED: ${detectedFlags.join(', ')}`;

                console.warn('üö® RED FLAGS DETECTED:', detectedFlags);

                // Reset border after 5 seconds
                setTimeout(() => {
                    transcriptArea.style.borderColor = '#ddd';
                    transcriptArea.style.borderWidth = '2px';
                    if (isRecording) {
                        status.className = 'status recording';
                        status.textContent = 'üî¥ Recording in progress...';
                    } else {
                        status.className = 'status connected';
                        status.textContent = '‚úÖ Ready to generate';
                    }
                }, 5000);
            }
        }

        async function generate() {
            // Detect which input mode is active
            const inputMode = detectActiveInputPanel();

            // Route to appropriate generation function
            if (inputMode === 'soap') {
                // Validate SOAP entry (async - supports parsing in simple mode)
                if (!await validateSOAPEntry()) {
                    return;
                }
                // Call SOAP generation
                await generateFromSOAP();
                return;
            }

            // Continue with transcript mode
            const transcript = document.getElementById('transcript').value.trim();

            if (!transcript) {
                alert('Please enter or record a clinical transcript first');
                return;
            }

            if (!API_KEY) {
                alert('API key not configured.');
                return;
            }

            const btn = document.getElementById('generateBtn');
            const status = document.getElementById('status');
            const output = document.getElementById('output');

            // V6: Reset review state for new generation
            currentSuggestions = [];
            const reviewTabButton = document.getElementById('review-tab-button');
            if (reviewTabButton) {
                reviewTabButton.style.display = 'none';
            }

            btn.disabled = true;
            btn.textContent = '‚è≥ Generating Expert Analysis...';
            status.className = 'status';
            status.style.background = '#d1ecf1';
            status.style.color = '#0c5460';

            // Check if briefing is available for integration
            const hasBriefing = generatedBriefing && generatedBriefing.length > 0;

            // Check enhancement mode toggle
            if (transcriptEnhanceMode && hasBriefing) {
                status.textContent = 'üîÑ Enhanced Mode: Briefing + Transcript ‚Üí Expert Analysis';
            } else {
                status.textContent = 'üîÑ Expand Only: Professional documentation from transcript';
            }

            try {
                let prompt;

                if (transcriptEnhanceMode && hasBriefing) {
                    // EXPERT MODE: Integrated briefing + transcript analysis (toggle ON + briefing available)
                    const pathologyData = selectedPathology ? PathologyDatabase[selectedPathology] : null;
                    const pathologyName = customPathology || (pathologyData ? pathologyData.name : 'Unknown');

                    // Build scale assessment section
                    let scaleAssessmentSection = '';
                    if (pathologyData && pathologyData.recommendedScales && pathologyData.recommendedScales.length > 0) {
                        const scaleNames = pathologyData.recommendedScales
                            .map(id => ClinicalScalesDatabase[id]?.shortName || id)
                            .join(', ');

                        scaleAssessmentSection = `\n### üìã Clinical Scales Assessment:\nRecommended scales for this pathology: ${scaleNames}\n\nFor each recommended scale, assess which components were addressed in the transcript and which are missing:\n`;

                        for (const scaleId of pathologyData.recommendedScales) {
                            const scale = ClinicalScalesDatabase[scaleId];
                            if (scale) {
                                scaleAssessmentSection += `\n**${scale.shortName}** (${scale.name}):\n`;
                                for (const q of scale.questions) {
                                    const questionText = q.text.length > 80 ? q.text.substring(0, 80) + '...' : q.text;
                                    scaleAssessmentSection += `- [ ] ${questionText}\n`;
                                }
                            }
                        }

                        scaleAssessmentSection += `\n‚ö†Ô∏è MISSING INFORMATION TO OBTAIN:\n[List specific scale questions that were NOT addressed in transcript and should be asked during follow-up]\n`;
                    }

                    prompt = `You are an expert neurosurgical consultant. Create a comprehensive consultation note from the transcript AND provide expert clinical analysis.

CRITICAL STRUCTURE REQUIREMENTS:

## SECTION 1: DOCUMENTED CONVERSATION
Start with what was actually said in the encounter:
üìù DOCUMENTED: [Professional narrative of the actual conversation - NO additions]

## SECTION 2: AI-GENERATED EXPERT ANALYSIS
After documented content, provide expert analysis wrapped in AI_SUGGESTION markers.

MARKER FORMAT EXAMPLES:

<!-- AI_SUGGESTION type="clinical-analysis" id="analysis-001" category="subjective" depends-on="" -->
ü§ñ CLINICAL ANALYSIS:
[Your expert interpretation of symptoms, patterns, temporal relationships]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="clinical-reasoning" id="reasoning-001" category="assessment" depends-on="analysis-001" -->
üß† DIAGNOSTIC REASONING:

**Hypothesis Generation:**
- Initial differential based on chief complaint: [List 3-5 hypotheses]
- Pre-test probabilities ranked: [Most likely ‚Üí Least likely with rationale]

**Data Interpretation:**
- Key positive findings supporting diagnosis:
  ‚Ä¢ [Finding 1] - Weight: High/Moderate/Low (likelihood ratio +X.X)
  ‚Ä¢ [Finding 2] - Weight: High/Moderate/Low
  ‚Ä¢ [Finding 3] - Weight: High/Moderate/Low
- Key negative findings against alternatives:
  ‚Ä¢ [Negative finding 1] - Rules out: [Alternative diagnosis]
  ‚Ä¢ [Negative finding 2] - Makes unlikely: [Alternative diagnosis]
- Discriminating features present: [Findings that narrow differential]

**Bayesian Reasoning:**
- Findings that significantly INCREASE probability:
  ‚Ä¢ [Finding] ‚Üí Increases likelihood by [X]% (LR+ = X.X)
  ‚Ä¢ [Finding] ‚Üí Strongly supports [diagnosis] (LR+ = X.X)
- Findings that significantly DECREASE probability:
  ‚Ä¢ [Absence of finding] ‚Üí Decreases likelihood by [X]% (LR- = 0.X)
  ‚Ä¢ [Negative finding] ‚Üí Argues against [diagnosis] (LR- = 0.X)

**Diagnostic Threshold Assessment:**
- Test threshold reached: [Yes/No with explanation]
  ‚Üí Additional testing needed: [Yes/No - specify tests]
- Treatment threshold reached: [Yes/No with explanation]
  ‚Üí Sufficient certainty to treat empirically: [Yes/No]
- Certainty level: [High (>90%) / Moderate (70-90%) / Low (<70%)]
  ‚Üí Basis for certainty: [Explain reasoning]

**Clinical Synthesis:**
[Summarize diagnostic reasoning in 2-3 sentences showing logical progression from symptoms ‚Üí findings ‚Üí diagnosis]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="differential" id="diff-001" category="assessment" depends-on="analysis-001,reasoning-001" -->
ü§ñ SYSTEMATIC DIFFERENTIAL DIAGNOSIS:

**PRIMARY DIAGNOSIS:**
1. **[Most Likely Diagnosis]** - Confidence: [High/Moderate/Low] ([X]%)
   - Supporting features (present):
     ‚Ä¢ [Feature 1 with specificity/sensitivity data]
     ‚Ä¢ [Feature 2]
     ‚Ä¢ [Feature 3]
   - Discriminating features: [Findings that distinguish from alternatives]
   - Epidemiological fit: [Age/gender/risk factor concordance - relevant/not relevant]
   - Timeline consistency: [Natural history alignment - consistent/atypical]
   - Against: [Any contradicting findings that don't fit]
   - Evidence base: [Cite relevant guidelines/studies if applicable]

**ALTERNATIVE DIAGNOSES (Ranked by Likelihood):**
2. **[Alternative 1]** - Confidence: [X]%
   - Why considered: [Key overlapping clinical features]
   - Why less likely: [Discriminating negatives or timeline issues]
   - Rule-out criteria: [What specific findings would exclude this diagnosis]

3. **[Alternative 2]** - Confidence: [X]%
   - Why considered: [Overlapping features]
   - Why less likely: [Key differences]
   - Rule-out criteria: [Exclusion criteria]

**MUST-NOT-MISS DIAGNOSES:**
‚ùó **[Dangerous diagnosis 1]** - Status: [Ruled out / Unlikely / Cannot exclude]
   - Ruled out by: [Specific findings/tests OR "Cannot exclude - needs further workup"]

‚ùó **[Dangerous diagnosis 2]** - Status: [Ruled out / Unlikely / Cannot exclude]
   - Ruled out by: [Specific findings/tests]

**RED FLAG DIFFERENTIAL:**
‚ö†Ô∏è Life-threatening conditions systematically screened:
- [ ] [Condition 1 (e.g., herniation, cauda equina)] - Status: [Ruled out / Possible / Confirmed]
      Evidence: [Specific exam findings or imaging]
- [ ] [Condition 2] - Status: [Ruled out / Possible / Confirmed]
      Evidence: [Findings]

**NEXT DIAGNOSTIC STEPS TO NARROW DIFFERENTIAL:**
- If [specific clinical finding present], then [specific action to favor diagnosis A over B]
- If [test result X], strongly favors [diagnosis Y] over [diagnosis Z] (sensitivity/specificity data)
- Key discriminating test needed: [Test name] - will differentiate between [diagnosis A vs B]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="red-flag" id="alert-001" category="assessment" depends-on="" -->
‚ö†Ô∏è RED FLAG ALERT:
[Critical findings requiring immediate attention]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="gap-analysis" id="gap-001" category="assessment" depends-on="" -->
ü§ñ CLINICAL GAPS IDENTIFIED:
Missing from history: [list]
Missing from exam: [list from briefing checklist]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="workup" id="workup-001" category="plan" depends-on="diff-001" -->
üî¨ RECOMMENDED DIAGNOSTIC WORKUP:
### Immediate/Urgent:
- [Studies with rationale]
### Standard:
- [Routine investigations from briefing]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="recommendation" id="rec-001" category="plan" depends-on="diff-001,workup-001" -->
üíä EVIDENCE-BASED MANAGEMENT PLAN:
### Conservative:
- [Options with evidence levels from briefing]
### Surgical Considerations:
- [If indications met per briefing]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="scales" id="scales-001" category="objective" depends-on="" -->
üìè CLINICAL SCALES ASSESSMENT:
${scaleAssessmentSection}
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="pearl" id="pearl-001" category="assessment" depends-on="" -->
üí° CLINICAL PEARL:
[Expert insight relevant to this presentation]
üìä Evidence Level: [I/II/III/IV from briefing]
<!-- /AI_SUGGESTION -->

MARKER RULES:
1. **Every AI-generated insight MUST be wrapped** in AI_SUGGESTION markers
2. **Use type attribute**: clinical-analysis, differential, recommendation, pearl, red-flag, gap-analysis, workup, scales
3. **Unique ID**: Use format type-### (e.g., diff-001, rec-002)
4. **Category**: subjective, objective, assessment, plan
5. **depends-on**: Comma-separated parent IDs if suggestion builds on others (empty string if independent)
6. **DO NOT wrap** üìù DOCUMENTED sections - only AI additions

=== PRE-CONSULTATION BRIEFING ===
${generatedBriefing}

Use this briefing to inform your expert analysis. Check for:
- Completeness of history/exam per briefing checklist
- Red flags identified or ruled out
- Evidence-based workup recommendations
- Pathology-specific management guidelines
- Clinical scales completion status

=== CLINICAL ENCOUNTER TRANSCRIPT ===
${transcript}

---
CONTEXT:
- Pathology Context: ${pathologyName}
- Evidence Base: Pre-consultation briefing available

ANTI-HALLUCINATION RULES:
‚úÖ Document actual conversation professionally in üìù DOCUMENTED
‚úÖ Provide expert analysis in marked AI_SUGGESTION blocks
‚úÖ Use briefing to inform analysis
‚úÖ Mark all suggestions properly with correct attributes
‚úÖ Link related suggestions with depends-on

‚ùå DO NOT add facts to üìù DOCUMENTED
‚ùå DO NOT modify what was actually said
‚ùå DO NOT forget markers on AI suggestions
‚ùå DO NOT create suggestions without proper type, id, category

Generate the comprehensive note with proper markers:`;

                } else {
                    // EXPAND ONLY MODE: Simple documentation (toggle OFF or no briefing)

                    // Check consultation type for appropriate prompt
                    if (consultationType === 'followup') {
                        // FOLLOW-UP VISIT EXPAND ONLY PROMPT
                        prompt = `You are a medical documentation assistant. Convert this follow-up visit transcript into professional clinical documentation.

CRITICAL RULES - WHAT YOU MUST DO:
‚úÖ Expand transcript into proper medical narrative format
‚úÖ Organize into standard follow-up visit structure
‚úÖ Use correct medical terminology and grammar
‚úÖ Expand common abbreviations appropriately

CRITICAL RULES - WHAT YOU MUST NOT DO:
‚ùå DO NOT add medical facts, symptoms, or findings not in transcript
‚ùå DO NOT infer or assume clinical information
‚ùå DO NOT add differential diagnoses beyond what clinician stated
‚ùå DO NOT add treatment recommendations not discussed
‚ùå DO NOT add examination findings not documented
‚ùå If information not mentioned, note "[Not documented]"

PROFESSIONAL LANGUAGE REQUIREMENTS:
‚úÖ Use precise medical terminology (avoid colloquialisms like "guy came in with")
‚úÖ Write in complete, grammatically correct sentences with proper medical narrative structure
‚úÖ Use standard medical abbreviations from Joint Commission approved list ONLY
‚úÖ Avoid ambiguous pronouns - use "the patient" consistently (not "he/she/they")
‚úÖ Use objective descriptors with measurements (not "seems somewhat" or "appears pretty")
‚úÖ Quantify whenever possible: pain 7/10 (not "severe pain"), weakness 4/5 (not "weak")
‚úÖ Use present tense for current status, past tense for historical information
‚úÖ Maintain professional clinical tone throughout (not conversational or casual)
‚úÖ Use patient-centered, non-stigmatizing language
‚ùå DO NOT use: casual language, ambiguous descriptors, dangerous abbreviations
‚ùå DO NOT use: judgmental language ("non-compliant" ‚Üí "did not adhere to treatment")
‚ùå DO NOT use: stigmatizing terms ("drug-seeking", "frequent flyer")

FOLLOW-UP VISIT FOCUS:
- Frame as INTERVAL HISTORY (changes since last visit)
- Document treatment response from transcript only
- Compare to baseline only if mentioned in transcript

# NEUROSURGICAL FOLLOW-UP NOTE

## INTERVAL HISTORY
[Document changes since last visit: symptoms better/worse/same, new developments, complications, medication compliance, therapy adherence]

## CURRENT SYMPTOMS
[Current symptom status with comparison to baseline if mentioned]
- Pain level: [Current vs previous]
- Functional status: [Current vs previous]
- New symptoms: [If any]

## MEDICATIONS & TREATMENTS
[Current medications with compliance, any changes, response to therapy]

## PHYSICAL EXAMINATION
**Updated Examination Findings:**
[Focus on relevant changes; state "unchanged from previous" if applicable]
- Neurological Examination:
  - Mental Status: [if assessed]
  - Motor: [any changes in strength, tone]
  - Sensory: [any changes]
  - Reflexes: [if assessed]
  - Gait: [if assessed]
  - Special tests: [if performed]

## DIAGNOSTIC RESULTS
[New imaging, labs, or studies since last visit with interpretation]

## ASSESSMENT
[Current status from transcript - improved/stable/worsened]
[Clinician's stated assessment from transcript only]

## PLAN
[Plan modifications from transcript ONLY - what was discussed]

## ICD-10 CODES
[Only if diagnosis clearly stated]

FINAL CHECK - CRITICAL:
‚úì Used ONLY information explicitly in transcript
‚úì Added NO medical facts or clinical information
‚úì Added NO treatment recommendations not discussed
‚úì Compared to baseline ONLY if mentioned in transcript
‚úì Professional language and organization from transcript content only

Transcript:
${transcript}`;

                    } else {
                        // NEW CONSULTATION EXPAND ONLY PROMPT
                        prompt = `You are a medical documentation assistant. Convert this clinical consultation transcript into professional clinical documentation.

CRITICAL RULES - WHAT YOU MUST DO:
‚úÖ Extract all information from transcript systematically
‚úÖ Organize into proper SOAP/consultation format
‚úÖ Use correct medical terminology and grammar
‚úÖ Expand common abbreviations appropriately
‚úÖ Maintain chronological narrative in HPI

CRITICAL RULES - WHAT YOU MUST NOT DO:
‚ùå DO NOT add medical facts, symptoms, or findings not in transcript
‚ùå DO NOT infer or assume clinical information
‚ùå DO NOT add differential diagnoses beyond what clinician stated
‚ùå DO NOT add workup studies not discussed in transcript
‚ùå DO NOT add treatment recommendations not mentioned
‚ùå DO NOT add examination findings not documented
‚ùå If information not mentioned, note "[Not documented]"

EXTRACTION REQUIREMENTS:
- Extract EVERY clinical detail mentioned in transcript
- Quantify when possible (pain scores, duration, frequency, ranges)
- Note temporal patterns (onset, progression, alleviating/aggravating factors)
- Document all examination findings with precise descriptions
- Identify any red flags or concerning features
- Note information gaps that should be obtained

# NEUROSURGICAL CONSULTATION NOTE

## CHIEF COMPLAINT
[Primary symptom or reason for visit - be specific and concise]

## HISTORY OF PRESENT ILLNESS
[Comprehensive narrative including: onset, location, duration, character, alleviating/aggravating factors, radiation, temporal pattern, associated symptoms, treatments tried, functional impact]

## PAST MEDICAL HISTORY
[List all conditions mentioned]

## PAST SURGICAL HISTORY
[List all surgeries with approximate dates if provided]

## MEDICATIONS
[List all medications with dosages if mentioned]

## ALLERGIES
[List drug/environmental allergies and reactions]

## PHYSICAL EXAMINATION
- **Vital Signs:** [Extract if mentioned]
- **General Appearance:** [Patient's overall presentation]
- **Neurological Examination:**
  - Mental Status: [Orientation, attention, memory]
  - Cranial Nerves: [I-XII assessment results]
  - Motor: [Strength by muscle group, tone, bulk]
  - Sensory: [Modalities tested and distributions]
  - Reflexes: [DTRs, pathological reflexes]
  - Cerebellar: [Coordination, dysmetria]
  - Gait: [Pattern, stability, aids needed]

## DIAGNOSTIC RESULTS
[Imaging, labs, EMG/NCS - extract findings if discussed]

## ASSESSMENT
[Clinician's stated diagnosis/impression from transcript - DO NOT add differential unless clinician discussed it]

## PLAN
[Management plan from transcript ONLY - DO NOT add recommendations not discussed]

## ICD-10 CODES
[Only if diagnosis clearly stated in transcript]

FINAL CHECK - CRITICAL:
‚úì Used ONLY information explicitly in transcript
‚úì Added NO medical facts, symptoms, or findings
‚úì Added NO differential diagnoses unless clinician stated them
‚úì Added NO treatment recommendations not discussed
‚úì Professional language and organization from transcript content only

Transcript:
${transcript}`;
                    }
                }

                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.4,  // Balanced: Maintains accuracy while improving narrative flow
                                maxOutputTokens: hasBriefing ? 16384 : 8192  // Double tokens for integrated analysis
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';

                // ============================================================
                // PHASE 7: VALIDATION PIPELINE INTEGRATION
                // ============================================================
                // Run 6-layer validation on generated content
                try {
                    console.log('üîç PHASE 4: VALIDATION PIPELINE');
                    status.textContent = 'üîç Validating generated content...';
                    status.className = 'status';
                    status.style.background = '#fff3cd';
                    status.style.color = '#856404';

                    // Create API client wrapper for validation
                    const validationAPIClient = {
                        generateText: async (prompt, options = {}) => {
                            const validationResponse = await fetch(
                                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${API_KEY}`,
                                {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        contents: [{
                                            role: 'user',
                                            parts: [{ text: prompt }]
                                        }],
                                        generationConfig: {
                                            temperature: options.temperature || 0.1,
                                            maxOutputTokens: options.maxOutputTokens || 2048
                                        }
                                    })
                                }
                            );

                            if (!validationResponse.ok) {
                                throw new Error(`Validation API Error ${validationResponse.status}`);
                            }

                            const validationData = await validationResponse.json();
                            return validationData.candidates?.[0]?.content?.parts?.[0]?.text || '';
                        }
                    };

                    // Initialize validation pipeline
                    const validator = new ValidationPipeline(validationAPIClient);

                    // Run complete validation (6 layers)
                    const validationResult = await validator.validateComplete(
                        {}, // extractedData - empty for now since we're validating generated text
                        transcript, // original source text
                        {
                            ultrathink: generatedText  // generated output to validate
                        },
                        {
                            skipSemanticFabrication: false,  // Run all validations
                            detailedGrounding: true
                        }
                    );

                    // Store validation results globally for Validation tab display (Phase 8)
                    lastValidationResult = validationResult;

                    // Log quality score
                    if (validationResult.success && validationResult.validation) {
                        const qualityScore = validationResult.validation.overallScore || 0;
                        console.log(`‚úÖ Validation Complete - Quality Score: ${qualityScore}/100`);
                        console.log('üìä Validation Summary:', {
                            grounding: validationResult.validation.grounding?.score || 'N/A',
                            fabrication: validationResult.validation.fabrication?.score || 'N/A',
                            completeness: validationResult.validation.completeness?.score || 'N/A',
                            consistency: validationResult.validation.consistency?.score || 'N/A',
                            proportionality: validationResult.validation.proportionality?.score || 'N/A',
                            overallScore: qualityScore
                        });

                        // Show quality badge in status (color-coded)
                        let qualityBadge = '';
                        let qualityColor = '';
                        if (qualityScore >= 80) {
                            qualityBadge = 'üü¢ High Quality';
                            qualityColor = '#28a745';
                        } else if (qualityScore >= 60) {
                            qualityBadge = 'üü° Moderate Quality';
                            qualityColor = '#ffc107';
                        } else {
                            qualityBadge = 'üî¥ Review Needed';
                            qualityColor = '#dc3545';
                        }

                        console.log(`${qualityBadge} (${qualityScore}/100)`);

                        // Display validation results in UI
                        displayValidationResults(validationResult);
                    } else {
                        console.warn('‚ö†Ô∏è Validation completed with warnings or partial results');
                    }
                } catch (validationError) {
                    // Validation failure should not break generation - log and continue
                    console.error('‚ö†Ô∏è Validation pipeline error (non-fatal):', validationError.message);
                    console.error('Stack:', validationError.stack);
                    lastValidationResult = {
                        success: false,
                        error: validationError.message,
                        validation: null
                    };
                }

                output.value = generatedText;
                status.className = 'status connected';

                if (hasBriefing) {
                    briefingUsed = true;
                    status.textContent = '‚úÖ Expert Analysis Complete - Briefing + Transcript Integrated!';
                    console.log('‚úÖ Expert integrated analysis generated successfully');
                    console.log(`üìã Briefing checklist items: ${briefingChecklist.length}`);
                } else {
                    status.textContent = '‚úÖ Documentation Generated Successfully!';
                    console.log('‚úÖ Generated successfully (no briefing)');
                }

                // Update formatted output tab
                updateFormattedOutput(generatedText);

                // V6: Parse AI suggestions if in enhanced mode
                if (transcriptEnhanceMode && hasBriefing) {
                    currentSuggestions = parseAISuggestions(generatedText);

                    if (currentSuggestions.length > 0) {
                        displayReviewInterface(currentSuggestions);

                        // Show review tab button and switch to it
                        const reviewTabButton = document.getElementById('review-tab-button');
                        if (reviewTabButton) {
                            reviewTabButton.style.display = 'inline-block';
                        }

                        switchTab('review');
                        status.textContent = `‚úÖ Expert Analysis Complete! Review ${currentSuggestions.length} AI suggestions.`;
                        console.log(`üîç ${currentSuggestions.length} suggestions ready for review`);
                    } else {
                        // No suggestions found, show validation tab
                        switchTab('validation');
                    }
                } else {
                    // Expand-only mode: show validation tab
                    switchTab('validation');
                }

                // Auto-generate compressed and ultracompressed summaries
                console.log('üìä Auto-generating compressed and ultracompressed summaries...');

                // Store the full note
                currentNoteVersions.full = generatedText;

                // Generate standard compression (independent)
                currentNoteVersions.status.standard = 'generating';
                updateCompressionStatusBadges();
                try {
                    const standardSummary = await generateAttendingSummary(generatedText);
                    currentNoteVersions.standard = standardSummary || '';
                    currentNoteVersions.status.standard = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Standard compression generated');
                } catch (standardError) {
                    console.error('‚ùå Standard compression failed:', standardError.message);
                    currentNoteVersions.standard = '‚ö†Ô∏è Standard compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.standard = 'failed';
                    updateCompressionStatusBadges();
                }

                // Generate ULTRA compression (independent)
                currentNoteVersions.status.ultra = 'generating';
                updateCompressionStatusBadges();
                try {
                    const ultraSummary = await generateUltraAttendingSummary(generatedText);
                    currentNoteVersions.ultra = ultraSummary || '';
                    currentNoteVersions.status.ultra = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ ULTRA compression generated');
                } catch (ultraError) {
                    console.error('‚ùå ULTRA compression failed:', ultraError.message);
                    currentNoteVersions.ultra = '‚ö†Ô∏è ULTRA compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.ultra = 'failed';
                    updateCompressionStatusBadges();
                }

                // Generate Telegram compression (independent)
                currentNoteVersions.status.telegram = 'generating';
                updateCompressionStatusBadges();
                try {
                    const telegramSummary = await generateTelegramSummary(generatedText);
                    currentNoteVersions.telegram = telegramSummary || '';
                    currentNoteVersions.status.telegram = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Telegram compression generated');
                } catch (telegramError) {
                    console.error('‚ùå Telegram compression failed:', telegramError.message);
                    currentNoteVersions.telegram = '‚ö†Ô∏è Telegram compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.telegram = 'failed';
                    updateCompressionStatusBadges();
                }

                // Display based on currently selected compression mode
                const selectedMode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
                const summaryToDisplay = selectedMode === 'ultra' ? currentNoteVersions.ultra
                                       : selectedMode === 'telegram' ? currentNoteVersions.telegram
                                       : currentNoteVersions.standard;

                if (summaryToDisplay && !summaryToDisplay.includes('failed')) {
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else if (summaryToDisplay) {
                    // Show error message in textarea
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else {
                    console.warn('‚ö†Ô∏è No summary generated');
                }

            } catch (error) {
                console.error('Generation error:', error);
                output.value = `‚ùå Error: ${error.message}`;
                status.className = 'status disconnected';
                status.textContent = '‚ùå Generation Failed';
                alert(`Generation failed: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.textContent = hasBriefing ? '‚ö° Generate Expert Analysis' : '‚ö° Generate Clinical Note';
            }
        }

        /**
         * Generate clinical note from SOAP quick-entry
         */
        async function generateFromSOAP() {
            if (!API_KEY) {
                alert('API key not configured.');
                return;
            }

            const btn = document.getElementById('generateBtn');
            const status = document.getElementById('status');
            const output = document.getElementById('output');

            // V6: Reset review state for new generation
            currentSuggestions = [];
            const reviewTabButton = document.getElementById('review-tab-button');
            if (reviewTabButton) {
                reviewTabButton.style.display = 'none';
            }

            btn.disabled = true;
            btn.textContent = '‚è≥ Generating from SOAP entry...';
            status.className = 'status';
            status.style.background = '#d1ecf1';
            status.style.color = '#0c5460';

            const hasBriefing = generatedBriefing && generatedBriefing.length > 0;

            if (soapEnhanceMode && hasBriefing) {
                status.textContent = 'üîÑ Enhanced mode: Expanding + Adding clinical analysis from briefing...';
            } else if (soapEnhanceMode) {
                status.textContent = 'üîÑ Enhanced mode: Expanding + General clinical analysis...';
            } else {
                status.textContent = 'üîÑ Expand mode: Professional writing only (no added facts)...';
            }

            try {
                let prompt;

                if (soapEnhanceMode) {
                    // ========================================
                    // MODE 2: ENHANCED (Expand + Analysis)
                    // ========================================

                    const pathologyData = selectedPathology ? PathologyDatabase[selectedPathology] : null;
                    const pathologyName = customPathology || (pathologyData ? pathologyData.name : 'General');

                    // Build scale recommendation section if pathology selected
                    let scaleRecommendation = '';
                    if (pathologyData && pathologyData.recommendedScales && pathologyData.recommendedScales.length > 0) {
                        const scaleNames = pathologyData.recommendedScales
                            .map(id => ClinicalScalesDatabase[id]?.shortName || id)
                            .join(', ');
                        scaleRecommendation = `\n## ü§ñ RECOMMENDED CLINICAL SCALES\nFor comprehensive assessment of ${pathologyName}, consider:\n${scaleNames}\n\n(These can be completed in the Clinical Scales tab)`;
                    }

                    prompt = `You are an expert neurosurgical consultant analyzing a clinical case. You will receive:
1. CLINICIAN'S SOAP NOTES (user's documented facts)
2. PRE-CONSULTATION BRIEFING (relevant medical context)

Your task: Generate a comprehensive clinical note that expands the brief SOAP notes AND provides expert clinical analysis.

CRITICAL STRUCTURE REQUIREMENTS:

## SECTION 1: USER'S DOCUMENTED FACTS
Always start with the clinician's documented observations marked as:
üìù DOCUMENTED: [Expand the user's SOAP notes professionally - NO additions, NO inferences]

## SECTION 2: AI-GENERATED EXPERT ANALYSIS
After documented facts, provide expert analysis wrapped in AI_SUGGESTION markers:

<!-- AI_SUGGESTION type="clinical-analysis" id="analysis-001" category="subjective" depends-on="" -->
ü§ñ CLINICAL ANALYSIS:
[Your expert interpretation of symptoms, patterns, temporal relationships]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="differential" id="diff-001" category="assessment" depends-on="analysis-001" -->
ü§ñ DIFFERENTIAL DIAGNOSIS:
1. **Most Likely:** [Diagnosis] - Confidence: High/Moderate/Low
   - Supporting: [specific findings]
   - Against: [contradicting findings]
2. **Alternative:** [Diagnosis] - Confidence: [level]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="red-flag" id="alert-001" category="assessment" depends-on="" -->
‚ö†Ô∏è RED FLAG ALERT:
[Critical findings requiring immediate attention]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="gap-analysis" id="gap-001" category="assessment" depends-on="" -->
ü§ñ CLINICAL GAPS IDENTIFIED:
Missing from history: [list]
Missing from exam: [list]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="workup" id="workup-001" category="plan" depends-on="diff-001" -->
üî¨ RECOMMENDED DIAGNOSTIC WORKUP:
### Imaging:
- [Specific study] - Rationale: [why]
### Laboratory:
- [Specific test] - Rationale: [why]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="recommendation" id="rec-001" category="plan" depends-on="diff-001,workup-001" -->
üíä EVIDENCE-BASED MANAGEMENT PLAN:
### Conservative:
- [Specific intervention] - Evidence: [level]
### Surgical Considerations:
- [If indicated, specific approach]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="scales" id="scales-001" category="objective" depends-on="" -->
üìè CLINICAL SCALES ASSESSMENT:
[Apply relevant scales from briefing - mJOA, Nurick, etc.]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="pearl" id="pearl-001" category="assessment" depends-on="" -->
üí° CLINICAL PEARL:
[Evidence-based insight or teaching point]
üìä Evidence Level: [I/II/III/IV]
<!-- /AI_SUGGESTION -->

MARKER RULES:
1. **Every AI-generated insight MUST be wrapped** in AI_SUGGESTION markers
2. **Use type attribute**: clinical-analysis, differential, recommendation, pearl, red-flag, gap-analysis, workup, scales
3. **Unique ID**: Use format type-### (e.g., diff-001, rec-002)
4. **Category**: subjective, objective, assessment, plan
5. **depends-on**: Comma-separated parent IDs if suggestion builds on others (empty string if independent)
6. **DO NOT wrap** üìù DOCUMENTED sections - only AI additions

${hasBriefing ?
`=== PRE-CONSULTATION BRIEFING ===
${generatedBriefing}

Use this briefing to inform your expert analysis. Check for:
- Completeness of history/exam per briefing checklist
- Red flags identified or ruled out
- Evidence-based workup recommendations
- Pathology-specific management guidelines
` : ''}

CLINICIAN'S SOAP HEADNOTES:

=== SUBJECTIVE ===
${soapQuickEntry.subjective || '[Not documented]'}

=== OBJECTIVE ===
${soapQuickEntry.objective || '[Not documented]'}

=== ASSESSMENT ===
${soapQuickEntry.assessment || '[Not documented]'}

=== PLAN ===
${soapQuickEntry.plan || '[Not documented]'}

---
CONTEXT:
- Consultation Type: ${consultationType === 'followup' ? 'Follow-up Visit' : 'New Consultation'}
- Pathology Context: ${pathologyName}
${hasBriefing ? '- Evidence Base: Pre-consultation briefing available' : ''}

${scaleRecommendation}

ANTI-HALLUCINATION RULES:
‚úÖ Expand user's notes professionally in üìù DOCUMENTED section
‚úÖ Provide expert analysis in marked AI_SUGGESTION blocks
‚úÖ Use briefing/pathology database to inform analysis
‚úÖ Mark all suggestions with proper attributes

‚ùå DO NOT add facts to üìù DOCUMENTED sections
‚ùå DO NOT modify user's observations
‚ùå DO NOT create findings not stated by clinician
‚ùå DO NOT forget to wrap suggestions in markers

Generate the comprehensive clinical note now with proper markers:`;

                } else {
                    // ========================================
                    // MODE 1: EXPAND ONLY (No Analysis)
                    // ========================================

                    prompt = `You are a medical documentation assistant. Your ONLY job is to convert the clinician's brief SOAP headnotes into professionally written clinical documentation.

CRITICAL RULES - WHAT YOU MUST DO:
‚úÖ Convert brief notes into proper medical narrative style
‚úÖ Organize information logically within each SOAP section
‚úÖ Use correct medical terminology and grammar
‚úÖ Expand common abbreviations appropriately (e.g., "x" ‚Üí "for", "F/U" ‚Üí "follow-up")
‚úÖ Maintain professional tone

CRITICAL RULES - WHAT YOU MUST NOT DO:
‚ùå DO NOT add medical facts, symptoms, or findings not stated by clinician
‚ùå DO NOT infer or assume clinical information
‚ùå DO NOT add differential diagnoses unless explicitly stated
‚ùå DO NOT suggest treatments or workup not mentioned
‚ùå DO NOT add physical exam findings not documented
‚ùå DO NOT fabricate history details
‚ùå If a section is empty, note "[Not documented]" - do not add content

CLINICIAN'S HEADNOTES:

=== SUBJECTIVE ===
${soapQuickEntry.subjective || '[Not documented]'}

=== OBJECTIVE ===
${soapQuickEntry.objective || '[Not documented]'}

=== ASSESSMENT ===
${soapQuickEntry.assessment || '[Not documented]'}

=== PLAN ===
${soapQuickEntry.plan || '[Not documented]'}

---
CONSULTATION TYPE: ${consultationType === 'followup' ? 'Follow-up Visit' : 'New Consultation'}

TASK: Expand these notes into professional clinical documentation using standard ${consultationType === 'followup' ? 'follow-up visit' : 'consultation'} format.

${consultationType === 'followup' ?
`For follow-up visits:
- Frame Subjective as "INTERVAL HISTORY" (changes since last visit)
- Focus on treatment response and progression
- Compare to baseline when clinician mentioned it
` :
`For new consultations:
- Use comprehensive SOAP format
- Maintain chronological narrative in HPI
- Organize exam findings systematically
`}

# CLINICAL NOTE

## ${consultationType === 'followup' ? 'INTERVAL HISTORY' : 'SUBJECTIVE / HISTORY'}
[Professional narrative based ONLY on clinician's subjective notes above - expand grammar and organization but add NO new medical facts]

## OBJECTIVE
[Organized examination findings based ONLY on clinician's objective notes above - use proper medical terminology but add NO new findings]

## ASSESSMENT
[Professional impression based ONLY on clinician's assessment notes above - add NO new diagnoses or analysis]

## PLAN
[Organized management plan based ONLY on clinician's plan notes above - add NO new treatments or recommendations]

## ICD-10 CODES
[Only if diagnosis clearly stated in assessment above]

FINAL CHECK:
‚úì Used only information explicitly provided by clinician
‚úì Added no medical facts or clinical reasoning
‚úì Professional language and organization
‚úì Appropriate medical terminology`;
                }

                // Call Gemini API
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: soapEnhanceMode ? 0.4 : 0.2,  // Lower temp for expand-only
                                maxOutputTokens: soapEnhanceMode && hasBriefing ? 12288 : 8192
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';

                // ============================================================
                // PHASE 7: VALIDATION PIPELINE INTEGRATION (SOAP Mode)
                // ============================================================
                // Run 6-layer validation on generated SOAP content
                try {
                    console.log('üîç PHASE 4: VALIDATION PIPELINE (SOAP)');
                    status.textContent = 'üîç Validating generated SOAP note...';
                    status.className = 'status';
                    status.style.background = '#fff3cd';
                    status.style.color = '#856404';

                    // Construct original text from SOAP fields
                    const soapOriginalText = `SUBJECTIVE: ${soapQuickEntry.subjective || '[Not documented]'}\n\nOBJECTIVE: ${soapQuickEntry.objective || '[Not documented]'}\n\nASSESSMENT: ${soapQuickEntry.assessment || '[Not documented]'}\n\nPLAN: ${soapQuickEntry.plan || '[Not documented]'}`;

                    // Create API client wrapper for validation
                    const validationAPIClient = {
                        generateText: async (prompt, options = {}) => {
                            const validationResponse = await fetch(
                                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${API_KEY}`,
                                {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        contents: [{
                                            role: 'user',
                                            parts: [{ text: prompt }]
                                        }],
                                        generationConfig: {
                                            temperature: options.temperature || 0.1,
                                            maxOutputTokens: options.maxOutputTokens || 2048
                                        }
                                    })
                                }
                            );

                            if (!validationResponse.ok) {
                                throw new Error(`Validation API Error ${validationResponse.status}`);
                            }

                            const validationData = await validationResponse.json();
                            return validationData.candidates?.[0]?.content?.parts?.[0]?.text || '';
                        }
                    };

                    // Initialize validation pipeline
                    const validator = new ValidationPipeline(validationAPIClient);

                    // Run complete validation (6 layers)
                    const validationResult = await validator.validateComplete(
                        {}, // extractedData - empty for now
                        soapOriginalText, // original SOAP text
                        {
                            ultrathink: generatedText  // generated SOAP output to validate
                        },
                        {
                            skipSemanticFabrication: false,  // Run all validations
                            detailedGrounding: true
                        }
                    );

                    // Store validation results globally for Validation tab display (Phase 8)
                    lastValidationResult = validationResult;

                    // Log quality score
                    if (validationResult.success && validationResult.validation) {
                        const qualityScore = validationResult.validation.overallScore || 0;
                        console.log(`‚úÖ Validation Complete - Quality Score: ${qualityScore}/100`);
                        console.log('üìä Validation Summary:', {
                            grounding: validationResult.validation.grounding?.score || 'N/A',
                            fabrication: validationResult.validation.fabrication?.score || 'N/A',
                            completeness: validationResult.validation.completeness?.score || 'N/A',
                            consistency: validationResult.validation.consistency?.score || 'N/A',
                            proportionality: validationResult.validation.proportionality?.score || 'N/A',
                            overallScore: qualityScore
                        });

                        // Show quality badge in status (color-coded)
                        let qualityBadge = '';
                        if (qualityScore >= 80) {
                            qualityBadge = 'üü¢ High Quality';
                        } else if (qualityScore >= 60) {
                            qualityBadge = 'üü° Moderate Quality';
                        } else {
                            qualityBadge = 'üî¥ Review Needed';
                        }

                        console.log(`${qualityBadge} (${qualityScore}/100)`);

                        // Display validation results in UI
                        displayValidationResults(validationResult);
                    } else {
                        console.warn('‚ö†Ô∏è Validation completed with warnings or partial results');
                    }
                } catch (validationError) {
                    // Validation failure should not break generation - log and continue
                    console.error('‚ö†Ô∏è Validation pipeline error (non-fatal):', validationError.message);
                    console.error('Stack:', validationError.stack);
                    lastValidationResult = {
                        success: false,
                        error: validationError.message,
                        validation: null
                    };
                }

                output.value = generatedText;
                status.className = 'status connected';

                if (soapEnhanceMode) {
                    status.textContent = '‚úÖ Enhanced SOAP Note Generated!';
                    console.log('‚úÖ SOAP Enhanced mode generation complete');
                } else {
                    status.textContent = '‚úÖ SOAP Note Expanded!';
                    console.log('‚úÖ SOAP Expand-only mode generation complete');
                }

                // Update formatted output tab
                updateFormattedOutput(generatedText);

                // V6: Parse AI suggestions if in enhanced mode
                if (soapEnhanceMode) {
                    currentSuggestions = parseAISuggestions(generatedText);

                    if (currentSuggestions.length > 0) {
                        displayReviewInterface(currentSuggestions);

                        // Show review tab button and switch to it
                        const reviewTabButton = document.getElementById('review-tab-button');
                        if (reviewTabButton) {
                            reviewTabButton.style.display = 'inline-block';
                        }

                        switchTab('review');
                        status.textContent = `‚úÖ Enhanced Note Generated! Review ${currentSuggestions.length} AI suggestions.`;
                        console.log(`üîç ${currentSuggestions.length} suggestions ready for review`);
                    } else {
                        // No suggestions found, show validation tab
                        switchTab('validation');
                    }
                } else {
                    // Expand-only mode: show validation tab
                    switchTab('validation');
                }

                // Auto-generate compressed and ultracompressed summaries
                console.log('üìä Auto-generating compressed and ultracompressed summaries...');

                // Store the full note
                currentNoteVersions.full = generatedText;

                // Generate standard compression (independent)
                currentNoteVersions.status.standard = 'generating';
                updateCompressionStatusBadges();
                try {
                    const standardSummary = await generateAttendingSummary(generatedText);
                    currentNoteVersions.standard = standardSummary || '';
                    currentNoteVersions.status.standard = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Standard compression generated');
                } catch (standardError) {
                    console.error('‚ùå Standard compression failed:', standardError.message);
                    currentNoteVersions.standard = '‚ö†Ô∏è Standard compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.standard = 'failed';
                    updateCompressionStatusBadges();
                }

                // Generate ULTRA compression (independent)
                currentNoteVersions.status.ultra = 'generating';
                updateCompressionStatusBadges();
                try {
                    const ultraSummary = await generateUltraAttendingSummary(generatedText);
                    currentNoteVersions.ultra = ultraSummary || '';
                    currentNoteVersions.status.ultra = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ ULTRA compression generated');
                } catch (ultraError) {
                    console.error('‚ùå ULTRA compression failed:', ultraError.message);
                    currentNoteVersions.ultra = '‚ö†Ô∏è ULTRA compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.ultra = 'failed';
                    updateCompressionStatusBadges();
                }

                // Generate Telegram compression (independent)
                currentNoteVersions.status.telegram = 'generating';
                updateCompressionStatusBadges();
                try {
                    const telegramSummary = await generateTelegramSummary(generatedText);
                    currentNoteVersions.telegram = telegramSummary || '';
                    currentNoteVersions.status.telegram = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Telegram compression generated');
                } catch (telegramError) {
                    console.error('‚ùå Telegram compression failed:', telegramError.message);
                    currentNoteVersions.telegram = '‚ö†Ô∏è Telegram compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.telegram = 'failed';
                    updateCompressionStatusBadges();
                }

                // Display based on currently selected compression mode
                const selectedMode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
                const summaryToDisplay = selectedMode === 'ultra' ? currentNoteVersions.ultra
                                       : selectedMode === 'telegram' ? currentNoteVersions.telegram
                                       : currentNoteVersions.standard;

                if (summaryToDisplay && !summaryToDisplay.includes('failed')) {
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else if (summaryToDisplay) {
                    // Show error message in textarea
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else {
                    console.warn('‚ö†Ô∏è No summary generated');
                }

            } catch (error) {
                console.error('‚ùå SOAP generation error:', error);
                output.value = `‚ùå Error: ${error.message}`;
                status.className = 'status disconnected';
                status.textContent = '‚ùå Generation Failed';
                alert(`SOAP generation failed: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.textContent = '‚ö° Generate Clinical Note';
            }
        }

        function copyOutput() {
            const output = document.getElementById('output');
            output.select();
            document.execCommand('copy');
            alert('‚úÖ Copied to clipboard!');
        }

        function downloadOutput() {
            const text = document.getElementById('output').value;
            if (!text) {
                alert('No content to download');
                return;
            }

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Tab Navigation Functions
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Find and activate the correct tab button
            const targetButton = document.getElementById(`${tabName}-tab-button`) ||
                                 document.querySelector(`button[onclick*="switchTab('${tabName}')"]`);
            if (targetButton) {
                targetButton.classList.add('active');
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = ''; // Clear inline display style
            });

            const targetTab = document.getElementById(`tab-${tabName}`);
            if (targetTab) {
                targetTab.classList.add('active');
                targetTab.style.display = 'block'; // Force display with inline style
            } else {
                console.error(`‚ùå Tab not found: tab-${tabName}`);
            }
        }

        function copyFormatted() {
            const formattedText = document.getElementById('formattedOutput').innerText;
            if (!formattedText || formattedText.includes('Generate documentation')) {
                alert('No content to copy');
                return;
            }
            navigator.clipboard.writeText(formattedText);
            alert('‚úÖ Copied formatted text to clipboard!');
        }

        function printFormatted() {
            const content = document.getElementById('formattedOutput').innerHTML;
            if (!content || content.includes('Generate documentation')) {
                alert('No content to print');
                return;
            }

            const printWindow = window.open('', '', 'width=800,height=600');
            printWindow.document.write(`
                <html>
                <head>
                    <title>Clinical Note</title>
                    <style>
                        body { font-family: Georgia, serif; line-height: 1.6; padding: 40px; }
                        h1 { color: #333; border-bottom: 2px solid #0066CC; padding-bottom: 10px; }
                        h2 { color: #0066CC; margin-top: 20px; }
                        h3 { color: #333; margin-top: 15px; }
                    </style>
                </head>
                <body>${content}</body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        }

        function doExport() {
            const format = document.getElementById('exportFormat').value;
            const includes = document.getElementById('exportIncludes').value;
            const rawText = document.getElementById('output').value;

            if (!rawText) {
                alert('No content to export. Generate documentation first.');
                return;
            }

            let content = rawText;

            // Filter content based on selection
            if (includes === 'summary') {
                // Extract summary sections only
                const sections = ['CHIEF COMPLAINT', 'HISTORY OF PRESENT ILLNESS', 'ASSESSMENT'];
                content = extractSections(rawText, sections);
            } else if (includes === 'plan') {
                // Extract assessment and plan only
                const sections = ['ASSESSMENT', 'PLAN', 'ICD-10'];
                content = extractSections(rawText, sections);
            }

            // Export based on format
            switch (format) {
                case 'txt':
                    downloadAsText(content);
                    break;
                case 'html':
                    downloadAsHTML(content);
                    break;
                case 'json':
                    downloadAsJSON(content);
                    break;
                case 'docx':
                    alert('DOCX export requires additional library. Use HTML or TXT for now.');
                    break;
                case 'pdf':
                    alert('PDF export requires additional library. Use Print to PDF from browser for now.');
                    break;
            }
        }

        function extractSections(text, sectionNames) {
            let result = '';
            const lines = text.split('\n');
            let capturing = false;

            for (const line of lines) {
                const isHeader = sectionNames.some(section => line.includes(section));
                if (isHeader) {
                    capturing = true;
                }
                if (capturing) {
                    result += line + '\n';
                }
            }

            return result || text;
        }

        function downloadAsText(content) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadAsHTML(content) {
            const html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Clinical Note</title>
    <style>
        body { font-family: Georgia, serif; line-height: 1.6; max-width: 800px; margin: 40px auto; padding: 20px; }
        h1 { color: #333; border-bottom: 2px solid #0066CC; padding-bottom: 10px; }
        h2 { color: #0066CC; margin-top: 20px; }
        h3 { color: #333; margin-top: 15px; }
        pre { white-space: pre-wrap; font-family: inherit; }
    </style>
</head>
<body>
    <pre>${content}</pre>
</body>
</html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadAsJSON(content) {
            // Prepare scale data for export
            const scaleData = {};
            for (const scaleId in calculatedScores) {
                const score = calculatedScores[scaleId];
                const scale = ClinicalScalesDatabase[scaleId];
                if (scale) {
                    scaleData[scaleId] = {
                        scaleName: scale.name,
                        shortName: scale.shortName,
                        score: score,
                        responses: scaleResponses[scaleId] || {},
                        interpretation: scale.interpretation ?
                            (scaleId === 'ndi' || scaleId === 'odi' ? scale.interpretation(score.percentage) :
                             scaleId === 'vas_pain' ? scale.interpretation(score.overallAverage) :
                             scale.interpretation(score.total)) : null,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            const jsonData = {
                timestamp: new Date().toISOString(),
                generatedBy: 'NeuroScribe V7 - Professional Clinical Intelligence',
                pathology: selectedPathology,
                briefingUsed: briefingUsed,
                clinicalNote: content,
                wordCount: content.split(/\s+/).length,
                clinicalScales: scaleData,
                scalesSummary: {
                    totalScalesCompleted: Object.keys(calculatedScores).length,
                    scalesAssessed: Object.keys(calculatedScores)
                }
            };

            const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function updateFormattedOutput(markdown) {
            // Convert markdown to HTML with enhanced clinical highlighting
            let html = markdown
                .replace(/^# (.+)$/gm, '<h1>$1</h1>')
                .replace(/^## (.+)$/gm, '<h2>$1</h2>')
                .replace(/^### (.+)$/gm, '<h3>$1</h3>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')

                // Highlight expert analysis sections (V5 specific)
                .replace(/## üìã BRIEFING-TRANSCRIPT INTEGRATION ANALYSIS/gi,
                    '<h2 style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üìã BRIEFING-TRANSCRIPT INTEGRATION ANALYSIS</h2>')

                .replace(/## üéØ EXPERT DIFFERENTIAL DIAGNOSIS/gi,
                    '<h2 style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üéØ EXPERT DIFFERENTIAL DIAGNOSIS</h2>')

                .replace(/## üí° ASSESSMENT & SYNTHESIS/gi,
                    '<h2 style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üí° ASSESSMENT & SYNTHESIS</h2>')

                .replace(/## üìä QUALITY METRICS/gi,
                    '<h2 style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üìä QUALITY METRICS</h2>')

                // Highlight clinical pearls
                .replace(/üíé CLINICAL PEARL:([^<\n]+)/gi,
                    '<div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin: 10px 0; border-radius: 4px;"><strong>üíé CLINICAL PEARL:</strong>$1</div>')

                // Highlight red flags
                .replace(/‚ö†Ô∏è RED FLAG:([^<\n]+)/gi,
                    '<div style="background: #f8d7da; border-left: 4px solid #dc3545; padding: 10px; margin: 10px 0; border-radius: 4px;"><strong>‚ö†Ô∏è RED FLAG:</strong>$1</div>')

                // Highlight evidence levels
                .replace(/üìä Level (I{1,3}|IV|V) Evidence:([^<\n]+)/gi,
                    '<div style="background: #d1ecf1; border-left: 4px solid #0c5460; padding: 8px; margin: 8px 0; border-radius: 4px; font-size: 0.95rem;"><strong>üìä Level $1 Evidence:</strong>$2</div>')

                // Highlight confidence levels
                .replace(/Confidence level: (High|Medium|Low)/gi,
                    '<span style="background: #e3f2fd; padding: 4px 8px; border-radius: 4px; font-weight: 600; color: #0066CC;">Confidence: $1</span>')

                .replace(/\n/g, '<br>');

            document.getElementById('formattedOutput').innerHTML = html;
        }

        // ============================================================
        // EXPERT DOCUMENT UPLOAD FUNCTIONS
        // ============================================================

        async function handleDocumentUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            const uploadedDocsDiv = document.getElementById('uploadedDocs');
            uploadedDocsDiv.innerHTML = '<div style="color: #0066CC;">üì§ Processing documents...</div>';

            try {
                let duplicateCount = 0;
                let skippedCount = 0;

                for (const file of files) {
                    console.log(`üìÑ Processing: ${file.name}`);
                    const text = await readFileContent(file);

                    if (text && text.trim().length > 0) {
                        // Check for duplicates
                        if (isDuplicateDocument(file, text)) {
                            duplicateCount++;
                            console.warn(`‚ö†Ô∏è Duplicate detected: ${file.name}`);
                            continue;
                        }

                        // Check storage limit before adding
                        const currentSize = getDocumentStorageSize();
                        const newContentSize = text.length;
                        const limit = getStorageLimit();

                        if (currentSize + newContentSize > limit) {
                            const percentUsed = Math.round(((currentSize + newContentSize) / limit) * 100);
                            alert(`‚ö†Ô∏è Storage Limit Warning!\n\nAdding "${file.name}" would exceed storage capacity (${percentUsed}%).\n\nPlease delete some existing documents before uploading new ones.`);
                            skippedCount++;
                            console.warn(`‚ö†Ô∏è Skipped due to storage limit: ${file.name}`);
                            continue;
                        }

                        // Warn if approaching limit (>80%)
                        if ((currentSize + newContentSize) / limit > 0.8) {
                            const percentUsed = Math.round(((currentSize + newContentSize) / limit) * 100);
                            if (!confirm(`‚ö†Ô∏è Storage Warning\n\nYou are using ${percentUsed}% of available storage.\n\nContinue uploading "${file.name}"?`)) {
                                skippedCount++;
                                continue;
                            }
                        }

                        uploadedDocuments.push({
                            name: file.name,
                            content: text,
                            size: file.size,
                            type: file.type,
                            timestamp: new Date().toISOString()
                        });

                        console.log(`‚úÖ Loaded: ${file.name} (${text.length} chars)`);
                    } else {
                        console.warn(`‚ö†Ô∏è Empty or unreadable: ${file.name}`);
                        skippedCount++;
                    }
                }

                // Combine all document texts
                uploadedDocText = uploadedDocuments.map(doc =>
                    `\n=== ${doc.name} ===\n${doc.content}\n`
                ).join('\n');

                // Save to localStorage
                saveUploadedDocumentsToStorage();

                // Update UI
                updateUploadedDocsList();
                updateDocumentStorageUI();

                // Show summary
                let summary = `‚úÖ Total documents loaded: ${uploadedDocuments.length}`;
                if (duplicateCount > 0) {
                    summary += `\n‚ö†Ô∏è ${duplicateCount} duplicate(s) skipped`;
                }
                if (skippedCount > 0) {
                    summary += `\n‚ö†Ô∏è ${skippedCount} file(s) skipped`;
                }

                console.log(summary);
                console.log(`üìä Total text content: ${uploadedDocText.length} characters`);

            } catch (error) {
                console.error('‚ùå Error processing documents:', error);
                uploadedDocsDiv.innerHTML = `<div style="color: #dc2626;">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = (e) => {
                    try {
                        const content = e.target.result;

                        // Handle different file types
                        if (file.type === 'application/pdf') {
                            // For PDF, we can only read text if it's text-based PDF
                            // In a full implementation, you'd use pdf.js library
                            resolve('[PDF content - Note: Full PDF parsing requires pdf.js library. Please convert to TXT for best results.]');
                        } else {
                            // Text files, Word docs as text, etc.
                            resolve(content);
                        }
                    } catch (error) {
                        reject(error);
                    }
                };

                reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));

                // Read as text
                if (file.type.includes('text') || file.name.endsWith('.txt') || file.name.endsWith('.md')) {
                    reader.readAsText(file);
                } else if (file.type.includes('pdf')) {
                    resolve('[PDF Upload - Please convert to .TXT format for full text extraction, or paste content manually into Custom Pathology field]');
                } else {
                    // Try reading as text anyway
                    reader.readAsText(file);
                }
            });
        }

        function updateUploadedDocsList() {
            const uploadedDocsDiv = document.getElementById('uploadedDocs');

            if (uploadedDocuments.length === 0) {
                uploadedDocsDiv.innerHTML = '';
                return;
            }

            let html = '<div style="background: #e3f2fd; padding: 10px; border-radius: 6px; margin-top: 10px;">';
            html += `<strong>‚úÖ ${uploadedDocuments.length} document(s) loaded:</strong><br>`;

            uploadedDocuments.forEach((doc, index) => {
                const sizeKB = (doc.size / 1024).toFixed(1);
                html += `<div style="margin-top: 5px; padding: 5px; background: white; border-radius: 4px;">`;
                html += `üìÑ ${doc.name} (${sizeKB} KB)`;
                html += `<button onclick="removeDocument(${index})" style="float: right; padding: 2px 8px; font-size: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 3px; cursor: pointer;">‚úï</button>`;
                html += `</div>`;
            });

            html += `<div style="margin-top: 8px; font-size: 0.75rem; color: #666;">`;
            html += `Total content: ${(uploadedDocText.length / 1024).toFixed(1)} KB`;
            html += `</div>`;
            html += '</div>';

            uploadedDocsDiv.innerHTML = html;
        }

        function removeDocument(index) {
            if (confirm(`Remove ${uploadedDocuments[index].name}?`)) {
                uploadedDocuments.splice(index, 1);

                // Rebuild combined text
                uploadedDocText = uploadedDocuments.map(doc =>
                    `\n=== ${doc.name} ===\n${doc.content}\n`
                ).join('\n');

                // Save to localStorage
                saveUploadedDocumentsToStorage();

                // Update UI
                updateUploadedDocsList();
                updateDocumentStorageUI();

                console.log(`üóëÔ∏è Document removed. Remaining: ${uploadedDocuments.length}`);
            }
        }

        function clearAllDocuments() {
            if (confirm('Clear all uploaded documents? This will remove them from storage permanently.')) {
                uploadedDocuments = [];
                uploadedDocText = '';
                document.getElementById('expertDocUpload').value = '';
                localStorage.removeItem('neuroscribe_uploaded_documents');
                updateUploadedDocsList();
                updateDocumentStorageUI();
                console.log('üóëÔ∏è All documents cleared from memory and storage');
            }
        }

        // ============================================================
        // DOCUMENT PERSISTENCE FUNCTIONS
        // ============================================================

        /**
         * Save uploaded documents to localStorage
         */
        function saveUploadedDocumentsToStorage() {
            try {
                const dataToSave = {
                    documents: uploadedDocuments,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('neuroscribe_uploaded_documents', JSON.stringify(dataToSave));
                console.log(`‚úÖ ${uploadedDocuments.length} document(s) saved to localStorage`);
                return true;
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    alert('‚ö†Ô∏è Storage limit reached! Please delete some documents before uploading new ones.');
                    console.error('‚ùå Storage quota exceeded');
                } else {
                    console.error('‚ùå Error saving documents:', error);
                }
                return false;
            }
        }

        /**
         * Load uploaded documents from localStorage
         */
        function loadUploadedDocumentsFromStorage() {
            try {
                const saved = localStorage.getItem('neuroscribe_uploaded_documents');
                if (saved) {
                    const data = JSON.parse(saved);
                    uploadedDocuments = data.documents || [];

                    // Rebuild combined text
                    uploadedDocText = uploadedDocuments.map(doc =>
                        `\n=== ${doc.name} ===\n${doc.content}\n`
                    ).join('\n');

                    updateUploadedDocsList();
                    updateDocumentStorageUI();

                    console.log(`‚úÖ ${uploadedDocuments.length} document(s) loaded from localStorage (saved: ${data.timestamp})`);
                    return true;
                }
            } catch (error) {
                console.error('‚ùå Error loading documents:', error);
            }
            return false;
        }

        /**
         * Check if a document is a duplicate
         */
        function isDuplicateDocument(file, content) {
            return uploadedDocuments.some(doc =>
                doc.name === file.name &&
                doc.size === file.size &&
                doc.content.substring(0, 100) === content.substring(0, 100)
            );
        }

        /**
         * Calculate total storage used by documents
         */
        function getDocumentStorageSize() {
            const totalBytes = uploadedDocuments.reduce((sum, doc) => sum + doc.content.length, 0);
            return totalBytes;
        }

        /**
         * Get estimated storage limit (5 MB)
         */
        function getStorageLimit() {
            return 5 * 1024 * 1024; // 5 MB in bytes
        }

        /**
         * Update document storage UI showing usage and list
         */
        function updateDocumentStorageUI() {
            const storageUIDiv = document.getElementById('documentStorageUI');
            if (!storageUIDiv) return;

            const totalSize = getDocumentStorageSize();
            const limit = getStorageLimit();
            const percentUsed = Math.round((totalSize / limit) * 100);
            const totalMB = (totalSize / (1024 * 1024)).toFixed(2);
            const limitMB = (limit / (1024 * 1024)).toFixed(0);

            let html = '<div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #0066CC;">';
            html += '<strong>üì¶ Document Storage</strong><br>';
            html += `<div style="margin-top: 8px; font-size: 0.85rem;">`;
            html += `Storage used: ${totalMB} MB / ${limitMB} MB (${percentUsed}%)`;

            // Storage bar
            const barColor = percentUsed > 80 ? '#dc2626' : percentUsed > 60 ? '#f59e0b' : '#10b981';
            html += `<div style="margin-top: 5px; background: #e5e7eb; border-radius: 3px; height: 8px; overflow: hidden;">`;
            html += `<div style="background: ${barColor}; height: 100%; width: ${Math.min(percentUsed, 100)}%;"></div>`;
            html += `</div>`;
            html += `</div>`;

            if (uploadedDocuments.length > 0) {
                html += '<div style="margin-top: 12px; max-height: 200px; overflow-y: auto;">';
                html += '<strong style="font-size: 0.85rem;">Stored Documents:</strong><br>';

                uploadedDocuments.forEach((doc, index) => {
                    const sizeKB = (doc.size / 1024).toFixed(1);
                    const uploadDate = new Date(doc.timestamp).toLocaleDateString();
                    html += `<div style="margin-top: 6px; padding: 6px; background: white; border-radius: 4px; font-size: 0.8rem; display: flex; justify-content: space-between; align-items: center;">`;
                    html += `<div>üìÑ ${doc.name}<br><span style="color: #666; font-size: 0.75rem;">${sizeKB} KB ‚Ä¢ ${uploadDate}</span></div>`;
                    html += `<button onclick="removeDocument(${index})" style="padding: 4px 10px; font-size: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>`;
                    html += `</div>`;
                });

                html += '</div>';

                html += `<div style="margin-top: 10px;">`;
                html += `<button onclick="clearAllDocuments()" style="padding: 6px 12px; font-size: 0.8rem; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer;">üóëÔ∏è Clear All Documents</button>`;
                html += `</div>`;
            } else {
                html += '<div style="margin-top: 8px; font-size: 0.8rem; color: #666;">No documents stored</div>';
            }

            html += '</div>';
            storageUIDiv.innerHTML = html;
        }

        // ============================================================
        // SOAP QUICK-ENTRY FUNCTIONS
        // ============================================================

        /**
         * Toggle SOAP enhancement mode
         */
        function toggleSOAPEnhancement() {
            soapEnhanceMode = document.getElementById('soapEnhanceToggle').checked;
            console.log(`ü§ñ SOAP Enhancement mode: ${soapEnhanceMode ? 'ON (Expand + Analysis)' : 'OFF (Expand Only)'}`);

            // Update mode stat display
            document.getElementById('soapMode').textContent = soapEnhanceMode ? 'Enhanced' : 'Expand';

            // Show/hide enhancement warning
            const hasBriefing = generatedBriefing && generatedBriefing.length > 0;
            const hasPathology = selectedPathology || customPathology;

            if (soapEnhanceMode && !hasBriefing && !hasPathology) {
                document.getElementById('enhanceWarning').style.display = 'block';
            } else {
                document.getElementById('enhanceWarning').style.display = 'none';
            }
        }

        /**
         * Toggle Transcript enhancement mode
         */
        function toggleTranscriptEnhancement() {
            transcriptEnhanceMode = document.getElementById('transcriptEnhanceToggle').checked;
            console.log(`ü§ñ Transcript Enhancement mode: ${transcriptEnhanceMode ? 'ON (Briefing Integration)' : 'OFF (Expand Only)'}`);
        }

        /**
         * Update enhancement toggles based on briefing availability
         */
        function updateEnhancementToggles() {
            const hasBriefing = generatedBriefing && generatedBriefing.length > 0;

            // Update Transcript toggle
            const transcriptToggle = document.getElementById('transcriptEnhanceToggle');
            const transcriptWarning = document.getElementById('transcriptEnhanceWarning');
            const transcriptLabel = document.getElementById('transcriptEnhanceLabel');

            if (transcriptToggle) {
                transcriptToggle.disabled = !hasBriefing;
                transcriptLabel.style.cursor = hasBriefing ? 'pointer' : 'not-allowed';
                transcriptLabel.style.opacity = hasBriefing ? '1' : '0.6';

                if (hasBriefing) {
                    transcriptWarning.style.display = 'none';
                } else {
                    transcriptWarning.style.display = 'block';
                    transcriptToggle.checked = false;
                    transcriptEnhanceMode = false;
                }
            }

            // Update SOAP toggle
            const soapToggle = document.getElementById('soapEnhanceToggle');
            const soapWarning = document.getElementById('enhanceWarning');

            if (soapToggle) {
                soapToggle.disabled = !hasBriefing;

                // Update parent label styling
                const soapLabel = soapToggle.closest('label');
                if (soapLabel) {
                    soapLabel.style.cursor = hasBriefing ? 'pointer' : 'not-allowed';
                    soapLabel.style.opacity = hasBriefing ? '1' : '0.6';
                }

                if (hasBriefing) {
                    soapWarning.style.display = 'none';
                } else {
                    soapWarning.innerHTML = 'üí° <strong>Note:</strong> Generate a briefing first to enable Enhanced Mode';
                    soapWarning.style.display = 'block';
                    soapToggle.checked = false;
                    soapEnhanceMode = false;
                }
            }

            console.log(`üîÑ Enhancement toggles updated: ${hasBriefing ? 'ENABLED' : 'DISABLED'}`);
        }

        /**
         * =====================================================
         * V6 INTERACTIVE REVIEW SYSTEM - Parser & UI Functions
         * =====================================================
         */

        /**
         * Parse AI suggestions from generated note
         * @param {string} noteText - The generated note containing AI_SUGGESTION markers
         * @returns {Array} Array of suggestion objects
         */
        function parseAISuggestions(noteText) {
            const suggestions = [];
            const regex = /<!-- AI_SUGGESTION (.*?) -->([\s\S]*?)<!-- \/AI_SUGGESTION -->/g;
            let match;
            let index = 0;

            while ((match = regex.exec(noteText)) !== null) {
                const attrs = match[1];
                const content = match[2].trim();

                // Parse attributes
                const typeMatch = attrs.match(/type="([^"]+)"/);
                const idMatch = attrs.match(/id="([^"]+)"/);
                const categoryMatch = attrs.match(/category="([^"]+)"/);
                const dependsMatch = attrs.match(/depends-on="([^"]*)"/);

                suggestions.push({
                    id: idMatch ? idMatch[1] : `ai-${index}`,
                    type: typeMatch ? typeMatch[1] : 'unknown',
                    category: categoryMatch ? categoryMatch[1] : 'general',
                    dependsOn: dependsMatch && dependsMatch[1] ? dependsMatch[1].split(',').map(d => d.trim()).filter(d => d) : [],
                    content: content,
                    startPos: match.index,
                    endPos: match.index + match[0].length,
                    fullMatch: match[0],
                    kept: true  // Default to keeping suggestions
                });
                index++;
            }

            console.log(`üìä Parsed ${suggestions.length} AI suggestions`);
            return suggestions;
        }

        /**
         * Display suggestions in review interface
         * @param {Array} suggestions - Array of parsed suggestions
         */
        function displayReviewInterface(suggestions) {
            const container = document.getElementById('reviewInterface');

            if (!container) {
                console.error('‚ùå Review interface container not found');
                return;
            }

            if (suggestions.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; padding: 20px; font-style: italic;">No AI suggestions found in this note. The note contains only documented facts.</p>';
                return;
            }

            // Group by category
            const grouped = {
                subjective: [],
                objective: [],
                assessment: [],
                plan: [],
                general: []
            };

            suggestions.forEach(s => {
                if (grouped[s.category]) {
                    grouped[s.category].push(s);
                } else {
                    grouped.general.push(s);
                }
            });

            let html = '';

            // Render each category
            Object.keys(grouped).forEach(category => {
                if (grouped[category].length === 0) return;

                const categoryTitle = category.charAt(0).toUpperCase() + category.slice(1);
                html += `<div class="suggestion-category" style="margin-bottom: 25px;">`;
                html += `<h3 style="color: #4A90E2; font-size: 1.1rem; margin-bottom: 12px; font-weight: 600;">${categoryTitle} Section</h3>`;

                grouped[category].forEach(suggestion => {
                    const typeLabel = getSuggestionTypeLabel(suggestion.type);
                    const icon = getSuggestionIcon(suggestion.type);
                    const hasDeps = suggestion.dependsOn.length > 0;

                    html += `
                    <div class="suggestion-item" style="background: #f9fafb; border: 1px solid #E1E4E8; border-radius: 6px; padding: 14px; margin-bottom: 12px; transition: all 0.2s;">
                        <label style="display: flex; align-items: start; cursor: pointer; user-select: none;">
                            <input type="checkbox"
                                   id="suggestion-${suggestion.id}"
                                   data-suggestion-id="${suggestion.id}"
                                   onchange="toggleSuggestion('${suggestion.id}')"
                                   ${suggestion.kept ? 'checked' : ''}
                                   style="margin-right: 12px; margin-top: 4px; width: 18px; height: 18px; cursor: pointer; flex-shrink: 0; accent-color: #4A90E2;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: #24292e; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                                    <span>${icon} ${typeLabel}</span>
                                    ${hasDeps ? '<span style="font-size: 0.75rem; color: #6a737d; font-weight: normal; background: #fff; padding: 2px 6px; border-radius: 3px; border: 1px solid #e1e4e8;">üîó linked</span>' : ''}
                                </div>
                                <div style="background: white; padding: 12px; border-radius: 4px; border: 1px solid #e1e4e8; white-space: pre-wrap; font-size: 0.9rem; line-height: 1.6; color: #24292e; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;">
${escapeHtml(suggestion.content)}</div>
                            </div>
                        </label>
                    </div>`;
                });

                html += `</div>`;
            });

            container.innerHTML = html;
            console.log(`‚úÖ Review interface displayed with ${suggestions.length} suggestions`);
        }

        /**
         * Get human-readable label for suggestion type
         * @param {string} type - Suggestion type code
         * @returns {string} Human-readable label
         */
        function getSuggestionTypeLabel(type) {
            const labels = {
                'clinical-analysis': 'Clinical Analysis',
                'differential': 'Differential Diagnosis',
                'recommendation': 'Management Recommendation',
                'pearl': 'Clinical Pearl',
                'red-flag': 'Red Flag Alert',
                'gap-analysis': 'Clinical Gaps Identified',
                'evidence': 'Evidence-Based Analysis',
                'workup': 'Diagnostic Workup',
                'scales': 'Clinical Scales Assessment'
            };
            return labels[type] || type.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        /**
         * Get icon for suggestion type
         * @param {string} type - Suggestion type code
         * @returns {string} Emoji icon
         */
        function getSuggestionIcon(type) {
            const icons = {
                'clinical-analysis': 'ü§ñ',
                'differential': 'üéØ',
                'recommendation': 'üíä',
                'pearl': 'üíé',
                'red-flag': '‚ö†Ô∏è',
                'gap-analysis': 'üìã',
                'evidence': 'üìä',
                'workup': 'üî¨',
                'scales': 'üìè'
            };
            return icons[type] || 'üìù';
        }

        /**
         * Escape HTML special characters
         * @param {string} text - Text to escape
         * @returns {string} Escaped text
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * =====================================================
         * V6 INTERACTIVE REVIEW SYSTEM - Interaction Logic
         * =====================================================
         */

        /**
         * Toggle a suggestion on/off
         * @param {string} id - Suggestion ID
         */
        function toggleSuggestion(id) {
            const checkbox = document.getElementById(`suggestion-${id}`);
            const suggestion = currentSuggestions.find(s => s.id === id);

            if (!suggestion) {
                console.error(`‚ùå Suggestion ${id} not found`);
                return;
            }

            suggestion.kept = checkbox.checked;
            console.log(`${suggestion.kept ? '‚úÖ KEPT' : '‚ùå DISCARDED'}: ${getSuggestionTypeLabel(suggestion.type)} (${id})`);

            // Smart dependencies - ask about related items when discarding
            if (!suggestion.kept) {
                handleDependencies(id);
            }
        }

        /**
         * Handle smart dependencies when discarding a suggestion
         * @param {string} parentId - ID of the suggestion being discarded
         */
        function handleDependencies(parentId) {
            // Find suggestions that depend on this one
            const dependents = currentSuggestions.filter(s =>
                s.dependsOn.includes(parentId) && s.kept
            );

            if (dependents.length === 0) return;

            // Build list of dependent items
            const dependentNames = dependents.map(d =>
                `‚Ä¢ ${getSuggestionIcon(d.type)} ${getSuggestionTypeLabel(d.type)}`
            ).join('\n');

            const shouldDiscard = confirm(
                `‚ö†Ô∏è LINKED SUGGESTIONS DETECTED\n\n` +
                `The following ${dependents.length} suggestion(s) depend on the item you just discarded:\n\n` +
                `${dependentNames}\n\n` +
                `Would you like to also discard these related items?\n\n` +
                `Click OK to discard related items, or Cancel to keep them.`
            );

            if (shouldDiscard) {
                dependents.forEach(dep => {
                    dep.kept = false;
                    const checkbox = document.getElementById(`suggestion-${dep.id}`);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                    console.log(`üîó Auto-discarded dependent: ${dep.id}`);
                });

                console.log(`‚úÖ Discarded ${dependents.length} dependent suggestion(s)`);
            } else {
                console.log(`‚ÑπÔ∏è Kept ${dependents.length} dependent suggestion(s)`);
            }
        }

        /**
         * Select all suggestions (check all checkboxes)
         */
        function selectAllSuggestions() {
            if (currentSuggestions.length === 0) {
                alert('‚ÑπÔ∏è No suggestions to select. Generate a note with Enhanced Mode first.');
                return;
            }

            currentSuggestions.forEach(s => {
                s.kept = true;
                const checkbox = document.getElementById(`suggestion-${s.id}`);
                if (checkbox) checkbox.checked = true;
            });

            console.log(`‚úÖ All ${currentSuggestions.length} suggestions kept`);
        }

        /**
         * Deselect all suggestions (uncheck all checkboxes)
         */
        function deselectAllSuggestions() {
            if (currentSuggestions.length === 0) {
                alert('‚ÑπÔ∏è No suggestions to deselect.');
                return;
            }

            const confirmed = confirm(
                `‚ö†Ô∏è DISCARD ALL SUGGESTIONS?\n\n` +
                `This will remove all ${currentSuggestions.length} AI-generated suggestions from your final note.\n\n` +
                `Only your documented facts will remain.\n\n` +
                `Click OK to discard all, or Cancel to keep them.`
            );

            if (!confirmed) return;

            currentSuggestions.forEach(s => {
                s.kept = false;
                const checkbox = document.getElementById(`suggestion-${s.id}`);
                if (checkbox) checkbox.checked = false;
            });

            console.log(`‚ùå All ${currentSuggestions.length} suggestions discarded`);
        }

        /**
         * =====================================================
         * V6 INTERACTIVE REVIEW SYSTEM - Final Note Generator
         * =====================================================
         */

        /**
         * Generate final clean note with only kept suggestions
         */
        async function generateFinalNote() {
            if (currentSuggestions.length === 0) {
                alert('‚ÑπÔ∏è No suggestions to process. This note contains only documented facts and is already finalized.');
                return;
            }

            console.log('üìÑ Generating final clean note...');

            // Get the raw generated note
            const rawNote = document.getElementById('output').value;
            if (!rawNote) {
                alert('‚ùå No note content found. Please generate a note first.');
                return;
            }

            let finalNote = rawNote;

            // Count kept vs discarded
            const keptCount = currentSuggestions.filter(s => s.kept).length;
            const discardedCount = currentSuggestions.length - keptCount;

            console.log(`üìä Processing: ${keptCount} kept, ${discardedCount} discarded`);

            // Remove all AI_SUGGESTION markers and their content
            currentSuggestions.forEach(suggestion => {
                if (suggestion.kept) {
                    // Keep the content but remove the markers
                    finalNote = finalNote.replace(
                        suggestion.fullMatch,
                        suggestion.content
                    );
                } else {
                    // Remove entirely (markers + content)
                    finalNote = finalNote.replace(suggestion.fullMatch, '');
                }
            });

            // Clean up formatting
            finalNote = cleanFinalNote(finalNote);

            // Display in new tab
            displayFinalNote(finalNote, keptCount, discardedCount);

            // Generate ALL compression levels automatically from final note
            console.log('üìä Auto-generating compressed and ultracompressed summaries...');

            // Store the full note
            currentNoteVersions.full = finalNote;

            // Generate standard compression (independent)
            currentNoteVersions.status.standard = 'generating';
            updateCompressionStatusBadges();
            try {
                const standardSummary = await generateAttendingSummary(finalNote);
                currentNoteVersions.standard = standardSummary || '';
                currentNoteVersions.status.standard = 'ready';
                updateCompressionStatusBadges();
                console.log('‚úÖ Standard compression generated');
            } catch (standardError) {
                console.error('‚ùå Standard compression failed:', standardError.message);
                currentNoteVersions.standard = '‚ö†Ô∏è Standard compression failed. Click "Regenerate" to retry.';
                currentNoteVersions.status.standard = 'failed';
                updateCompressionStatusBadges();
            }

            // Generate ULTRA compression (independent)
            currentNoteVersions.status.ultra = 'generating';
            updateCompressionStatusBadges();
            try {
                const ultraSummary = await generateUltraAttendingSummary(finalNote);
                currentNoteVersions.ultra = ultraSummary || '';
                currentNoteVersions.status.ultra = 'ready';
                updateCompressionStatusBadges();
                console.log('‚úÖ ULTRA compression generated');
            } catch (ultraError) {
                console.error('‚ùå ULTRA compression failed:', ultraError.message);
                currentNoteVersions.ultra = '‚ö†Ô∏è ULTRA compression failed. Click "Regenerate" to retry.';
                currentNoteVersions.status.ultra = 'failed';
                updateCompressionStatusBadges();
            }

            // Generate Telegram compression (independent)
            currentNoteVersions.status.telegram = 'generating';
            updateCompressionStatusBadges();
            try {
                const telegramSummary = await generateTelegramSummary(finalNote);
                currentNoteVersions.telegram = telegramSummary || '';
                currentNoteVersions.status.telegram = 'ready';
                updateCompressionStatusBadges();
                console.log('‚úÖ Telegram compression generated');
            } catch (telegramError) {
                console.error('‚ùå Telegram compression failed:', telegramError.message);
                currentNoteVersions.telegram = '‚ö†Ô∏è Telegram compression failed. Click "Regenerate" to retry.';
                currentNoteVersions.status.telegram = 'failed';
                updateCompressionStatusBadges();
            }

            // Display based on currently selected compression mode
            const selectedMode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
            const summaryToDisplay = selectedMode === 'ultra' ? currentNoteVersions.ultra
                                   : selectedMode === 'telegram' ? currentNoteVersions.telegram
                                   : currentNoteVersions.standard;

            if (summaryToDisplay && !summaryToDisplay.includes('failed')) {
                displayAttendingSummary(summaryToDisplay, selectedMode);
            } else if (summaryToDisplay) {
                // Show error message in textarea
                displayAttendingSummary(summaryToDisplay, selectedMode);
            } else {
                console.warn('‚ö†Ô∏è No summary generated');
            }
        }

        /**
         * Clean final note formatting for EMR
         * @param {string} note - Note text to clean
         * @returns {string} Cleaned note
         */
        function cleanFinalNote(note) {
            return note
                // Remove emoji markers
                .replace(/üìù DOCUMENTED:/g, '')
                .replace(/üìù /g, '')
                .replace(/ü§ñ CLINICAL ANALYSIS:/g, 'CLINICAL ANALYSIS:')
                .replace(/ü§ñ DIFFERENTIAL DIAGNOSIS:/g, 'DIFFERENTIAL DIAGNOSIS:')
                .replace(/ü§ñ EVIDENCE-BASED RECOMMENDATIONS:/g, 'RECOMMENDATIONS:')
                .replace(/ü§ñ CLINICAL GAPS IDENTIFIED:/g, 'CLINICAL GAPS:')
                .replace(/ü§ñ /g, '')
                .replace(/üí° CLINICAL PEARL:/g, 'CLINICAL PEARL:')
                .replace(/üí° /g, '')
                .replace(/‚ö†Ô∏è RED FLAG ALERT:/g, 'IMPORTANT:')
                .replace(/‚ö†Ô∏è RED FLAGS:/g, 'RED FLAGS:')
                .replace(/‚ö†Ô∏è /g, '')
                .replace(/üìä Evidence Level:/g, 'Evidence Level:')
                .replace(/üìä /g, '')
                .replace(/üî¨ RECOMMENDED DIAGNOSTIC WORKUP/g, 'DIAGNOSTIC WORKUP')
                .replace(/üî¨ /g, '')
                .replace(/üíä EVIDENCE-BASED MANAGEMENT PLAN/g, 'MANAGEMENT PLAN')
                .replace(/üíä /g, '')
                .replace(/üìè CLINICAL SCALES ASSESSMENT/g, 'CLINICAL SCALES ASSESSMENT')
                .replace(/üìè /g, '')
                .replace(/üîó /g, '')
                .replace(/üéØ /g, '')
                .replace(/üíé /g, '')
                .replace(/üìã /g, '')

                // Remove multiple blank lines (max 2 consecutive)
                .replace(/\n{4,}/g, '\n\n\n')
                .replace(/\n{3,}/g, '\n\n')

                // Remove trailing whitespace from lines
                .replace(/[ \t]+$/gm, '')

                // Clean up spacing around headers
                .replace(/\n\n##/g, '\n\n\n##')
                .replace(/##([^\n])/g, '## $1')

                .trim();
        }

        /**
         * Display final note in dedicated tab
         * @param {string} finalNote - The cleaned final note
         * @param {number} keptCount - Number of kept suggestions
         * @param {number} discardedCount - Number of discarded suggestions
         */
        function displayFinalNote(finalNote, keptCount, discardedCount) {
            // Check if Final Note tab already exists
            let finalTab = document.getElementById('tab-final');
            let finalButton = document.getElementById('final-tab-button');

            if (!finalTab) {
                // Create the tab button
                const tabButtons = document.querySelector('.tab-buttons');
                finalButton = document.createElement('button');
                finalButton.className = 'tab-button';
                finalButton.id = 'final-tab-button';
                finalButton.onclick = () => switchTab('final');
                finalButton.innerHTML = 'üìÑ Final Note';
                tabButtons.appendChild(finalButton);

                // Create the tab content
                const outputPanel = document.querySelector('#tab-export').parentElement;
                finalTab = document.createElement('div');
                finalTab.className = 'tab-content';
                finalTab.id = 'tab-final';
                finalTab.style.display = 'none';
                finalTab.innerHTML = `
                    <div style="background: #d4edda; padding: 14px; border-radius: 6px; margin-bottom: 20px; color: #155724; border-left: 4px solid #28a745;">
                        <strong>‚úÖ Final Clean Note:</strong> Professional clinical documentation ready for medical record.
                        All markers and emojis removed. You can edit before exporting.
                    </div>

                    <div id="finalNoteSummary" style="background: #f6f8fa; padding: 12px; border-radius: 6px; margin-bottom: 15px; font-size: 0.9rem; color: #24292e; display: flex; gap: 20px; justify-content: center; border: 1px solid #e1e4e8;">
                        <span id="finalKeptCount"></span>
                        <span id="finalDiscardedCount"></span>
                    </div>

                    <textarea id="finalNoteText"
                              style="width: 100%; min-height: 500px; font-family: 'Courier New', Courier, monospace; font-size: 0.95rem; padding: 15px; border: 2px solid #E1E4E8; border-radius: 6px; line-height: 1.6; resize: vertical;"
                              placeholder="Final note will appear here..."></textarea>

                    <div style="margin-top: 15px; display: flex; gap: 12px;">
                        <button onclick="copyFinalNote()" class="success" style="flex: 1; padding: 12px;">
                            üìã Copy to Clipboard
                        </button>
                        <button onclick="downloadFinalNote()" class="success" style="flex: 1; padding: 12px;">
                            üíæ Download as TXT
                        </button>
                        <button onclick="printFinalNote()" style="flex: 1; padding: 12px;">
                            üñ®Ô∏è Print Note
                        </button>
                    </div>
                `;
                outputPanel.appendChild(finalTab);

                console.log('üìÑ Final Note tab created');
            }

            // Update summary
            document.getElementById('finalKeptCount').textContent = `‚úÖ ${keptCount} suggestions kept`;
            document.getElementById('finalDiscardedCount').textContent = `‚ùå ${discardedCount} discarded`;

            // Set the final note text
            document.getElementById('finalNoteText').value = finalNote;

            // Switch to the Final Note tab
            switchTab('final');

            console.log('‚úÖ Final note generated and displayed');
        }

        /**
         * Copy final note to clipboard
         */
        function copyFinalNote() {
            const finalNote = document.getElementById('finalNoteText');
            if (!finalNote || !finalNote.value) {
                alert('‚ùå No final note to copy. Generate the final note first.');
                return;
            }

            finalNote.select();
            finalNote.setSelectionRange(0, 99999); // For mobile

            try {
                document.execCommand('copy');
                alert('‚úÖ Final note copied to clipboard!');
                console.log('üìã Final note copied to clipboard');
            } catch (err) {
                alert('‚ùå Failed to copy. Please select and copy manually.');
                console.error('Copy failed:', err);
            }
        }

        /**
         * Download final note as text file
         */
        function downloadFinalNote() {
            const text = document.getElementById('finalNoteText').value;
            if (!text) {
                alert('‚ùå No final note to download. Generate the final note first.');
                return;
            }

            const patientName = document.getElementById('patientName').value || 'Patient';
            const dateStr = new Date().toISOString().slice(0, 10);
            const filename = `Clinical_Note_${patientName.replace(/\s+/g, '_')}_${dateStr}.txt`;

            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log(`üíæ Downloaded: ${filename}`);
        }

        /**
         * Print final note
         */
        function printFinalNote() {
            const text = document.getElementById('finalNoteText').value;
            if (!text) {
                alert('‚ùå No final note to print. Generate the final note first.');
                return;
            }

            const printWindow = window.open('', '', 'height=800,width=800');
            printWindow.document.write('<html><head><title>Clinical Note</title>');
            printWindow.document.write('<style>body { font-family: "Courier New", monospace; font-size: 12pt; line-height: 1.6; padding: 1in; white-space: pre-wrap; }</style>');
            printWindow.document.write('</head><body>');
            printWindow.document.write(text);
            printWindow.document.write('</body></html>');
            printWindow.document.close();
            printWindow.print();

            console.log('üñ®Ô∏è Print dialog opened');
        }

        /**
         * =====================================================
         * ATTENDING SUMMARY (Ultra Summarizer) - DOAP Framework
         * =====================================================
         */

        /**
         * Generate attending presentation summary using DOAP framework
         * @param {string} clinicalNote - The full clinical note to summarize
         */
        async function generateAttendingSummary(clinicalNote) {
            if (!API_KEY) {
                console.error('‚ùå API key not configured for attending summary');
                return;
            }

            if (!clinicalNote || clinicalNote.trim().length === 0) {
                console.error('‚ùå No clinical note to summarize');
                return;
            }

            // Show immediate visual feedback
            const textarea = document.getElementById('attendingSummaryText');
            const tabButton = document.getElementById('attending-tab-button');

            if (textarea) {
                textarea.value = '‚è≥ Generating DOAP attending summary...\n\nPlease wait while the AI creates your 45-second presentation.';
            }

            // Show tab immediately
            if (tabButton) {
                tabButton.style.display = 'inline-block';
            }

            // Store for regeneration
            lastGeneratedNote = clinicalNote;

            try {
                // DOAP Framework Prompt
                const prompt = `You are an expert at creating concise attending presentations for neurosurgical cases. Your task is to create a 45-second presentation summary using the DOAP framework.

**DOAP Framework:**
- **D** (Diagnosis Line) - 5 seconds: [Age][Sex], [key PMHx], [primary diagnosis with grade/severity]
- **O** (One-Liner) - 10 seconds: Exam (GCS + critical findings) + Imaging (key pathology with size/grade)
- **A** (Assessment) - 10 seconds: Severity assessment + candidacy for intervention
- **P** (Plan) - 20 seconds: Intervention + timing + main concern/risk

**Critical Rules:**
1. Extract ONLY factual information from the note - NO fabrication
2. Be extremely concise - target 45-second speaking time (~120-140 words)
3. Use neurosurgical terminology appropriately
4. Prioritize most critical findings
5. Format clearly with D/O/A/P headers
6. If information missing, note it briefly (e.g., "exam not documented")

**Example Format:**
D: 67M, HTN, ruptured ACoA aneurysm H&H 3

O: GCS 13, no focal deficit, stiff neck. CT shows Fisher 3 SAH, 7mm ACoA aneurysm on CTA, acute hydrocephalus

A: Low-grade bleed, symptomatic ICP, favorable anatomy for clipping, no contraindications

P: EVD tonight for hydrocephalus, clip tomorrow via pterional. Main concern is vasospasm‚ÄîFisher 3, so TCDs day 3, nimodipine √ó 21 days

---
**Clinical Note to Summarize:**
${clinicalNote}

---
Generate the DOAP summary now:`;

                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.3,  // Factual but concise
                                maxOutputTokens: 4096  // Doubled to handle thinking tokens + actual output
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå API Response NOT OK:', response.status, errorText.substring(0, 500));
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                console.log('üìä Full API Response:', JSON.stringify(data, null, 2));

                // Check for safety blocking
                if (data.promptFeedback?.blockReason) {
                    const blockReason = data.promptFeedback.blockReason;
                    console.error('‚ùå Content blocked by API:', blockReason);
                    throw new Error(`API blocked content: ${blockReason}`);
                }

                // Check if candidates exist
                if (!data.candidates || data.candidates.length === 0) {
                    console.error('‚ùå No candidates in response');
                    console.error('Response structure:', JSON.stringify(data, null, 2));
                    throw new Error('API returned no candidates. Check console for details.');
                }

                // Check finish reason
                const finishReason = data.candidates[0]?.finishReason;
                if (finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during compression generation');
                    console.error('Note may be too long. Candidate structure:', JSON.stringify(data.candidates[0], null, 2));
                    throw new Error('Token limit exceeded. Try with a shorter clinical note or increase maxOutputTokens.');
                } else if (finishReason && finishReason !== 'STOP') {
                    console.warn('‚ö†Ô∏è Unusual finish reason:', finishReason);
                }

                const summary = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No summary generated';

                if (summary === 'No summary generated') {
                    console.error('‚ùå Failed to extract text from response');
                    console.error('Candidate structure:', JSON.stringify(data.candidates[0], null, 2));
                    throw new Error(`Generation failed with finish reason: ${finishReason || 'UNKNOWN'}`);
                }

                console.log('‚úÖ Attending summary generated successfully');
                console.log('Summary length:', summary.length, 'characters');
                return summary;

            } catch (error) {
                console.error('‚ùå Error generating attending summary:', error);

                // Show error in textarea
                if (textarea) {
                    textarea.value = `‚ùå Error generating attending summary:\n\n${error.message}\n\nPlease check:\n1. API key is configured\n2. Internet connection is active\n3. Gemini API quota is available\n\nTry the Regenerate button or generate a new note.`;
                }

                throw error;
            }
        }

        /**
         * Display attending summary in the UI
         * @param {string} summary - The DOAP summary text
         */
        function displayAttendingSummary(summary, mode = null) {
            const textarea = document.getElementById('attendingSummaryText');
            const tabButton = document.getElementById('attending-tab-button');

            if (!textarea) {
                console.error('‚ùå Attending summary textarea not found');
                return;
            }

            // Display the summary
            textarea.value = summary;

            // Show the attending summary tab button
            if (tabButton) {
                tabButton.style.display = 'inline-block';
            }

            // Automatically switch to the attending summary tab
            switchTab('attending');

            // Log which compression level is being displayed
            const displayMode = mode || document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
            const modeLabels = {
                'standard': 'Compressed (Standard DOAP)',
                'ultra': 'Ultracompressed (ULTRATHINK)',
                'telegram': 'Super-compressed (Telegram)'
            };
            console.log(`‚úÖ ${modeLabels[displayMode]} summary displayed and tab switched`);

            // Update stats after displaying
            updateSummaryStats(summary);
        }

        /**
         * Update status badges for compression modes
         */
        function updateCompressionStatusBadges() {
            const statusMap = {
                'pending': { emoji: '‚è≥', text: 'Pending', bg: '#e0e0e0', color: '#666' },
                'generating': { emoji: '‚åõ', text: 'Generating...', bg: '#FFF9C4', color: '#F57F17' },
                'ready': { emoji: '‚úÖ', text: 'Ready', bg: '#C8E6C9', color: '#2E7D32' },
                'failed': { emoji: '‚ùå', text: 'Failed', bg: '#FFCDD2', color: '#C62828' }
            };

            ['standard', 'ultra', 'telegram'].forEach(mode => {
                const badge = document.getElementById(`status-${mode}`);
                if (badge) {
                    const status = currentNoteVersions.status[mode] || 'pending';
                    const statusInfo = statusMap[status];
                    badge.textContent = `${statusInfo.emoji} ${statusInfo.text}`;
                    badge.style.background = statusInfo.bg;
                    badge.style.color = statusInfo.color;
                }
            });
        }

        /**
         * Update compression info box based on selected mode
         */
        function updateCompressionInfo() {
            const mode = document.querySelector('input[name="compressionMode"]:checked').value;
            const infoBox = document.getElementById('compressionInfoBox');

            if (!infoBox) return;

            if (mode === 'standard') {
                infoBox.innerHTML = `
                    <strong>üìä DOAP Framework for Attending Presentation:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>D</strong> - Diagnosis (5 sec): Age, Sex, PMHx, Primary diagnosis</li>
                        <li><strong>O</strong> - One-liner (10 sec): Exam findings + Imaging results</li>
                        <li><strong>A</strong> - Assessment (10 sec): Severity + Candidacy</li>
                        <li><strong>P</strong> - Plan (20 sec): Intervention + Timing + Main concern</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 45-second presentation to impress attending staff</p>
                `;
                infoBox.style.background = '#e3f2fd';
                infoBox.style.borderLeft = '4px solid #2196F3';
            } else if (mode === 'ultra') {
                infoBox.innerHTML = `
                    <strong>‚ö° ULTRATHINK Compression Mode:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>Ultra-Brief Format:</strong> Merge D+O into one line, strip all non-essential words</li>
                        <li><strong>Aggressive Abbreviations:</strong> sz (seizure), fx (fracture), EDH (epidural hematoma)</li>
                        <li><strong>Numbers Only:</strong> GCS scores, vital signs, timeframes</li>
                        <li><strong>Key Actions:</strong> Only critical interventions and monitoring</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 15-second rapid-fire summary (~35-50 words)</p>
                `;
                infoBox.style.background = '#FFE5E0';
                infoBox.style.borderLeft = '4px solid #FF5722';
            } else if (mode === 'telegram') {
                infoBox.innerHTML = `
                    <strong>üì± Telegram Style - Extreme Compression:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>One Sentence Only:</strong> Age+Dx+Key finding+Action</li>
                        <li><strong>Maximum Abbreviations:</strong> Every word counts</li>
                        <li><strong>No Elaboration:</strong> Core facts only</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 5-second elevator pitch (~15-25 words max)</p>
                `;
                infoBox.style.background = '#F3E5F5';
                infoBox.style.borderLeft = '4px solid #9C27B0';
            }

            console.log('üîÑ Compression mode changed to:', mode);

            // Auto-switch to display the already-generated version if it exists
            const textarea = document.getElementById('attendingSummaryText');
            if (!textarea) return;

            let summaryToDisplay = '';
            const modeLabels = {
                'standard': 'Compressed (Standard DOAP)',
                'ultra': 'Ultracompressed (ULTRATHINK)',
                'telegram': 'Telegram Style'
            };

            if (mode === 'ultra' && currentNoteVersions.ultra) {
                summaryToDisplay = currentNoteVersions.ultra;
                console.log('‚úÖ Switched to ultracompressed version');
            } else if (mode === 'standard' && currentNoteVersions.standard) {
                summaryToDisplay = currentNoteVersions.standard;
                console.log('‚úÖ Switched to compressed version');
            } else if (mode === 'telegram' && currentNoteVersions.telegram) {
                summaryToDisplay = currentNoteVersions.telegram;
                console.log('‚úÖ Switched to telegram version');
            }

            // Display the summary (including error messages)
            if (summaryToDisplay) {
                textarea.value = summaryToDisplay;
                // Only update stats if not an error message
                if (!summaryToDisplay.includes('failed')) {
                    updateSummaryStats(summaryToDisplay);
                }
            } else {
                // Show helpful message if mode not yet generated
                const status = currentNoteVersions.status[mode];
                if (status === 'pending') {
                    textarea.value = `‚ÑπÔ∏è ${modeLabels[mode]} will be generated automatically after you create a clinical note.\n\nGenerate a note using transcript or SOAP entry to see ${modeLabels[mode]} here.`;
                } else if (status === 'generating') {
                    textarea.value = `‚åõ Generating ${modeLabels[mode]}...\n\nPlease wait a moment.`;
                }
            }
        }

        /**
         * Generate ULTRA-compressed attending summary (15 seconds, ~35-50 words)
         */
        async function generateUltraAttendingSummary(clinicalNote) {
            if (!API_KEY) {
                console.error('‚ùå API key not configured');
                return;
            }

            if (!clinicalNote || clinicalNote.trim().length === 0) {
                console.error('‚ùå No clinical note to summarize');
                return;
            }

            const prompt = `You are an expert neurosurgeon creating ULTRA-COMPRESSED handoff presentations. Create a 15-second ULTRATHINK summary for safe neurosurgical handoff.

‚ö†Ô∏è CRITICAL SAFETY - NEVER COMPRESS THESE:
1. **GCS components** - ALWAYS include E_V_M_ breakdown (e.g., GCS8:E2V2M4) NOT just total
2. **Laterality** - ALWAYS specify L/R: "L hemiparesis", "R pupil dilated 6mm"
3. **Exact measurements** - NEVER round: "7mm aneurysm" NOT "small aneurysm"
4. **Time-critical windows** - Include exact times: "onset 2h ago", "last normal 14:30"
5. **Anticoagulation** - If on anticoag: "+warfarin INR2.8", "+Plavix"
6. **Neuro exam changes** - Always include direction: "pupil L3‚Üí6mm", "weakness improving 2/5‚Üí4/5"
7. **Critical actions** - Never abbreviate urgent interventions: "Stat craniotomy" not "crani"

**COMPRESSION RULES:**
1. Target 35-50 words total (strict limit)
2. Merge diagnosis + exam into continuous flow
3. Use neurosurgical abbreviations ONLY
4. Strip non-essential words BUT maintain clarity
5. Numbers and critical timeframes mandatory
6. Action items in shortest form that remains unambiguous

‚õî PROHIBITED ABBREVIATIONS (Joint Commission):
- U (units) ‚Üí spell "units"
- Q.D./Q.O.D. ‚Üí "daily"/"every other day"
- Trailing zeros (1.0mg) ‚Üí "1mg"
- MS/MSO4 ‚Üí spell out medication

**NEUROSURGICAL APPROVED ABBREVIATIONS:**
TBI, SAH, EDH, SDH, IPH, ICH, IVH, AVM, GBM, mets, HCP, sz, fx, SCI, ACDF, lami, EVD, ICP, crani, VP shunt, C/T/L/S levels, H&H, Fisher, mRS

**NEUROSURGERY HANDOFF EXAMPLES:**

**TRAUMA (Emergent Surgical):**
29M polytrauma: TBI+3cm R temporal EDH (GCS8:E2V2M4 intubated, L hemiplegia 0/5, R pupil 5mm). 5mm midline shift. EMERGENT craniotomy OR2 in 30min. WATCH: L pupil pre-op, ICP>25.

**VASCULAR (Urgent Observation):**
67F ruptured ACoA: 7mm aneurysm H&H3 Fisher3 (GCS13:E4V4M6 stiff neck). Acute hydroceph, dilated ventricles. EVD tonight, clip AM. WATCH: Vasospasm day 3-14, rebleed, TCDs q12h.

**DEGENERATIVE (Elective - Cauda Equina):**
58M L4-5 massive disc: cauda equina 12h (saddle anesthesia, retention, foot drop L2/5 R3/5). MRI confirms compression. SURGERY <6h from onset‚Äîfunction salvage. WATCH: Return bladder/motor post-op.

**TUMOR (Urgent Resection):**
45F L frontal GBM: 4cm enhancing mass (headache+sz 2wks, now hemiparesis R4/5 declining). 10mm shift+edema. Resection this week, dex 4mg q6h. WATCH: Neuro decline‚Äîexpedite if worsens.

**SPINE TRAUMA (Unstable):**
35M C5-6 fx-dislocation: fall 6m (incomplete SCI, hands weak 3/5, legs 4/5, sensory C6). CT unstable fx, MRI cord contusion. SURGERY 24h‚ÄîACDF+fusion. Halo until OR. WATCH: Neuro decline, resp failure.

---
**Clinical Note to Compress:**
${clinicalNote}

---
Generate ULTRATHINK neurosurgical handoff (35-50 words, preserve ALL safety-critical details):`;

            try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.1,  // Maximum factual accuracy for critical neurosurgical handoffs
                                maxOutputTokens: 4096  // Quadrupled - handles complex notes with long prompts
                            }
                        })
                    }
                );

                if (!response.ok) {
                    throw new Error(`API Error ${response.status}`);
                }

                const data = await response.json();

                // Check for MAX_TOKENS finish reason
                const finishReason = data.candidates?.[0]?.finishReason;
                if (finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during ULTRA compression');
                    throw new Error('Token limit exceeded for ULTRA compression. Note may be too complex.');
                }

                const summary = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No summary generated';

                if (summary === 'No summary generated') {
                    console.error('‚ùå Failed to generate ULTRA summary. Finish reason:', finishReason);
                    throw new Error(`ULTRA generation failed: ${finishReason || 'UNKNOWN'}`);
                }

                console.log('‚úÖ ULTRA summary generated');
                return summary;

            } catch (error) {
                console.error('‚ùå Error generating ULTRA summary:', error);
                throw error;
            }
        }

        /**
         * Generate Telegram-style summary (5 seconds, ~15-25 words)
         */
        async function generateTelegramSummary(clinicalNote) {
            if (!API_KEY) {
                console.error('‚ùå API key not configured');
                return;
            }

            if (!clinicalNote || clinicalNote.trim().length === 0) {
                console.error('‚ùå No clinical note to summarize');
                return;
            }

            const prompt = `You are an expert at creating TELEGRAM-STYLE neurosurgical summaries. Create a 5-second extreme compression.

**Telegram Rules:**
1. Maximum 15-25 words (ABSOLUTE LIMIT)
2. ONE sentence only
3. Format: [Age][Sex] [Dx]+[complication]: [key finding]. [GCS]. [Action]
4. Maximum abbreviations everywhere
5. No elaboration whatsoever

**Example:**
29M TBI+sz: bifrontal contusions, EDH mass effect. GCS8. Observe, CT q8h

---
**Clinical Note:**
${clinicalNote}

---
Generate Telegram summary (15-25 words ONLY):`;

            try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.1,  // Extremely factual
                                maxOutputTokens: 2048  // Adequate buffer for thinking + input + output
                            }
                        })
                    }
                );

                if (!response.ok) {
                    throw new Error(`API Error ${response.status}`);
                }

                const data = await response.json();

                // Check for MAX_TOKENS finish reason
                const finishReason = data.candidates?.[0]?.finishReason;
                if (finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during Telegram compression');
                    throw new Error('Token limit exceeded for Telegram compression.');
                }

                const summary = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No summary generated';

                if (summary === 'No summary generated') {
                    console.error('‚ùå Failed to generate Telegram summary. Finish reason:', finishReason);
                    throw new Error(`Telegram generation failed: ${finishReason || 'UNKNOWN'}`);
                }

                console.log('‚úÖ Telegram summary generated');
                return summary;

            } catch (error) {
                console.error('‚ùå Error generating Telegram summary:', error);
                throw error;
            }
        }

        /**
         * Update summary statistics display
         */
        function updateSummaryStats(summaryText) {
            if (!summaryText || summaryText.trim().length === 0) {
                document.getElementById('summaryWordCount').textContent = '0';
                document.getElementById('summarySeconds').textContent = '0';
                document.getElementById('compressionRatio').textContent = '0%';
                return;
            }

            // Calculate word count
            const words = summaryText.trim().split(/\s+/).length;

            // Calculate speaking time (150 words per minute = 2.5 words per second)
            const seconds = Math.ceil(words / 2.5);

            // Calculate compression ratio if original note exists
            let compressionRatio = 0;
            if (lastGeneratedNote && lastGeneratedNote.trim().length > 0) {
                const originalWords = lastGeneratedNote.trim().split(/\s+/).length;
                compressionRatio = Math.round((1 - words / originalWords) * 100);
            }

            // Update display
            document.getElementById('summaryWordCount').textContent = words;
            document.getElementById('summarySeconds').textContent = seconds;
            document.getElementById('compressionRatio').textContent = compressionRatio + '%';

            console.log(`üìä Stats: ${words} words, ${seconds}s, ${compressionRatio}% compression`);
        }

        /**
         * Copy attending summary to clipboard
         */
        function copyAttendingSummary() {
            const textarea = document.getElementById('attendingSummaryText');
            if (!textarea || !textarea.value) {
                alert('‚ùå No attending summary to copy. Generate a note first.');
                return;
            }

            textarea.select();
            textarea.setSelectionRange(0, 99999);

            try {
                document.execCommand('copy');
                alert('‚úÖ Attending summary copied to clipboard!');
                console.log('üìã Attending summary copied');
            } catch (err) {
                alert('‚ùå Failed to copy. Please select and copy manually.');
                console.error('Copy failed:', err);
            }
        }

        /**
         * Regenerate attending summary from last note
         */
        async function regenerateAttendingSummary() {
            if (!lastGeneratedNote || lastGeneratedNote.trim().length === 0) {
                alert('‚ùå No note available to regenerate summary. Generate a clinical note first.');
                return;
            }

            // Get selected compression mode
            const mode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';

            const textarea = document.getElementById('attendingSummaryText');
            if (textarea) {
                const modeLabel = mode === 'ultra' ? 'ULTRATHINK' : mode === 'telegram' ? 'Telegram' : 'Standard DOAP';
                textarea.value = `‚è≥ Regenerating ${modeLabel} summary...`;
            }

            try {
                let summary;
                if (mode === 'ultra') {
                    console.log('‚ö° Generating ULTRATHINK summary...');
                    summary = await generateUltraAttendingSummary(lastGeneratedNote);
                } else if (mode === 'telegram') {
                    console.log('üì± Generating Telegram summary...');
                    summary = await generateTelegramSummary(lastGeneratedNote);
                } else {
                    console.log('üìä Generating Standard DOAP summary...');
                    summary = await generateAttendingSummary(lastGeneratedNote);
                }

                displayAttendingSummary(summary);
                switchTab('attending');
            } catch (error) {
                if (textarea) {
                    textarea.value = `‚ùå Error: ${error.message}`;
                }
                alert(`Failed to regenerate attending summary: ${error.message}`);
            }
        }

        /**
         * Test attending summary generation with current note
         */
        async function testAttendingSummary() {
            console.log('üß™ TEST: Manual attending summary test triggered');

            // Get current note from output textarea
            const output = document.getElementById('output');
            if (!output || !output.value || output.value.trim().length === 0) {
                alert('‚ùå No clinical note found. Please generate a note first (Transcript, SOAP, or V6 Final Note).');
                return;
            }

            const currentNote = output.value;
            console.log('üß™ TEST: Found note with length:', currentNote.length);

            // Get selected compression mode
            const mode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
            const modeLabel = mode === 'ultra' ? 'ULTRATHINK' : mode === 'telegram' ? 'Telegram' : 'Standard DOAP';
            console.log(`üß™ TEST: Selected mode: ${modeLabel}`);

            // Show the attending tab immediately
            const tabButton = document.getElementById('attending-tab-button');
            if (tabButton) {
                tabButton.style.display = 'inline-block';
                switchTab('attending');
            }

            // Show loading message in textarea
            const textarea = document.getElementById('attendingSummaryText');
            if (textarea) {
                textarea.value = `‚è≥ Generating ${modeLabel} summary...\n\nPlease wait...`;
            }

            try {
                let summary;
                if (mode === 'ultra') {
                    console.log('üß™ TEST: Calling generateUltraAttendingSummary...');
                    summary = await generateUltraAttendingSummary(currentNote);
                } else if (mode === 'telegram') {
                    console.log('üß™ TEST: Calling generateTelegramSummary...');
                    summary = await generateTelegramSummary(currentNote);
                } else {
                    console.log('üß™ TEST: Calling generateAttendingSummary...');
                    summary = await generateAttendingSummary(currentNote);
                }

                if (summary) {
                    console.log('üß™ TEST: Summary received, length:', summary.length);
                    displayAttendingSummary(summary);
                    alert(`‚úÖ Test successful! ${modeLabel} summary generated.`);
                } else {
                    console.error('üß™ TEST: No summary returned');
                    alert('‚ùå Test failed: No summary returned from API');
                }
            } catch (error) {
                console.error('üß™ TEST: Error:', error);
                if (textarea) {
                    textarea.value = `‚ùå Error: ${error.message}`;
                }
                alert(`‚ùå Test failed: ${error.message}`);
            }
        }

        /**
         * Update SOAP statistics in real-time
         */
        function updateSOAPStats() {
            const subjective = document.getElementById('soapSubjective').value.trim();
            const objective = document.getElementById('soapObjective').value.trim();
            const assessment = document.getElementById('soapAssessment').value.trim();
            const plan = document.getElementById('soapPlan').value.trim();

            // Count total words
            const allText = `${subjective} ${objective} ${assessment} ${plan}`;
            const wordCount = allText.trim() ? allText.trim().split(/\s+/).length : 0;
            document.getElementById('soapTotalWords').textContent = wordCount;

            // Count completed sections
            let sectionCount = 0;
            if (subjective) sectionCount++;
            if (objective) sectionCount++;
            if (assessment) sectionCount++;
            if (plan) sectionCount++;
            document.getElementById('soapSectionCount').textContent = `${sectionCount}/4`;
        }

        /**
         * SOAP UNIFIED INPUT PARSERS
         * Three-tier parsing strategy for single-textbox SOAP input
         */

        /**
         * Tier 1: Regex-based SOAP section detector (Fast path - handles 70-80% of cases)
         * Detects labeled sections: "S:", "Subjective:", etc.
         * Returns: { success: boolean, data: {S, O, A, P}, confidence: number }
         */
        function detectSOAPSections(text) {
            if (!text || !text.trim()) {
                return { success: false, data: null, confidence: 0 };
            }

            // Common SOAP section markers (case-insensitive)
            const patterns = {
                subjective: /(?:^|\n)\s*(?:S(?:ubjective)?|SUBJECTIVE|Chief Complaint)\s*[:Ôºö]\s*([^\n]*(?:\n(?!(?:O(?:bjective)?|A(?:ssessment)?|P(?:lan)?)\s*[:Ôºö])[^\n]*)*)/i,
                objective: /(?:^|\n)\s*(?:O(?:bjective)?|OBJECTIVE|Exam(?:ination)?)\s*[:Ôºö]\s*([^\n]*(?:\n(?!(?:A(?:ssessment)?|P(?:lan)?)\s*[:Ôºö])[^\n]*)*)/i,
                assessment: /(?:^|\n)\s*(?:A(?:ssessment)?|ASSESSMENT|Diagnosis|Impression)\s*[:Ôºö]\s*([^\n]*(?:\n(?!(?:P(?:lan)?)\s*[:Ôºö])[^\n]*)*)/i,
                plan: /(?:^|\n)\s*(?:P(?:lan)?|PLAN|Treatment|Recommendations?)\s*[:Ôºö]\s*([\s\S]*)/i
            };

            const result = {
                subjective: '',
                objective: '',
                assessment: '',
                plan: ''
            };

            let sectionsFound = 0;

            // Try to match each section
            for (const [key, pattern] of Object.entries(patterns)) {
                const match = text.match(pattern);
                if (match && match[1]) {
                    result[key] = match[1].trim();
                    if (result[key].length > 0) sectionsFound++;
                }
            }

            // Calculate confidence based on sections found and formatting
            let confidence = 0;
            if (sectionsFound >= 2) {
                confidence = Math.min(95, sectionsFound * 25); // 2 sections = 50%, 3 = 75%, 4 = 100%

                // Bonus for proper formatting (labels present)
                const hasLabels = /(?:S(?:ubjective)?|O(?:bjective)?|A(?:ssessment)?|P(?:lan)?)\s*[:Ôºö]/i.test(text);
                if (hasLabels) confidence = Math.min(95, confidence + 10);
            }

            return {
                success: sectionsFound >= 2, // At least 2 sections needed for regex success
                data: result,
                confidence: confidence,
                sectionsFound: sectionsFound
            };
        }

        /**
         * Tier 2: AI-powered SOAP parser (Accurate path - handles ambiguous/unlabeled cases)
         * Uses Gemini to intelligently parse unstructured clinical text into SOAP format
         */
        async function aiParseSOAP(text) {
            if (!API_KEY) {
                throw new Error('API key not configured');
            }

            const prompt = `You are a clinical documentation expert. Parse the following clinical text into SOAP format.

CRITICAL INSTRUCTIONS:
1. Extract information into 4 categories: Subjective, Objective, Assessment, Plan
2. DO NOT add information not present in the original text
3. DO NOT infer or make assumptions
4. Preserve exact medical terminology and measurements
5. If a section is empty, return empty string
6. Output ONLY valid JSON in this exact format:

{
  "subjective": "patient's symptoms and history",
  "objective": "physical exam findings, vital signs, labs",
  "assessment": "diagnosis, clinical impression",
  "plan": "treatment recommendations, follow-up"
}

CLINICAL TEXT TO PARSE:
${text}

OUTPUT (JSON only, no markdown, no explanation):`;

            try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.1, // Maximum accuracy for parsing
                                maxOutputTokens: 8192 // Increased to handle thinking tokens + JSON output
                            }
                        })
                    }
                );

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();

                // Check for MAX_TOKENS finish reason
                if (data.candidates?.[0]?.finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during SOAP parsing');
                    throw new Error('Response too long. Try shortening the input note.');
                }

                // Extract response text
                const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!responseText) {
                    const finishReason = data.candidates?.[0]?.finishReason || 'UNKNOWN';
                    console.error('‚ùå No response text generated. Finish reason:', finishReason);
                    console.error('Response data:', JSON.stringify(data, null, 2));
                    throw new Error(`AI generation failed: ${finishReason}`);
                }

                // Clean up response (remove markdown code blocks if present)
                const cleanedText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                // Parse JSON response
                const parsed = JSON.parse(cleanedText);

                // Validate structure
                if (typeof parsed === 'object' &&
                    'subjective' in parsed &&
                    'objective' in parsed &&
                    'assessment' in parsed &&
                    'plan' in parsed) {
                    return {
                        success: true,
                        data: {
                            subjective: parsed.subjective || '',
                            objective: parsed.objective || '',
                            assessment: parsed.assessment || '',
                            plan: parsed.plan || ''
                        },
                        confidence: 85 // AI parsing gets 85% confidence
                    };
                } else {
                    throw new Error('Invalid JSON structure from AI');
                }
            } catch (error) {
                console.error('‚ùå AI parsing failed:', error);
                return {
                    success: false,
                    data: null,
                    confidence: 0,
                    error: error.message
                };
            }
        }

        /**
         * Tier 3: Orchestrator function - Coordinates regex and AI parsing
         * Strategy: Try regex first (fast), fall back to AI if needed (accurate)
         */
        async function parseSOAPInput(text, forceAI = false) {
            console.log('üîç Parsing SOAP input...', { length: text.length, forceAI });

            // Step 1: Try regex parsing first (unless forced to use AI)
            if (!forceAI) {
                const regexResult = detectSOAPSections(text);
                console.log('üìä Regex parsing result:', regexResult);

                // If regex parsing successful with high confidence, use it
                if (regexResult.success && regexResult.confidence >= 70) {
                    console.log('‚úÖ Using regex parsing (fast path)');
                    return {
                        ...regexResult,
                        method: 'regex'
                    };
                }

                // If regex found some sections but low confidence, show preview and ask
                if (regexResult.sectionsFound >= 1 && regexResult.confidence < 70) {
                    console.log('‚ö†Ô∏è Regex found sections but low confidence, falling back to AI');
                }
            }

            // Step 2: Fall back to AI parsing
            console.log('ü§ñ Using AI parsing (accurate path)');
            const aiResult = await aiParseSOAP(text);

            if (aiResult.success) {
                return {
                    ...aiResult,
                    method: 'ai'
                };
            }

            // Step 3: Both failed - return error
            return {
                success: false,
                data: null,
                confidence: 0,
                method: 'none',
                error: 'Both regex and AI parsing failed'
            };
        }

        /**
         * SOAP MODE TOGGLE & UI FUNCTIONS
         */

        // Current SOAP input mode ('simple' or 'advanced')
        let currentSOAPMode = 'simple';

        /**
         * Switch between Simple (unified) and Advanced (4-box) SOAP input modes
         */
        function switchSOAPMode(mode) {
            currentSOAPMode = mode;

            const unifiedContainer = document.getElementById('soapUnifiedContainer');
            const separateContainer = document.getElementById('soapSeparateContainer');
            const simpleModeBtn = document.getElementById('simpleModeBtn');
            const advancedModeBtn = document.getElementById('advancedModeBtn');
            const modeDescription = document.getElementById('modeDescription');

            if (mode === 'simple') {
                // Show unified textarea, hide 4 boxes
                unifiedContainer.style.display = 'block';
                separateContainer.style.display = 'none';

                // Update button styles
                simpleModeBtn.style.background = '#2196F3';
                simpleModeBtn.style.color = 'white';
                advancedModeBtn.style.background = '#E0E0E0';
                advancedModeBtn.style.color = '#666';

                // Update description
                modeDescription.innerHTML = '<strong>Simple:</strong> Enter all SOAP sections in one textbox (AI will intelligently parse sections)';

                console.log('‚úÖ Switched to Simple mode (unified input)');
            } else {
                // Show 4 boxes, hide unified textarea
                unifiedContainer.style.display = 'none';
                separateContainer.style.display = 'block';

                // Update button styles
                simpleModeBtn.style.background = '#E0E0E0';
                simpleModeBtn.style.color = '#666';
                advancedModeBtn.style.background = '#2196F3';
                advancedModeBtn.style.color = 'white';

                // Update description
                modeDescription.innerHTML = '<strong>Advanced:</strong> Enter each SOAP section separately in dedicated textboxes';

                console.log('‚úÖ Switched to Advanced mode (4-box input)');
            }

            // Update stats for current mode
            if (mode === 'simple') {
                updateUnifiedStats();
            } else {
                updateSOAPStats();
            }
        }

        /**
         * Update statistics for unified SOAP textarea
         */
        function updateUnifiedStats() {
            const unifiedText = document.getElementById('soapUnifiedInput').value.trim();
            const wordCount = unifiedText ? unifiedText.split(/\s+/).length : 0;

            document.getElementById('soapTotalWords').textContent = wordCount;

            // For unified mode, section count is shown as "Unified"
            document.getElementById('soapSectionCount').textContent = 'Unified';

            // Reset parse indicators when text changes (user needs to re-parse)
            const parseMethod = document.getElementById('parseMethod');
            const parseConfidence = document.getElementById('parseConfidence');
            if (parseMethod && parseMethod.textContent !== 'Not parsed') {
                parseMethod.textContent = 'Not parsed';
                parseMethod.style.background = '#F5F5F5';
                parseMethod.style.color = '#999';
                parseConfidence.textContent = '';

                // Clear stored parsed data (will trigger fresh parsing on generate)
                if (soapQuickEntry && (soapQuickEntry.subjective || soapQuickEntry.objective ||
                    soapQuickEntry.assessment || soapQuickEntry.plan)) {
                    soapQuickEntry = { subjective: '', objective: '', assessment: '', plan: '' };
                }
            }
        }

        /**
         * Preview how SOAP will be parsed from unified input
         */
        async function previewSOAPParsing() {
            const unifiedText = document.getElementById('soapUnifiedInput').value.trim();

            if (!unifiedText) {
                alert('‚ö†Ô∏è Please enter some clinical notes first.');
                return;
            }

            // Show loading state
            const parseMethod = document.getElementById('parseMethod');
            const parseConfidence = document.getElementById('parseConfidence');
            parseMethod.textContent = 'Parsing...';
            parseMethod.style.background = '#FFF9C4';
            parseConfidence.textContent = '';

            try {
                // Try to parse using orchestrator
                const result = await parseSOAPInput(unifiedText);

                console.log('üìä Parse result:', result);

                if (result.success) {
                    // Update UI indicators
                    parseMethod.textContent = result.method === 'regex' ? '‚ö° Regex' : 'ü§ñ AI';
                    parseMethod.style.background = result.method === 'regex' ? '#C8E6C9' : '#E1F5FE';
                    parseConfidence.textContent = `Confidence: ${result.confidence}%`;

                    // Show preview modal with parsed sections
                    showParsePreviewModal(result.data, result.method, result.confidence);
                } else {
                    parseMethod.textContent = '‚ùå Failed';
                    parseMethod.style.background = '#FFCDD2';
                    parseConfidence.textContent = result.error || 'Unable to parse';
                    alert('‚ùå Unable to parse SOAP sections. Please check your input format.');
                }
            } catch (error) {
                console.error('‚ùå Parsing error:', error);
                parseMethod.textContent = '‚ùå Error';
                parseMethod.style.background = '#FFCDD2';
                parseConfidence.textContent = error.message;
                alert('‚ùå Error parsing SOAP: ' + error.message);
            }
        }

        // Temporary storage for parsed data during modal preview
        let tempParsedData = null;

        /**
         * Show modal with parsed SOAP sections for user confirmation
         */
        function showParsePreviewModal(parsedData, method, confidence) {
            // Store data in temporary variable (safer than inline JSON)
            tempParsedData = parsedData;

            const modal = document.createElement('div');
            modal.id = 'soapPreviewModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            const methodLabel = method === 'regex' ? '‚ö° Fast Regex Parsing' : 'ü§ñ AI Parsing';
            const methodColor = method === 'regex' ? '#4CAF50' : '#2196F3';

            // Escape HTML in parsed data to prevent XSS
            const escapeHtml = (text) => {
                if (!text) return '<i style="color: #999;">Empty</i>';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };

            modal.innerHTML = `
                <div style="background: white; padding: 24px; border-radius: 8px; max-width: 700px; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h3 style="margin: 0; color: #333;">üîç SOAP Parsing Preview</h3>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <span style="font-size: 0.8rem; padding: 4px 10px; background: ${methodColor}; color: white; border-radius: 4px; font-weight: 600;">
                                ${methodLabel}
                            </span>
                            <span style="font-size: 0.8rem; padding: 4px 10px; background: #E0E0E0; border-radius: 4px;">
                                ${confidence}% confidence
                            </span>
                        </div>
                    </div>

                    <div style="background: #F5F5F5; padding: 12px; border-radius: 6px; margin-bottom: 16px; font-size: 0.85rem; color: #666;">
                        ‚ÑπÔ∏è Review the parsed sections below. Click "Use This Parsing" to proceed with generation.
                    </div>

                    <div style="margin-bottom: 12px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">üìù Subjective:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.subjective)}
                        </div>
                    </div>

                    <div style="margin-bottom: 12px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">üî¨ Objective:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.objective)}
                        </div>
                    </div>

                    <div style="margin-bottom: 12px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">ü©∫ Assessment:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.assessment)}
                        </div>
                    </div>

                    <div style="margin-bottom: 16px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">üíä Plan:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.plan)}
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeParsePreviewModal()"
                                style="padding: 10px 20px; background: #E0E0E0; color: #666; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                            ‚ùå Cancel
                        </button>
                        <button onclick="acceptParsedSOAPFromModal()"
                                style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                            ‚úÖ Use This Parsing
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        /**
         * Close the SOAP preview modal
         */
        function closeParsePreviewModal() {
            const modal = document.getElementById('soapPreviewModal');
            if (modal) {
                modal.remove();
            }
            tempParsedData = null;
        }

        /**
         * Accept parsed data from modal and close
         */
        function acceptParsedSOAPFromModal() {
            if (tempParsedData) {
                acceptParsedSOAP(tempParsedData);
            }
            closeParsePreviewModal();
        }

        /**
         * Accept parsed SOAP data and populate the 4-box fields (for verification or editing)
         */
        function acceptParsedSOAP(parsedData) {
            // Store in soapQuickEntry for generation
            soapQuickEntry = {
                subjective: parsedData.subjective || '',
                objective: parsedData.objective || '',
                assessment: parsedData.assessment || '',
                plan: parsedData.plan || ''
            };

            console.log('‚úÖ Accepted parsed SOAP data:', soapQuickEntry);

            // Update parse method indicator
            const parseMethod = document.getElementById('parseMethod');
            parseMethod.textContent = '‚úÖ Parsed';
            parseMethod.style.background = '#C8E6C9';
            parseMethod.style.color = '#2E7D32';

            alert('‚úÖ SOAP sections parsed successfully! You can now generate the clinical note.');
        }

        /**
         * Validate SOAP entry before generation (supports both Simple and Advanced modes)
         */
        async function validateSOAPEntry() {
            let subjective, objective, assessment, plan;

            // MODE 1: SIMPLE (Unified Textarea) - Parse the text
            if (currentSOAPMode === 'simple') {
                const unifiedText = document.getElementById('soapUnifiedInput').value.trim();

                if (!unifiedText) {
                    alert('‚ö†Ô∏è Please enter clinical notes before generating.');
                    return false;
                }

                console.log('üîç Simple mode: Parsing unified SOAP input...');

                // Check if already parsed (user clicked "Preview Parsing" and accepted)
                if (soapQuickEntry &&
                    (soapQuickEntry.subjective || soapQuickEntry.objective ||
                     soapQuickEntry.assessment || soapQuickEntry.plan)) {
                    console.log('‚úÖ Using previously parsed SOAP data');
                    subjective = soapQuickEntry.subjective;
                    objective = soapQuickEntry.objective;
                    assessment = soapQuickEntry.assessment;
                    plan = soapQuickEntry.plan;
                } else {
                    // Parse on-the-fly
                    console.log('‚ö° Auto-parsing SOAP input...');
                    try {
                        const parseResult = await parseSOAPInput(unifiedText);

                        if (!parseResult.success) {
                            alert('‚ùå Unable to parse SOAP sections. Please check your input format or use "Preview Parsing" first.');
                            return false;
                        }

                        // Store parsed data
                        soapQuickEntry = {
                            subjective: parseResult.data.subjective || '',
                            objective: parseResult.data.objective || '',
                            assessment: parseResult.data.assessment || '',
                            plan: parseResult.data.plan || ''
                        };

                        subjective = soapQuickEntry.subjective;
                        objective = soapQuickEntry.objective;
                        assessment = soapQuickEntry.assessment;
                        plan = soapQuickEntry.plan;

                        console.log(`‚úÖ Auto-parsed using ${parseResult.method} (${parseResult.confidence}% confidence)`);
                    } catch (error) {
                        console.error('‚ùå Parsing error:', error);
                        alert('‚ùå Error parsing SOAP: ' + error.message);
                        return false;
                    }
                }
            }
            // MODE 2: ADVANCED (4 Separate Textboxes) - Read directly
            else {
                subjective = document.getElementById('soapSubjective').value.trim();
                objective = document.getElementById('soapObjective').value.trim();
                assessment = document.getElementById('soapAssessment').value.trim();
                plan = document.getElementById('soapPlan').value.trim();

                // At least one section must have content
                if (!subjective && !objective && !assessment && !plan) {
                    alert('‚ö†Ô∏è Please enter information in at least one SOAP section before generating.');
                    return false;
                }

                // Store values
                soapQuickEntry = {
                    subjective: subjective,
                    objective: objective,
                    assessment: assessment,
                    plan: plan
                };
            }

            // Common validation for both modes
            // Warning if assessment empty (but allow to proceed)
            if (!assessment && (subjective || objective || plan)) {
                const proceed = confirm('‚ö†Ô∏è Assessment section is empty. Proceed without diagnosis/impression?');
                if (!proceed) return false;
            }

            console.log('‚úÖ SOAP validation passed');
            console.log(`üìä SOAP Entry: S=${subjective.length} O=${objective.length} A=${assessment.length} P=${plan.length} chars`);
            console.log(`Mode: ${currentSOAPMode}`);
            return true;
        }

        /**
         * Determine which input panel is active (transcript or SOAP)
         */
        function detectActiveInputPanel() {
            // Check if SOAP panel has content (both unified and separate modes)
            let soapHasContent = false;

            if (currentSOAPMode === 'simple') {
                soapHasContent = document.getElementById('soapUnifiedInput').value.trim();
            } else {
                soapHasContent =
                    document.getElementById('soapSubjective').value.trim() ||
                    document.getElementById('soapObjective').value.trim() ||
                    document.getElementById('soapAssessment').value.trim() ||
                    document.getElementById('soapPlan').value.trim();
            }

            // Check if transcript has content
            const transcriptHasContent = document.getElementById('transcript').value.trim();

            // If SOAP has content, use SOAP mode
            if (soapHasContent) {
                activeInputPanel = 'soap';
                return 'soap';
            }

            // Otherwise default to transcript mode
            activeInputPanel = 'transcript';
            return 'transcript';
        }

        // ============================================================
        // CONSULTATION TYPE FUNCTIONS
        // ============================================================

        function selectConsultType(type) {
            consultationType = type;

            // Update button styles
            const newBtn = document.getElementById('consultTypeNew');
            const followupBtn = document.getElementById('consultTypeFollowup');
            const descDiv = document.getElementById('consultTypeDescription');

            if (type === 'new') {
                newBtn.style.background = '#4A90E2';
                newBtn.style.color = 'white';
                newBtn.style.borderColor = '#4A90E2';

                followupBtn.style.background = 'white';
                followupBtn.style.color = '#333';
                followupBtn.style.borderColor = '#E1E4E8';

                descDiv.innerHTML = '<strong>New Consultation:</strong> Comprehensive initial assessment with full history, examination, and workup.';
            } else {
                followupBtn.style.background = '#4A90E2';
                followupBtn.style.color = 'white';
                followupBtn.style.borderColor = '#4A90E2';

                newBtn.style.background = 'white';
                newBtn.style.color = '#333';
                newBtn.style.borderColor = '#E1E4E8';

                descDiv.innerHTML = '<strong>Follow-up Visit:</strong> Interval history, treatment response, updated assessment, and plan modifications.';
            }

            console.log(`‚úÖ Consultation type set to: ${type}`);
        }

        // ============================================================
        // REAL-TIME MONITORING FUNCTIONS
        // ============================================================

        function checkForRedFlags(text) {
            if (!selectedPathology || !activeRedFlags || activeRedFlags.length === 0) {
                return;
            }

            const lowerText = text.toLowerCase();
            const detectedFlags = [];

            for (const flag of activeRedFlags) {
                if (lowerText.includes(flag.toLowerCase())) {
                    detectedFlags.push(flag);
                }
            }

            if (detectedFlags.length > 0) {
                // Display alert in status area
                const status = document.getElementById('status');
                const originalStatus = status.textContent;
                const originalClass = status.className;

                status.className = 'status disconnected';
                status.innerHTML = `‚ö†Ô∏è RED FLAG DETECTED: ${detectedFlags[0]}`;

                // Revert after 5 seconds
                setTimeout(() => {
                    if (isRecording) {
                        status.className = 'status recording';
                        status.textContent = 'üî¥ Recording in progress...';
                    } else {
                        status.className = originalClass;
                        status.textContent = originalStatus;
                    }
                }, 5000);

                console.log('üö® Red flags detected:', detectedFlags);
            }
        }

        function checkForScaleComponents(text) {
            if (!selectedPathology) {
                return;
            }

            // Get recommended scales for current pathology
            const pathologyData = PathologyDatabase[selectedPathology];
            if (!pathologyData || !pathologyData.recommendedScales) {
                return;
            }

            const lowerText = text.toLowerCase();
            const detectedComponents = [];

            // Check each recommended scale's keywords
            for (const scaleId of pathologyData.recommendedScales) {
                const scale = ClinicalScalesDatabase[scaleId];
                if (!scale) continue;

                for (const question of scale.questions) {
                    if (!question.keywords) continue;

                    for (const keyword of question.keywords) {
                        if (lowerText.includes(keyword.toLowerCase())) {
                            detectedComponents.push({
                                scale: scale.shortName,
                                scaleId: scaleId,
                                question: question.text,
                                questionId: question.id,
                                keyword: keyword
                            });
                            break; // Only detect once per question
                        }
                    }
                }
            }

            if (detectedComponents.length > 0) {
                // Log detected components
                console.log('üìä Scale components detected:', detectedComponents);

                // Could add visual indicator here if desired
                // For now, just log to console for physician review

                // Optional: Show subtle notification (non-intrusive)
                const component = detectedComponents[0];
                console.log(`‚úì ${component.scale} - ${component.question.substring(0, 50)}...`);
            }
        }

        // ============================================================
        // CLINICAL SCALES FUNCTIONS
        // ============================================================

        function initializeScales() {
            try {
                // Check if database is loaded
                if (typeof ClinicalScalesDatabase === 'undefined') {
                    console.error('‚ùå ClinicalScalesDatabase not loaded');
                    alert('Error: Clinical scales database failed to load. Please refresh the page.');
                    return false;
                }

                // Populate scale selector dropdown
                const select = document.getElementById('scaleSelect');
                if (!select) {
                    console.error('‚ùå Scale selector element not found');
                    return false;
                }

                // Clear existing options except first
                while (select.options.length > 1) {
                    select.remove(1);
                }

                // Add all available scales
                let scalesAdded = 0;
                for (const scaleId in ClinicalScalesDatabase) {
                    const scale = ClinicalScalesDatabase[scaleId];
                    if (scale && scale.name && scale.shortName) {
                        const option = document.createElement('option');
                        option.value = scaleId;
                        option.textContent = `${scale.shortName} - ${scale.name}`;
                        select.appendChild(option);
                        scalesAdded++;
                    }
                }

                console.log(`‚úÖ Clinical scales initialized: ${scalesAdded} scales loaded`);
                return true;
            } catch (error) {
                console.error('‚ùå Error initializing scales:', error);
                alert('Error initializing clinical scales. Please refresh the page.');
                return false;
            }
        }

        function loadScaleForm() {
            const scaleId = document.getElementById('scaleSelect').value;

            if (!scaleId) {
                document.getElementById('scaleFormContainer').style.display = 'none';
                document.getElementById('scalesPlaceholder').style.display = 'block';
                document.getElementById('scaleResults').style.display = 'none';
                return;
            }

            currentScale = ClinicalScalesDatabase[scaleId];

            // Initialize responses object for this scale if not exists
            if (!scaleResponses[scaleId]) {
                scaleResponses[scaleId] = {};
            }

            // Show form container, hide placeholder
            document.getElementById('scaleFormContainer').style.display = 'block';
            document.getElementById('scalesPlaceholder').style.display = 'none';
            document.getElementById('scaleResults').style.display = 'none';

            // Display scale description
            const descDiv = document.getElementById('scaleDescription');
            descDiv.innerHTML = `
                <h3 style="margin: 0 0 10px 0; color: #0066CC;">${currentScale.name}</h3>
                <p style="margin: 0 0 8px 0; font-size: 0.95rem;">${currentScale.description}</p>
                <p style="margin: 0; font-size: 0.85rem; color: #666;">
                    <strong>Range:</strong> ${currentScale.minScore}-${currentScale.maxScore} |
                    <strong>Evidence Level:</strong> ${currentScale.evidenceLevel}
                </p>
            `;

            // Generate form questions
            const questionsDiv = document.getElementById('scaleQuestions');
            questionsDiv.innerHTML = '';

            currentScale.questions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.style.cssText = 'background: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; border: 2px solid #ddd;';

                // Question header
                let questionHTML = `
                    <div style="margin-bottom: 12px;">
                        <span style="background: #0066CC; color: white; padding: 4px 10px; border-radius: 4px; font-weight: 600; margin-right: 8px;">
                            Q${index + 1}
                        </span>
                        ${question.section ? `<span style="color: #666; font-size: 0.9rem;">${question.section}</span>` : ''}
                    </div>
                    <div style="font-weight: 600; margin-bottom: 15px; color: #333; font-size: 1.05rem;">
                        ${question.text}
                    </div>
                `;

                // Generate input based on question type
                if (question.type === 'slider') {
                    // Slider for VAS pain scale
                    questionHTML += `
                        <div style="margin: 15px 0;">
                            <input type="range"
                                id="scale_${scaleId}_${question.id}"
                                min="0" max="10"
                                value="${scaleResponses[scaleId][question.id] || 5}"
                                oninput="updateSliderValue('${scaleId}', '${question.id}', this.value)"
                                style="width: 100%; height: 8px; border-radius: 5px; background: #ddd; outline: none; cursor: pointer;">
                            <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.9rem; color: #666;">
                                <span>0 (No Pain)</span>
                                <span id="slider_value_${scaleId}_${question.id}" style="font-weight: 600; color: #0066CC; font-size: 1.2rem;">
                                    ${scaleResponses[scaleId][question.id] || 5}
                                </span>
                                <span>10 (Worst Pain)</span>
                            </div>
                        </div>
                    `;
                } else {
                    // Radio buttons for standard scales
                    questionHTML += '<div style="margin-top: 10px;">';
                    question.options.forEach((option) => {
                        const isChecked = scaleResponses[scaleId][question.id] === option.value ? 'checked' : '';
                        questionHTML += `
                            <label style="display: flex; align-items: flex-start; padding: 12px; margin-bottom: 8px; border: 2px solid ${isChecked ? '#0066CC' : '#e0e0e0'}; border-radius: 6px; cursor: pointer; background: ${isChecked ? '#e3f2fd' : 'white'}; transition: all 0.2s;">
                                <input type="radio"
                                    name="scale_${scaleId}_${question.id}"
                                    value="${option.value}"
                                    onchange="updateScaleResponse('${scaleId}', '${question.id}', ${option.value})"
                                    ${isChecked}
                                    style="margin-right: 12px; margin-top: 4px; transform: scale(1.2);">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: #333; margin-bottom: 4px;">${option.label}</div>
                                    ${option.description ? `<div style="font-size: 0.85rem; color: #666;">${option.description}</div>` : ''}
                                </div>
                            </label>
                        `;
                    });
                    questionHTML += '</div>';
                }

                questionDiv.innerHTML = questionHTML;
                questionsDiv.appendChild(questionDiv);
            });
        }

        function updateSliderValue(scaleId, questionId, value) {
            // Update display
            document.getElementById(`slider_value_${scaleId}_${questionId}`).textContent = value;
            // Store response
            scaleResponses[scaleId][questionId] = parseInt(value);
            // Save to localStorage
            saveScaleResponsesToStorage();
        }

        function updateScaleResponse(scaleId, questionId, value) {
            // Store the response
            scaleResponses[scaleId][questionId] = value;

            // Save to localStorage
            saveScaleResponsesToStorage();

            // Update all radio labels to reflect selection visually
            const radios = document.getElementsByName(`scale_${scaleId}_${questionId}`);
            radios.forEach(radio => {
                const label = radio.parentElement;
                if (radio.checked) {
                    label.style.borderColor = '#0066CC';
                    label.style.background = '#e3f2fd';
                } else {
                    label.style.borderColor = '#e0e0e0';
                    label.style.background = 'white';
                }
            });
        }

        function saveScaleResponsesToStorage() {
            try {
                const dataToSave = {
                    responses: scaleResponses,
                    scores: calculatedScores,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('neuroscribe_scale_data', JSON.stringify(dataToSave));
                console.log('‚úÖ Scale data saved to localStorage');
            } catch (error) {
                console.error('‚ùå Error saving scale data:', error);
            }
        }

        function loadScaleResponsesFromStorage() {
            try {
                const saved = localStorage.getItem('neuroscribe_scale_data');
                if (saved) {
                    const data = JSON.parse(saved);
                    scaleResponses = data.responses || {};
                    calculatedScores = data.scores || {};
                    console.log(`‚úÖ Scale data loaded from localStorage (saved: ${data.timestamp})`);
                    return true;
                }
            } catch (error) {
                console.error('‚ùå Error loading scale data:', error);
            }
            return false;
        }

        function clearScaleData() {
            if (confirm('Are you sure you want to clear all scale responses and scores? This cannot be undone.')) {
                scaleResponses = {};
                calculatedScores = {};
                localStorage.removeItem('neuroscribe_scale_data');
                // Reset current scale if loaded
                if (currentScale) {
                    loadScaleForm(); // Reload the form to show empty state
                }
                alert('‚úÖ All scale data cleared');
                console.log('‚úÖ Scale data cleared');
            }
        }

        function calculateScale() {
            try {
                if (!currentScale) {
                    alert('Please select a clinical scale first.');
                    return;
                }

                const scaleId = currentScale.id;
                const responses = scaleResponses[scaleId] || {};

                // Validate that at least some questions are answered
                const answeredCount = Object.keys(responses).filter(key => responses[key] !== null && responses[key] !== undefined).length;

                if (answeredCount === 0) {
                    alert('Please answer at least one question before calculating the score.');
                    return;
                }

                // Warn if not all questions answered
                if (answeredCount < currentScale.questions.length) {
                    const proceed = confirm(`Only ${answeredCount} out of ${currentScale.questions.length} questions answered. Score may be incomplete. Continue?`);
                    if (!proceed) return;
                }

                // Update scale object with current responses
                currentScale.questions.forEach(q => {
                    q.value = responses[q.id] !== undefined ? responses[q.id] : null;
                });

                // Calculate score using scale's scoring function
                if (typeof currentScale.scoring !== 'function') {
                    throw new Error('Scale scoring function not found');
                }

                const scoreResult = currentScale.scoring(responses);
                if (!scoreResult) {
                    throw new Error('Score calculation failed');
                }

                calculatedScores[scaleId] = scoreResult;

                // Get interpretation
                let interpretation;
                if (typeof currentScale.interpretation !== 'function') {
                    // Provide default interpretation if function missing
                    interpretation = {
                        severity: 'Score Calculated',
                        color: '#0066CC',
                        description: 'Score calculated successfully',
                        recommendation: 'Review clinical context'
                    };
                } else {
                    if (scaleId === 'ndi' || scaleId === 'odi') {
                        interpretation = currentScale.interpretation(scoreResult.percentage);
                    } else if (scaleId === 'vas_pain') {
                        interpretation = currentScale.interpretation(scoreResult.overallAverage);
                    } else {
                        interpretation = currentScale.interpretation(scoreResult.total);
                    }
                }

                // Display results
                displayScaleResults(currentScale, scoreResult, interpretation);

                console.log(`‚úÖ ${currentScale.shortName} calculated:`, scoreResult);

            } catch (error) {
                console.error('‚ùå Error calculating scale:', error);
                alert(`Error calculating scale: ${error.message}. Please try again.`);
            }
        }

        function displayScaleResults(scale, scoreResult, interpretation) {
            const resultsDiv = document.getElementById('scaleResults');
            resultsDiv.style.display = 'block';

            let resultsHTML = `
                <h3 style="margin: 0 0 20px 0; color: #0066CC; display: flex; align-items: center; justify-content: space-between;">
                    ${scale.shortName} Results
                    <span style="background: ${interpretation.color}; color: white; padding: 6px 12px; border-radius: 6px; font-size: 0.9rem;">
                        ${interpretation.severity}
                    </span>
                </h3>
            `;

            // Score display based on scale type
            if (scale.id === 'vas_pain') {
                resultsHTML += `
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid ${interpretation.color};">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Current Pain</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.current !== null ? scoreResult.current : 'N/A'}</div>
                            </div>
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Worst (24h)</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.worst !== null ? scoreResult.worst : 'N/A'}</div>
                            </div>
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Average</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.average !== null ? scoreResult.average : 'N/A'}</div>
                            </div>
                        </div>
                    </div>
                `;
            } else if (scale.id === 'ndi' || scale.id === 'odi') {
                resultsHTML += `
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid ${interpretation.color};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Raw Score</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.total} / ${scoreResult.max}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Disability Index</div>
                                <div style="font-size: 2.5rem; font-weight: 600; color: ${interpretation.color};">${scoreResult.percentage}%</div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                resultsHTML += `
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid ${interpretation.color};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Total Score</div>
                                <div style="font-size: 2.5rem; font-weight: 600; color: #333;">${scoreResult.total}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Range</div>
                                <div style="font-size: 1.2rem; color: #666;">${scale.minScore} - ${scale.maxScore}</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Completion status
            resultsHTML += `
                <div style="background: ${scoreResult.percentage === 100 ? '#d4edda' : '#fff3cd'}; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                    <strong>Completion:</strong> ${scoreResult.answered} / ${scoreResult.totalQuestions} questions answered (${scoreResult.percentage}%)
                    ${scoreResult.percentage < 100 ? '<div style="margin-top: 5px; font-size: 0.9rem; color: #856404;">‚ö†Ô∏è Score may be inaccurate - not all questions answered</div>' : ''}
                </div>
            `;

            // Interpretation
            resultsHTML += `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="font-weight: 600; color: #333; margin-bottom: 8px;">Clinical Interpretation:</div>
                    <div style="color: #555; margin-bottom: 10px;">${interpretation.description}</div>
                    <div style="background: white; padding: 12px; border-radius: 6px; border-left: 4px solid #0066CC;">
                        <strong>Recommendation:</strong> ${interpretation.recommendation}
                    </div>
                </div>
            `;

            // Evidence and references
            if (scale.references && scale.references.length > 0) {
                resultsHTML += `
                    <div style="font-size: 0.85rem; color: #666; padding-top: 12px; border-top: 1px solid #ddd;">
                        <strong>References:</strong><br>
                        ${scale.references.map(ref => `‚Ä¢ ${ref}`).join('<br>')}
                    </div>
                `;
            }

            resultsDiv.innerHTML = resultsHTML;

            // Scroll to results
            resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // Load scales based on selected pathology
        function loadRecommendedScales(pathologyId) {
            if (!pathologyId) return;

            const select = document.getElementById('scaleSelect');

            // Get scales that match this pathology
            const recommendedScales = [];
            for (const scaleId in ClinicalScalesDatabase) {
                const scale = ClinicalScalesDatabase[scaleId];
                if (scale.pathologies.includes(pathologyId)) {
                    recommendedScales.push(scaleId);
                }
            }

            // If we have recommended scales, highlight them or auto-select first one
            if (recommendedScales.length > 0) {
                // Could implement highlighting or auto-selection here
                console.log('Recommended scales for', pathologyId, ':', recommendedScales);
            }
        }

        // ============================================================
        // VALIDATION RESULTS DISPLAY (V8)
        // ============================================================

        function displayValidationResults(validationResult) {
            console.log('üìä Displaying validation results in UI...');

            if (!validationResult || !validationResult.success) {
                console.warn('‚ö†Ô∏è No valid validation results to display');
                // Keep placeholder visible
                document.getElementById('validationPlaceholder').style.display = 'block';
                return;
            }

            // Hide placeholder
            document.getElementById('validationPlaceholder').style.display = 'none';

            const validation = validationResult.validation;
            if (!validation) {
                console.warn('‚ö†Ô∏è Validation object missing');
                return;
            }

            // ========================================
            // 1. OVERALL QUALITY SCORE
            // ========================================
            const overallScore = Math.round(validation.overallScore || 0);
            const scoreDisplay = document.getElementById('qualityScoreDisplay');
            const badgeDisplay = document.getElementById('qualityBadgeDisplay');

            if (scoreDisplay) {
                scoreDisplay.textContent = overallScore;

                // Color-code the score
                if (overallScore >= 80) {
                    scoreDisplay.style.color = '#28a745'; // Green
                } else if (overallScore >= 60) {
                    scoreDisplay.style.color = '#ffc107'; // Yellow/Orange
                } else {
                    scoreDisplay.style.color = '#dc3545'; // Red
                }
            }

            // Quality badge
            if (badgeDisplay) {
                if (overallScore >= 80) {
                    badgeDisplay.textContent = 'üü¢ High Quality';
                    badgeDisplay.style.background = '#d4edda';
                    badgeDisplay.style.color = '#155724';
                    badgeDisplay.style.border = '2px solid #28a745';
                } else if (overallScore >= 60) {
                    badgeDisplay.textContent = 'üü° Moderate Quality';
                    badgeDisplay.style.background = '#fff3cd';
                    badgeDisplay.style.color = '#856404';
                    badgeDisplay.style.border = '2px solid #ffc107';
                } else {
                    badgeDisplay.textContent = 'üî¥ Review Needed';
                    badgeDisplay.style.background = '#f8d7da';
                    badgeDisplay.style.color = '#721c24';
                    badgeDisplay.style.border = '2px solid #dc3545';
                }
            }

            // ========================================
            // 2. LAYER SCORES & PROGRESS BARS
            // ========================================
            const layers = [
                { id: 'grounding', data: validation.grounding, color: '#667eea' },
                { id: 'fabrication', data: validation.fabrication, color: '#764ba2' },
                { id: 'completeness', data: validation.completeness, color: '#f093fb' },
                { id: 'consistency', data: validation.consistency, color: '#4facfe' },
                { id: 'proportionality', data: validation.proportionality, color: '#43e97b' }
            ];

            layers.forEach(layer => {
                const score = layer.data?.score !== undefined ? Math.round(layer.data.score) : 0;
                const scoreEl = document.getElementById(`${layer.id}-score`);
                const progressBar = document.querySelector(`#${layer.id}-progress div`);

                if (scoreEl) {
                    scoreEl.textContent = score;
                    // Color-code individual scores
                    if (score >= 80) {
                        scoreEl.style.color = '#28a745';
                    } else if (score >= 60) {
                        scoreEl.style.color = '#ffc107';
                    } else {
                        scoreEl.style.color = '#dc3545';
                    }
                }

                if (progressBar) {
                    progressBar.style.width = `${score}%`;
                    progressBar.style.background = layer.color;
                }

                // Show details if available
                const detailsEl = document.getElementById(`${layer.id}-details`);
                if (detailsEl && layer.data) {
                    let detailsHTML = '';

                    if (layer.id === 'grounding' && layer.data.coverage) {
                        detailsHTML = `<strong>Coverage:</strong> ${Math.round(layer.data.coverage * 100)}%`;
                        if (layer.data.quotesFound !== undefined) {
                            detailsHTML += ` | <strong>Quotes:</strong> ${layer.data.quotesFound}`;
                        }
                    } else if (layer.id === 'fabrication') {
                        if (layer.data.highConfidenceFabrications !== undefined) {
                            detailsHTML = `<strong>High Confidence Issues:</strong> ${layer.data.highConfidenceFabrications}`;
                        }
                    } else if (layer.id === 'completeness') {
                        if (layer.data.extractionCoverage !== undefined) {
                            detailsHTML = `<strong>Extraction Coverage:</strong> ${Math.round(layer.data.extractionCoverage * 100)}%`;
                        }
                    } else if (layer.id === 'consistency') {
                        if (layer.data.issuesFound !== undefined) {
                            detailsHTML = `<strong>Issues Found:</strong> ${layer.data.issuesFound}`;
                        }
                    } else if (layer.id === 'proportionality') {
                        if (layer.data.ratio !== undefined) {
                            detailsHTML = `<strong>Output/Input Ratio:</strong> ${layer.data.ratio.toFixed(2)}`;
                        }
                    }

                    if (detailsHTML) {
                        detailsEl.innerHTML = detailsHTML;
                        detailsEl.style.display = 'block';
                    }
                }
            });

            // ========================================
            // 3. ERRORS & WARNINGS
            // ========================================
            const allIssues = [];

            // Collect issues from all layers
            layers.forEach(layer => {
                if (layer.data?.errors && layer.data.errors.length > 0) {
                    layer.data.errors.forEach(err => {
                        allIssues.push({
                            layer: layer.id,
                            type: 'error',
                            message: err
                        });
                    });
                }
                if (layer.data?.warnings && layer.data.warnings.length > 0) {
                    layer.data.warnings.forEach(warn => {
                        allIssues.push({
                            layer: layer.id,
                            type: 'warning',
                            message: warn
                        });
                    });
                }
            });

            // Display issues if any
            const issuesDiv = document.getElementById('validationIssues');
            const issuesList = document.getElementById('validationIssuesList');

            if (allIssues.length > 0 && issuesDiv && issuesList) {
                let issuesHTML = '<ul style="margin: 0; padding-left: 20px;">';
                allIssues.forEach(issue => {
                    const icon = issue.type === 'error' ? '‚ùå' : '‚ö†Ô∏è';
                    const layerName = issue.layer.charAt(0).toUpperCase() + issue.layer.slice(1);
                    issuesHTML += `<li style="margin-bottom: 8px;"><strong>${icon} ${layerName}:</strong> ${issue.message}</li>`;
                });
                issuesHTML += '</ul>';

                issuesList.innerHTML = issuesHTML;
                issuesDiv.style.display = 'block';
            } else if (issuesDiv) {
                issuesDiv.style.display = 'none';
            }

            // Show the validation tab button
            const validationTabButton = document.getElementById('validation-tab-button');
            if (validationTabButton) {
                validationTabButton.style.display = 'inline-block';
            }

            // Note: Tab switching is handled by calling code to allow review tab priority

            console.log('‚úÖ Validation results displayed successfully');
        }

        // Initialize on load
        // ============================================================
        // APPLICATION INITIALIZATION
        // ============================================================
        window.addEventListener('load', () => {
            try {
                console.log('üé¨ Starting application initialization...');

                // Run startup validation
                const validationPassed = validateStartup();
                if (!validationPassed) {
                    console.error('‚ùå Startup validation failed!');
                    return;
                }

                console.log('‚úÖ Startup validation passed');

                // Initialize components
                console.log('üîë Loading API key...');
                loadAPIKey();

                console.log('üé§ Initializing speech recognition...');
                initSpeechRecognition();

                console.log('üìä Updating word count...');
                updateWordCount();

                console.log('üíæ Loading saved scale data...');
                loadScaleResponsesFromStorage();

                console.log('üìö Loading uploaded documents...');
                loadUploadedDocumentsFromStorage();

                console.log('‚öïÔ∏è  Initializing clinical scales...');
                initializeScales();

                console.log('üîÑ Restoring panel states...');
                restorePanelStates();

                // Update word count as user types
                const transcriptEl = document.getElementById('transcript');
                if (transcriptEl) {
                    transcriptEl.addEventListener('input', updateWordCount);
                    console.log('‚úÖ Transcript input listener attached');
                } else {
                    console.error('‚ùå Transcript element not found');
                }

                // Add SOAP textarea event listeners for real-time stats
                const soapSubjective = document.getElementById('soapSubjective');
                const soapObjective = document.getElementById('soapObjective');
                const soapAssessment = document.getElementById('soapAssessment');
                const soapPlan = document.getElementById('soapPlan');

                if (soapSubjective && soapObjective && soapAssessment && soapPlan) {
                    soapSubjective.addEventListener('input', updateSOAPStats);
                    soapObjective.addEventListener('input', updateSOAPStats);
                    soapAssessment.addEventListener('input', updateSOAPStats);
                    soapPlan.addEventListener('input', updateSOAPStats);
                    console.log('‚úÖ SOAP Quick-Entry input listeners attached');
                } else {
                    console.error('‚ùå One or more SOAP textarea elements not found');
                }

                // Attach event listener to attending summary textarea for live stats
                const attendingSummaryText = document.getElementById('attendingSummaryText');
                if (attendingSummaryText) {
                    attendingSummaryText.addEventListener('input', function() {
                        updateSummaryStats(this.value);
                    });
                    console.log('‚úÖ Attending summary stats listener attached');
                } else {
                    console.error('‚ùå Attending summary textarea not found');
                }

                // Initialize enhancement toggles state
                updateEnhancementToggles();
                console.log('‚úÖ Enhancement toggles initialized');

                console.log('üéâ Application initialization complete!');
                console.log('‚ïê'.repeat(60));

            } catch (error) {
                console.error('üö® CRITICAL ERROR during initialization:', error);
                console.error('Stack trace:', error.stack);
                alert(`Critical error during startup: ${error.message}\n\nPlease refresh the page. If the problem persists, check the browser console (F12).`);
            }
        });
    </script>
</body>
</html>
