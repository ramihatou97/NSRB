<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src https://generativelanguage.googleapis.com; img-src 'self' data:;">
    <title>NeuroScribe V10.2.4 ENHANCED ULTRATHINK - Semantic-AI-Only ULTRATHINK + Progress Indicator + V10.2.3 Features</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #E8F4F8 0%, #F5F8FA 100%);
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        h1 {
            color: #4A90E2;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.2rem;
        }

        .version {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .grid {
            display: grid;
            grid-template-columns: 350px 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1400px) {
            .grid {
                grid-template-columns: 1fr 1fr;
            }
            .briefing-panel {
                grid-column: 1 / -1;
            }
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: #FAFBFC;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #E1E4E8;
        }

        #aiDocPanel {
            resize: both;
            overflow: auto;
            min-width: 400px;
            min-height: 500px;
        }

        .panel h2 {
            color: #333;
            margin-bottom: 12px;
            font-size: 1.3rem;
        }

        textarea {
            width: 100%;
            min-height: 300px;
            padding: 12px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.95rem;
            resize: both;
            overflow: auto;
            margin-bottom: 10px;
        }

        textarea:focus {
            outline: none;
            border-color: #4A90E2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        button {
            padding: 8px 16px;
            background: #4A90E2;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            margin: 3px;
            transition: all 0.2s;
        }

        button:hover {
            background: #5BA3F5;
            box-shadow: 0 2px 8px rgba(74, 144, 226, 0.25);
        }

        button:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
        }

        button.success {
            background: #10b981;
        }

        button.success:hover {
            background: #059669;
        }

        button.danger {
            background: #ef4444;
        }

        button.danger:hover {
            background: #dc2626;
        }

        button.warning {
            background: #f59e0b;
        }

        button.warning:hover {
            background: #d97706;
        }

        .status {
            text-align: center;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .status.connected {
            background: #d1fae5;
            color: #065f46;
        }

        .status.disconnected {
            background: #fee2e2;
            color: #991b1b;
        }

        .status.recording {
            background: #fef3c7;
            color: #92400e;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .buttons button {
            flex: 1;
            min-width: 100px;
        }

        .info {
            background: #EBF5FB;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 0.85rem;
            border-left: 3px solid #4A90E2;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: white;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #E1E4E8;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 600;
            color: #4A90E2;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 4px;
        }

        .recording-controls {
            margin-bottom: 15px;
        }

        /* Pathology Button Styles */
        .pathology-btn {
            padding: 6px 10px;
            background: white;
            color: #6b7280;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0;
        }

        .pathology-btn:hover {
            background: #f9fafb;
            border-color: #4A90E2;
            box-shadow: 0 1px 4px rgba(74, 144, 226, 0.15);
        }

        .pathology-btn.active {
            background: #4A90E2;
            color: white;
            border-color: #4A90E2;
        }

        /* Tab Navigation Styles */
        .tab-buttons {
            display: flex;
            gap: 3px;
            margin-bottom: 12px;
            border-bottom: 1px solid #E1E4E8;
        }

        .tab-button {
            flex: 1;
            padding: 8px 16px;
            background: transparent;
            color: #6b7280;
            border: none;
            border-bottom: 2px solid transparent;
            border-radius: 0;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            margin: 0;
        }

        .tab-button:hover {
            background: #f9fafb;
            color: #4A90E2;
            transform: none;
            box-shadow: none;
        }

        .tab-button.active {
            color: #4A90E2;
            border-bottom-color: #4A90E2;
            background: transparent;
            font-weight: 500;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .formatted-output {
            background: white;
            padding: 15px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            min-height: 300px;
            max-height: none;
            overflow: auto;
            resize: both;
            font-family: 'Georgia', serif;
            line-height: 1.6;
        }

        .formatted-output h1 {
            color: #333;
            font-size: 1.4rem;
            margin-bottom: 12px;
            border-bottom: 2px solid #4A90E2;
            padding-bottom: 8px;
        }

        .formatted-output h2 {
            color: #4A90E2;
            font-size: 1.15rem;
            margin-top: 16px;
            margin-bottom: 8px;
        }

        .formatted-output h3 {
            color: #374151;
            font-size: 0.95rem;
            margin-top: 12px;
            margin-bottom: 6px;
        }

        .formatted-output ul {
            margin-left: 20px;
        }

        .formatted-output p {
            margin: 10px 0;
        }

        .export-options {
            display: grid;
            gap: 15px;
        }

        .export-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .export-row label {
            min-width: 120px;
            font-weight: 600;
        }

        .export-row select {
            flex: 1;
            padding: 8px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        /* Collapsible Panel Styles */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .panel-header h2 {
            margin: 0;
        }

        .collapse-icon {
            font-size: 1.2rem;
            color: #4A90E2;
            transition: transform 0.3s;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .panel-content {
            max-height: 2000px;
            overflow: auto;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
            pointer-events: auto;
        }

        .panel-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            pointer-events: none;
        }

        /* SOAP Quick-Entry Panel Styles */
        .soap-panel {
            grid-column: 1 / -1;  /* Span full width on all screen sizes */
        }

        .soap-section {
            margin-bottom: 15px;
        }

        .soap-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border: 1px solid #E1E4E8;
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: inherit;
            resize: both;
            overflow: auto;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .soap-textarea:focus {
            outline: none;
            border-color: #4A90E2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .soap-textarea::placeholder {
            color: #9ca3af;
            font-style: italic;
        }

        /* Enhancement Toggle Disabled State */
        input[type="checkbox"]:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        label:has(input[type="checkbox"]:disabled) {
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h1 style="margin: 0;">üß† NeuroScribe V10.2.4 ENHANCED ULTRATHINK - Professional Clinical Intelligence</h1>
            <div style="display: flex; align-items: center; gap: 15px;">
                <div id="apiKeyStatus" style="font-size: 0.85rem; color: #6b7280;"></div>
                <button onclick="openSettings()" style="padding: 8px 16px; background: #4A90E2; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                    ‚öôÔ∏è Settings
                </button>
            </div>
        </div>
        <div class="version">V10.2.4 ENHANCED ULTRATHINK: Semantic-AI-Only ULTRATHINK | Progress Indicator | V10.2.3 Features (Sentence Tracking | Multiple Fix Options | Score Transparency)</div>

        <div id="status" class="status disconnected">
            üîë Checking API key...
        </div>

        <!-- V10.2.4 PHASE 1.2: ULTRATHINK Regeneration Progress Indicator -->
        <div id="resolution-progress-container" style="display: none; margin: 20px auto; max-width: 800px; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.15);">
            <div style="color: white; font-weight: 600; font-size: 1.1rem; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                <span id="resolution-progress-icon">üîÑ</span>
                <span id="resolution-progress-text">Processing resolutions...</span>
            </div>
            <div style="background: rgba(255,255,255,0.2); border-radius: 8px; height: 30px; overflow: hidden; position: relative;">
                <div id="resolution-progress-bar" style="background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%); height: 100%; width: 0%; transition: width 0.5s ease, background 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 0.9rem; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
                    <span id="resolution-progress-percent">0%</span>
                </div>
            </div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.85rem; margin-top: 8px; font-style: italic;" id="resolution-progress-stage">
                Initializing...
            </div>
            <div style="color: rgba(255,255,255,0.8); font-size: 0.75rem; margin-top: 4px;" id="resolution-progress-eta">
                Estimated time: Calculating...
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settingsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 10000; justify-content: center; align-items: center;">
            <div style="background: white; border-radius: 12px; padding: 30px; max-width: 600px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.2);">
                <h2 style="color: #4A90E2; margin-bottom: 15px; font-size: 1.4rem;">‚öôÔ∏è API Key Settings</h2>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 500; margin-bottom: 8px; color: #333; font-size: 0.9rem;">
                        Google Gemini API Key:
                    </label>
                    <input
                        type="password"
                        id="apiKeyInput"
                        placeholder="AIzaSy... (paste your API key here)"
                        style="width: 100%; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: monospace;"
                    />
                    <div style="margin-top: 6px; font-size: 0.8rem; color: #6b7280;">
                        Your API key is encrypted and stored locally in your browser. It never leaves your device.
                    </div>
                </div>

                <div style="background: #EBF5FB; padding: 12px; border-radius: 6px; margin-bottom: 15px; border-left: 3px solid #4A90E2;">
                    <strong style="font-size: 0.9rem;">üìå Don't have an API key?</strong><br>
                    <div style="margin-top: 6px; font-size: 0.85rem; line-height: 1.6;">
                        1. Visit <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: #4A90E2; text-decoration: underline;">Google AI Studio</a><br>
                        2. Sign in with your Google account<br>
                        3. Click "Create API Key"<br>
                        4. Copy the key and paste it above<br>
                        5. It's FREE with generous limits!
                    </div>
                </div>

                <div id="apiKeyStatusModal" style="margin-bottom: 15px; padding: 10px; border-radius: 6px; display: none; font-size: 0.9rem;"></div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                    <button onclick="saveAPIKey()" style="padding: 10px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        üíæ Save & Test
                    </button>
                    <button onclick="testAPIKey()" style="padding: 10px; background: #4A90E2; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        üß™ Test Key
                    </button>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <button onclick="clearAPIKey()" style="padding: 10px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        üóëÔ∏è Clear Key
                    </button>
                    <button onclick="closeSettings()" style="padding: 10px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">
                        Cancel
                    </button>
                </div>

                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 0.85rem; color: #666;">
                    <strong>üîí Privacy & Security:</strong><br>
                    ‚Ä¢ API key stored locally in your browser only<br>
                    ‚Ä¢ Encrypted using Base64 + character reversal<br>
                    ‚Ä¢ No server storage - your key never leaves your device<br>
                    ‚Ä¢ Clear browser data to remove the key
                </div>
            </div>
        </div>

        <div class="grid">
            <!-- Briefing Panel: Pre-Consultation Research -->
            <div class="panel briefing-panel">
                <div class="panel-header" onclick="togglePanel('briefing')">
                    <h2>üî¨ Pre-Consultation Briefing</h2>
                    <span class="collapse-icon" id="briefing-icon">‚ñº</span>
                </div>

                <div class="panel-content" id="briefing-content">
                <div class="info" style="margin-bottom: 12px;">
                    <strong>Expert Analysis:</strong> Enter specific pathology or select common category for deep research
                </div>

                <!-- Custom Pathology Input -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">Specific Pathology / Diagnosis:</label>
                    <input
                        type="text"
                        id="customPathology"
                        placeholder="e.g., C5-6 foraminal stenosis with radiculopathy, diffuse low-grade glioma..."
                        style="width: 100%; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; margin-bottom: 8px;"
                        oninput="onCustomPathologyInput()"
                    />
                    <div style="font-size: 0.8rem; color: #666; font-style: italic;">
                        Enter specific pathology for deep search, or select common category below
                    </div>
                </div>

                <!-- Pathology Quick-Select -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">Or select common pathology:</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="selectPathology('spine-degenerative')" class="pathology-btn" data-pathology="spine-degenerative">
                            ü¶¥ Spine Deg
                        </button>
                        <button onclick="selectPathology('spine-trauma')" class="pathology-btn" data-pathology="spine-trauma">
                            ‚ö†Ô∏è Trauma
                        </button>
                        <button onclick="selectPathology('brain-tumor')" class="pathology-btn" data-pathology="brain-tumor">
                            üß† Tumor
                        </button>
                        <button onclick="selectPathology('vascular')" class="pathology-btn" data-pathology="vascular">
                            üíâ Vascular
                        </button>
                        <button onclick="selectPathology('hydrocephalus')" class="pathology-btn" data-pathology="hydrocephalus">
                            üíß Hydro
                        </button>
                        <button onclick="selectPathology('functional')" class="pathology-btn" data-pathology="functional">
                            ‚öôÔ∏è Functional
                        </button>
                        <button onclick="selectPathology('pediatric')" class="pathology-btn" data-pathology="pediatric">
                            üë∂ Pediatric
                        </button>
                        <button onclick="selectPathology('peripheral')" class="pathology-btn" data-pathology="peripheral">
                            üîå Peripheral
                        </button>
                    </div>
                </div>

                <!-- Research Depth -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">Research Depth:</label>
                    <select id="briefingDepth" style="width: 100%; padding: 8px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem;">
                        <option value="quick">Quick Overview (30 sec)</option>
                        <option value="standard" selected>Standard Briefing (1 min)</option>
                        <option value="comprehensive">Comprehensive (2 min)</option>
                    </select>
                </div>

                <!-- Expert Document Upload -->
                <div style="margin-bottom: 12px; border: 2px dashed #E1E4E8; border-radius: 6px; padding: 12px; background: #FAFBFC;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem;">
                        üìö Upload Expert Documents (Optional):
                    </label>
                    <div style="font-size: 0.8rem; color: #666; margin-bottom: 10px;">
                        Upload research papers, guidelines, or notes to enrich the briefing
                    </div>
                    <input
                        type="file"
                        id="expertDocUpload"
                        accept=".txt,.pdf,.doc,.docx"
                        multiple
                        style="width: 100%; padding: 8px; font-size: 0.85rem;"
                        onchange="handleDocumentUpload(event)"
                    />
                    <div id="uploadedDocs" style="margin-top: 10px; font-size: 0.8rem; color: #333;">
                    </div>
                    <!-- Document Storage Management UI -->
                    <div id="documentStorageUI"></div>
                </div>

                <!-- Generate Button -->
                <button onclick="generateDeepBriefing()" id="briefingBtn" class="success" style="width: 100%; margin-bottom: 15px;" disabled>
                    üéØ Generate Deep Research + Checklist
                </button>

                <!-- Briefing Output -->
                <div id="briefingOutput" style="background: white; border: 1px solid #E1E4E8; border-radius: 6px; padding: 12px; min-height: 200px; max-height: none; overflow: auto; resize: both; font-size: 0.85rem; line-height: 1.5;">
                    <p style="color: #9ca3af; text-align: center; padding: 30px 10px;">
                        Select a pathology type to generate pre-consultation briefing
                    </p>
                </div>
                </div>
            </div>

            <!-- Transcript Panel: Input -->
            <div class="panel">
                <div class="panel-header" onclick="togglePanel('transcript')">
                    <h2>üìù Clinical Transcript</h2>
                    <span class="collapse-icon" id="transcript-icon">‚ñº</span>
                </div>

                <div class="panel-content" id="transcript-content">

                <!-- Consultation Type Selector -->
                <div style="margin-bottom: 12px; background: #EBF5FB; padding: 12px; border-radius: 6px; border-left: 3px solid #4A90E2;">
                    <label style="display: block; font-weight: 500; margin-bottom: 8px; color: #333; font-size: 0.9rem;">
                        üìã Consultation Type:
                    </label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="selectConsultType('new')" id="consultTypeNew" class="consult-type-btn" style="padding: 10px; border: 2px solid #4A90E2; border-radius: 6px; background: #4A90E2; color: white; cursor: pointer; font-weight: 500; transition: all 0.2s; font-size: 0.9rem;">
                            üÜï New Consultation
                        </button>
                        <button onclick="selectConsultType('followup')" id="consultTypeFollowup" class="consult-type-btn" style="padding: 10px; border: 2px solid #E1E4E8; border-radius: 6px; background: white; color: #333; cursor: pointer; font-weight: 500; transition: all 0.2s; font-size: 0.9rem;">
                            üîÑ Follow-up Visit
                        </button>
                    </div>
                    <div id="consultTypeDescription" style="margin-top: 8px; font-size: 0.8rem; color: #6b7280;">
                        <strong>New Consultation:</strong> Comprehensive initial assessment with full history, examination, and workup.
                    </div>
                </div>

                <!-- Reason for Consultation Panel -->
                <div style="margin-bottom: 15px; background: #F0F9FF; padding: 12px; border-radius: 6px; border-left: 3px solid #0EA5E9;">
                    <label style="display: block; font-weight: 500; margin-bottom: 8px; color: #333; font-size: 0.9rem;">
                        üìã Reason for Consultation (Chief Complaint)
                    </label>
                    <input type="text"
                           id="reasonForConsult"
                           placeholder="e.g., L4-5 disc herniation with radiculopathy, C5-6 cervical myelopathy"
                           style="width: 100%; padding: 10px; border: 1px solid #CBD5E1; border-radius: 4px; font-size: 0.9rem; font-family: inherit;"
                           oninput="updateReasonForConsult(this.value)">
                    <small style="color: #6B7280; font-size: 0.75rem; display: block; margin-top: 6px;">
                        üí° Optional: Leave blank to auto-detect from transcript
                    </small>

                    <!-- Auto-Activation Control -->
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #E2E8F0;">
                        <label style="display: flex; align-items: center; cursor: pointer; font-size: 0.85rem;">
                            <input type="checkbox"
                                   id="autoDeepSearchToggle"
                                   onchange="toggleAutoDeepSearch(this.checked)"
                                   style="margin-right: 8px; width: 16px; height: 16px; cursor: pointer;">
                            <span style="color: #334155;">
                                ü§ñ Auto-activate <strong>Comprehensive</strong> deep search if no pre-briefing done
                            </span>
                        </label>
                        <small style="color: #6B7280; font-size: 0.7rem; display: block; margin-left: 24px; margin-top: 4px;">
                            When enabled: System will automatically research the pathology before generating note
                        </small>
                    </div>
                </div>

                <!-- Transcript Enhancement Mode Toggle -->
                <div style="margin-bottom: 15px; background: #E3F2FD; padding: 12px; border-radius: 6px; border-left: 3px solid #2196F3;">
                    <label style="display: flex; align-items: flex-start; cursor: pointer; font-size: 0.9rem;" id="transcriptEnhanceLabel">
                        <input type="checkbox" id="transcriptEnhanceToggle" onchange="toggleTranscriptEnhancement()"
                               style="margin-right: 10px; margin-top: 2px; width: 18px; height: 18px; cursor: pointer; flex-shrink: 0;"
                               disabled>
                        <div>
                            <strong>ü§ñ Enhanced Mode:</strong> Add briefing-based clinical analysis & recommendations<br>
                            <span style="font-size: 0.75rem; color: #666; font-style: italic;">
                                Unchecked = Expand only | Checked = Briefing Integration + Analysis
                            </span>
                        </div>
                    </label>

                    <div id="transcriptEnhanceWarning" style="display: block; margin-top: 8px; padding: 8px; background: #FFF3CD; border-radius: 4px; font-size: 0.75rem;">
                        üí° <strong>Note:</strong> Generate a briefing first to enable Enhanced Mode
                    </div>
                </div>

                <div class="info">
                    <strong>üé§ New:</strong> Use voice recording or type/paste your transcript
                </div>

                <!-- Recording Controls -->
                <div class="recording-controls">
                    <div class="buttons">
                        <button onclick="startRecording()" id="startBtn">
                            üé§ Start Recording
                        </button>
                        <button onclick="stopRecording()" id="stopBtn" disabled>
                            ‚èπÔ∏è Stop
                        </button>
                        <button onclick="pauseRecording()" id="pauseBtn" class="warning" disabled>
                            ‚è∏Ô∏è Pause
                        </button>
                        <button onclick="clearText()">
                            üóëÔ∏è Clear
                        </button>
                    </div>
                </div>

                <textarea
                    id="transcript"
                    placeholder="Click 'Start Recording' to use voice transcription, or type/paste your clinical encounter transcript here..."
                ></textarea>

                <!-- Stats -->
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="wordCount">0</div>
                        <div class="stat-label">Words</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="duration">00:00</div>
                        <div class="stat-label">Duration</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="confidence">--</div>
                        <div class="stat-label">Confidence</div>
                    </div>
                </div>
                </div>
            </div>

            <!-- SOAP Quick-Entry Panel: Structured Input -->
            <div class="panel soap-panel">
                <div class="panel-header" onclick="togglePanel('soap')">
                    <h2>üìã SOAP Quick-Entry</h2>
                    <span class="collapse-icon" id="soap-icon">‚ñº</span>
                </div>

                <div class="panel-content" id="soap-content">
                <div class="info" style="background: #FFF3CD; border-left: 3px solid #FFA500;">
                    <strong>üìã Quick Entry Mode:</strong> Enter brief headnotes or bullet points - AI will expand into professional clinical documentation
                </div>

                <!-- Enhancement Mode Toggle -->
                <div style="margin-bottom: 15px; background: #E8F5E9; padding: 12px; border-radius: 6px; border-left: 3px solid #4CAF50;">
                    <label style="display: flex; align-items: flex-start; cursor: pointer; font-size: 0.9rem;">
                        <input type="checkbox" id="soapEnhanceToggle" onchange="toggleSOAPEnhancement()" style="margin-right: 10px; margin-top: 2px; width: 18px; height: 18px; cursor: pointer; flex-shrink: 0;">
                        <div>
                            <strong>ü§ñ V10 Pure Enhancement:</strong> AI suggestions in separate sections (never mixed with your notes)<br>
                            <span style="font-size: 0.75rem; color: #666; font-style: italic;">
                                ‚úÖ Unchecked = Expand only | ‚úÖ Checked = Expand + AI suggestions (fully separated)
                            </span>
                        </div>
                    </label>

                    <div id="enhanceWarning" style="display: none; margin-top: 8px; padding: 8px; background: #E3F2FD; border-radius: 4px; font-size: 0.75rem;">
                        ‚ÑπÔ∏è <strong>V10 Note:</strong> SOAP expand mode only uses information from your notes - briefing is NOT used
                    </div>
                </div>

                <!-- Input Mode Toggle: Simple (Unified) vs Advanced (4-Box) -->
                <div style="margin-bottom: 15px; background: #E3F2FD; padding: 12px; border-radius: 6px; border-left: 3px solid #2196F3;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                        <strong style="font-size: 0.9rem;">üìù Input Mode:</strong>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <button id="simpleModeBtn" onclick="switchSOAPMode('simple')"
                                    style="padding: 6px 12px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: 600;">
                                Simple (1 Box)
                            </button>
                            <button id="advancedModeBtn" onclick="switchSOAPMode('advanced')"
                                    style="padding: 6px 12px; background: #E0E0E0; color: #666; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: 600;">
                                Advanced (4 Boxes)
                            </button>
                        </div>
                    </div>
                    <div style="font-size: 0.75rem; color: #555;">
                        <span id="modeDescription">
                            <strong>Simple:</strong> Enter all SOAP sections in one textbox (AI will intelligently parse sections)
                        </span>
                    </div>
                </div>

                <!-- SIMPLE MODE: Unified SOAP Input -->
                <div id="soapUnifiedContainer" style="display: block; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #2196F3;">‚úèÔ∏è</span> Clinical Documentation:
                        </label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <span id="parseMethod" style="font-size: 0.7rem; color: #999; padding: 2px 6px; background: #F5F5F5; border-radius: 3px;">Not parsed</span>
                            <span style="font-size: 0.75rem; color: #999;">Format: S: / O: / A: / P: or free text</span>
                        </div>
                    </div>
                    <textarea
                        id="soapUnifiedInput"
                        class="soap-textarea"
                        placeholder="Enter clinical notes in any format:&#10;&#10;LABELED FORMAT (Recommended):&#10;S: 45F neck pain x 3wks, worse w/ extension, denies numbness, failed NSAIDs&#10;O: Spurling+ left, motor 5/5, decreased C6 sensation left&#10;A: C5-6 foraminal stenosis with left C6 radiculopathy&#10;P: MRI cervical spine, continue NSAIDs, PT, F/U 4wks&#10;&#10;FREE TEXT FORMAT (AI will parse):&#10;Patient reports 3 weeks of neck pain that worsens with extension. No numbness. NSAIDs haven't helped. Exam shows positive Spurling test on left, motor strength 5/5, decreased C6 sensation. Impression is C5-6 foraminal stenosis with left C6 radiculopathy. Plan for MRI, NSAIDs, PT, follow-up in 4 weeks."
                        oninput="updateUnifiedStats()"
                        style="width: 100%; min-height: 200px; padding: 12px; border: 2px solid #2196F3; border-radius: 6px; font-size: 0.9rem; font-family: 'Courier New', monospace; resize: both; line-height: 1.6;"
                    ></textarea>

                    <!-- Parse Preview Button -->
                    <div style="margin-top: 10px; display: flex; gap: 10px; align-items: center;">
                        <button onclick="previewSOAPParsing()"
                                style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 600;">
                            üîç Preview Parsing
                        </button>
                        <span id="parseConfidence" style="font-size: 0.8rem; color: #666;"></span>
                    </div>
                </div>

                <!-- ADVANCED MODE: 4 Separate Textareas (Original) -->
                <div id="soapSeparateContainer" style="display: none;">
                <!-- SOAP Section: Subjective -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Subjective (Patient History):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">bullets or brief phrases</span>
                    </div>
                    <textarea
                        id="soapSubjective"
                        class="soap-textarea"
                        placeholder="Enter brief notes, e.g.:&#10;‚Ä¢ Neck pain x 3 weeks&#10;‚Ä¢ Worse with extension&#10;‚Ä¢ Denies numbness&#10;‚Ä¢ Failed NSAIDs"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: both;"
                    ></textarea>
                </div>

                <!-- SOAP Section: Objective -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Objective (Examination):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">findings only</span>
                    </div>
                    <textarea
                        id="soapObjective"
                        class="soap-textarea"
                        placeholder="Enter exam findings, e.g.:&#10;‚Ä¢ Spurling test positive left&#10;‚Ä¢ Motor 5/5 throughout&#10;‚Ä¢ Decreased C6 sensation left"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: both;"
                    ></textarea>
                </div>

                <!-- SOAP Section: Assessment -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Assessment (Diagnosis):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">your impression</span>
                    </div>
                    <textarea
                        id="soapAssessment"
                        class="soap-textarea"
                        placeholder="Enter diagnosis/impression, e.g.:&#10;‚Ä¢ C5-6 foraminal stenosis with left C6 radiculopathy"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 60px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: both;"
                    ></textarea>
                </div>

                <!-- SOAP Section: Plan -->
                <div class="soap-section" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="font-weight: 600; color: #333; font-size: 0.95rem;">
                            <span style="color: #4A90E2;">‚óè</span> Plan (Management):
                        </label>
                        <span style="font-size: 0.75rem; color: #999;">treatment & follow-up</span>
                    </div>
                    <textarea
                        id="soapPlan"
                        class="soap-textarea"
                        placeholder="Enter management plan, e.g.:&#10;‚Ä¢ MRI cervical spine&#10;‚Ä¢ Continue NSAIDs&#10;‚Ä¢ PT for cervical strengthening&#10;‚Ä¢ F/U 4 weeks with MRI"
                        oninput="updateSOAPStats()"
                        style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #E1E4E8; border-radius: 6px; font-size: 0.9rem; font-family: inherit; resize: both;"
                    ></textarea>
                </div>
                </div>
                <!-- End of Advanced Mode Container -->

                <!-- Stats -->
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="soapTotalWords">0</div>
                        <div class="stat-label">Total Words</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="soapSectionCount">0/4</div>
                        <div class="stat-label">Sections</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="soapMode">Expand</div>
                        <div class="stat-label">Mode</div>
                    </div>
                </div>
                </div>
            </div>

            <!-- Right Panel: Output with Tabs -->
            <div class="panel" id="aiDocPanel">
                <h2>ü§ñ AI-Generated Documentation</h2>

                <button onclick="generate()" class="success" id="generateBtn" style="width: 100%; margin-bottom: 15px;">
                    ‚ö° Generate Clinical Note
                </button>

                <!-- Tab Navigation -->
                <div class="tab-buttons">
                    <button class="tab-button active" onclick="switchTab('formatted')">
                        üìÑ Formatted Note
                    </button>
                    <button class="tab-button" onclick="switchTab('raw')">
                        üìù Raw Output
                    </button>
                    <button class="tab-button" onclick="switchTab('scales')">
                        üìä Clinical Scales
                    </button>
                    <button class="tab-button" onclick="switchTab('export')">
                        üíæ Export Options
                    </button>
                    <button class="tab-button" onclick="switchTab('review')" id="review-tab-button" style="display: none;">
                        üîç Review Suggestions
                    </button>
                    <button class="tab-button" onclick="switchTab('attending')" id="attending-tab-button" style="display: none;">
                        üìä Attending Summary
                    </button>
                    <button class="tab-button" onclick="switchTab('validation')" id="validation-tab-button" style="display: none;">
                        üîç Quality Report
                    </button>
                </div>

                <!-- Tab 1: Formatted Note -->
                <div class="tab-content active" id="tab-formatted">
                    <div class="formatted-output" id="formattedOutput">
                        <p style="color: #999; text-align: center; padding: 50px;">
                            Generate documentation to see formatted output here
                        </p>
                    </div>
                    <div class="buttons" style="margin-top: 15px;">
                        <button onclick="copyFormatted()">üìã Copy</button>
                        <button onclick="printFormatted()">üñ®Ô∏è Print</button>
                    </div>
                </div>

                <!-- Tab 2: Raw Output -->
                <div class="tab-content" id="tab-raw">
                    <textarea
                        id="output"
                        placeholder="Raw markdown output will appear here..."
                        readonly
                    ></textarea>
                    <div class="buttons" style="margin-top: 15px;">
                        <button onclick="copyOutput()">üìã Copy</button>
                        <button onclick="downloadOutput()">üíæ Download TXT</button>
                    </div>
                </div>

                <!-- Tab 3: Clinical Scales -->
                <div class="tab-content" id="tab-scales">
                    <div class="scales-container">
                        <div class="scale-selector" style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 10px; font-weight: 600; color: #333;">
                                Select Clinical Scale:
                            </label>
                            <select id="scaleSelect" onchange="loadScaleForm()" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem; margin-bottom: 15px;">
                                <option value="">-- Select a Scale --</option>
                            </select>
                        </div>

                        <div id="scaleFormContainer" style="display: none;">
                            <div id="scaleDescription" style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #0066CC;">
                            </div>

                            <div id="scaleQuestions" style="margin-bottom: 20px;">
                            </div>

                            <button onclick="calculateScale()" class="success" style="width: 100%; margin-bottom: 15px;">
                                üßÆ Calculate Score
                            </button>

                            <div id="scaleResults" style="display: none; background: #f9f9f9; padding: 20px; border-radius: 8px; border: 2px solid #ddd;">
                            </div>
                        </div>

                        <div id="scalesPlaceholder" style="text-align: center; padding: 50px; color: #999;">
                            <p>Select a clinical scale to begin assessment</p>
                            <p style="font-size: 0.9rem; margin-top: 10px;">Scales will be automatically suggested based on selected pathology</p>
                        </div>
                    </div>
                </div>

                <!-- Tab 4: Export Options -->
                <div class="tab-content" id="tab-export">
                    <div class="export-options">
                        <div class="export-row">
                            <label>Format:</label>
                            <select id="exportFormat">
                                <option value="txt">Plain Text (.txt)</option>
                                <option value="docx">Word Document (.docx)</option>
                                <option value="pdf">PDF Document (.pdf)</option>
                                <option value="json">JSON Data (.json)</option>
                                <option value="html">HTML Page (.html)</option>
                            </select>
                        </div>
                        <div class="export-row">
                            <label>Include:</label>
                            <select id="exportIncludes">
                                <option value="full">Full Documentation</option>
                                <option value="summary">Summary Only</option>
                                <option value="plan">Assessment & Plan Only</option>
                            </select>
                        </div>
                        <button onclick="doExport()" class="success" style="width: 100%;">
                            üì• Export Document
                        </button>
                    </div>
                </div>

                <!-- Tab: Review AI Suggestions (V6) -->
                <div class="tab-content" id="tab-review" style="display: none;">
                    <div style="background: #FFF3CD; padding: 14px; border-radius: 6px; margin-bottom: 20px; border-left: 4px solid #FFC107;">
                        <strong>üìã Review AI Suggestions:</strong> Check items to keep in your final note, or uncheck to discard.
                        Linked suggestions have dependencies on other items.
                    </div>

                    <div id="reviewInterface" style="margin-bottom: 20px;">
                        <p style="color: #666; text-align: center; padding: 40px; font-style: italic;">
                            Generate a note with Enhanced Mode to see AI suggestions here.
                        </p>
                    </div>

                    <div style="margin-top: 20px; display: flex; gap: 12px; padding: 15px; background: #f6f8fa; border-radius: 6px;">
                        <button onclick="selectAllSuggestions()" class="success" style="flex: 1; padding: 12px;">
                            ‚úÖ Keep All
                        </button>
                        <button onclick="deselectAllSuggestions()" class="warning" style="flex: 1; padding: 12px;">
                            ‚ùå Discard All
                        </button>
                        <button onclick="generateFinalNote()" class="success" style="flex: 2; padding: 12px; font-weight: 600;">
                            üìÑ Generate Final Note
                        </button>
                    </div>
                </div>

                <!-- Tab: Validation Quality Report (V8) -->
                <div class="tab-content" id="tab-validation" style="display: none;">
                    <!-- Validation Header -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 8px; margin-bottom: 20px; color: white;">
                        <h2 style="margin: 0 0 10px 0; font-size: 1.5rem; color: white;">üîç Quality Validation Report</h2>
                        <p style="margin: 0; opacity: 0.9; font-size: 0.9rem;">6-Layer Industrial-Grade Validation Analysis</p>
                    </div>

                    <!-- Overall Quality Score -->
                    <div id="validationOverallScore" style="background: #f9f9f9; padding: 25px; border-radius: 8px; margin-bottom: 20px; text-align: center; border: 2px solid #ddd;">
                        <div style="font-size: 0.9rem; color: #666; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Overall Quality Score</div>
                        <div id="qualityScoreDisplay" style="font-size: 3.5rem; font-weight: bold; margin: 15px 0; color: #999;">--</div>
                        <div id="qualityBadgeDisplay" style="display: inline-block; padding: 8px 20px; border-radius: 20px; font-weight: 600; font-size: 0.9rem; background: #e0e0e0; color: #666;">
                            ‚è≥ Awaiting Validation
                        </div>

                        <!-- V10.2.3: Score Transparency Breakdown -->
                        <div id="scoreBreakdownToggle" style="margin-top: 15px; display: none;">
                            <button onclick="toggleScoreBreakdown()" style="background: #0969da; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 600;">
                                üìä Show Calculation Breakdown
                            </button>
                        </div>

                        <div id="scoreBreakdown" style="display: none; margin-top: 20px; padding: 20px; background: white; border-radius: 6px; border: 2px solid #0969da; text-align: left;">
                            <div style="font-weight: 600; color: #0969da; margin-bottom: 15px; font-size: 1rem;">üîç How Overall Score is Calculated</div>

                            <div style="margin-bottom: 12px;">
                                <div style="font-weight: 600; color: #333; margin-bottom: 5px;">üì• Extraction Score (60% weight)</div>
                                <div id="extractionScoreDetail" style="color: #666; font-size: 0.9rem; margin-left: 15px;">--</div>
                            </div>

                            <div style="margin-bottom: 12px;">
                                <div style="font-weight: 600; color: #333; margin-bottom: 5px;">üì§ Output Score (40% weight)</div>
                                <div id="outputScoreDetail" style="color: #666; font-size: 0.9rem; margin-left: 15px;">--</div>
                            </div>

                            <div style="border-top: 2px dashed #ddd; padding-top: 12px; margin-top: 12px;">
                                <div style="font-weight: 600; color: #333; margin-bottom: 5px;">üßÆ Calculation Formula:</div>
                                <div id="calculationFormula" style="color: #666; font-size: 0.9rem; margin-left: 15px; font-family: monospace; background: #f6f8fa; padding: 10px; border-radius: 4px;">--</div>
                            </div>

                            <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px;">
                                <div style="font-size: 0.85rem; color: #856404;">
                                    <strong>üí° Why not a simple average?</strong><br>
                                    Extraction quality (grounding, fabrication, completeness) is weighted higher (60%) because accurate information extraction is foundational. Output quality (consistency, proportionality) is important but secondary (40%).
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 6-Layer Breakdown -->
                    <div id="validationLayersBreakdown" style="margin-bottom: 20px;">
                        <h3 style="font-size: 1.2rem; margin-bottom: 15px; color: #333;">üìä Validation Layers Breakdown</h3>

                        <!-- Layer 1: Grounding -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">üéØ Layer 1: Source Grounding</div>
                                <div id="grounding-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">--</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">Ensures generated content is grounded in source material</div>
                            <div id="grounding-progress" style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: #999; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="grounding-details" style="margin-top: 10px; font-size: 0.85rem; color: #666; display: none;"></div>
                        </div>

                        <!-- Layer 2: Fabrication Detection -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">ü§ñ Layer 2: Fabrication Detection</div>
                                <div id="fabrication-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">--</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">AI-powered hallucination detection (semantic + term-based)</div>
                            <div id="fabrication-progress" style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: #999; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="fabrication-details" style="margin-top: 10px; font-size: 0.85rem; color: #666; display: none;"></div>
                        </div>

                        <!-- Layer 3: Completeness -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">‚úÖ Layer 3: Completeness Check</div>
                                <div id="completeness-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">--</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">Bidirectional validation (notes‚Üíextraction & extraction‚Üínotes)</div>
                            <div id="completeness-progress" style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: #999; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="completeness-details" style="margin-top: 10px; font-size: 0.85rem; color: #666; display: none;"></div>
                        </div>

                        <!-- Layer 4: Consistency -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">üî¨ Layer 4: Consistency Validation</div>
                                <div id="consistency-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">--</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">Medical logic checks (functional scores, anatomical rules, cross-field validation)</div>
                            <div id="consistency-progress" style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: #999; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="consistency-details" style="margin-top: 10px; font-size: 0.85rem; color: #666; display: none;"></div>
                        </div>

                        <!-- Layer 5: Proportionality -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">üìè Layer 5: Proportionality Check</div>
                                <div id="proportionality-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">--</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">Output sizing appropriateness (not too short/long for input)</div>
                            <div id="proportionality-progress" style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: #999; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="proportionality-details" style="margin-top: 10px; font-size: 0.85rem; color: #666; display: none;"></div>
                        </div>

                        <!-- Layer 6: Confidence Calibration -->
                        <div class="validation-layer" style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: 600; color: #333;">üéöÔ∏è Layer 6: Confidence Calibration</div>
                                <div id="confidence-score" style="font-size: 1.3rem; font-weight: bold; color: #999;">N/A</div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 8px;">Multi-source confidence adjustment based on validation findings</div>
                            <div style="margin-top: 10px; font-size: 0.85rem; color: #666;">
                                Applied to extracted data (not applicable to generated notes)
                            </div>
                        </div>
                    </div>

                    <!-- Errors & Warnings -->
                    <div id="validationIssues" style="display: none; margin-bottom: 20px;">
                        <h3 style="font-size: 1.2rem; margin-bottom: 15px; color: #333;">‚ö†Ô∏è Issues & Warnings</h3>
                        <div id="validationIssuesList" style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px;">
                            <!-- Issues will be dynamically inserted here -->
                        </div>
                    </div>

                    <!-- Placeholder (shown when no validation results) -->
                    <div id="validationPlaceholder" style="text-align: center; padding: 60px 20px; color: #999;">
                        <div style="font-size: 4rem; margin-bottom: 20px; opacity: 0.3;">üîç</div>
                        <p style="font-size: 1.1rem; margin-bottom: 10px;">No validation data available</p>
                        <p style="font-size: 0.9rem;">Generate a clinical note to see quality validation results here</p>
                    </div>
                </div>

                <!-- Tab: Attending Summary (Ultra Summarizer) -->
                <div class="tab-content" id="tab-attending">
                    <!-- Compression Mode Selector -->
                    <div style="background: #f5f5f5; padding: 16px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #ddd;">
                        <strong style="color: #333; font-size: 1.1rem;">‚ö° Compression Mode:</strong>
                        <div style="display: flex; gap: 15px; margin-top: 12px; flex-wrap: wrap;">
                            <label style="flex: 1; min-width: 200px; cursor: pointer; background: white; padding: 12px; border-radius: 6px; border: 2px solid #4CAF50; transition: all 0.2s;">
                                <input type="radio" name="compressionMode" value="standard" checked onchange="updateCompressionInfo()">
                                <strong style="color: #4CAF50;">üìä Standard DOAP</strong>
                                <span id="status-standard" style="margin-left: 8px; font-size: 0.75rem; padding: 2px 6px; border-radius: 3px; background: #e0e0e0; color: #666;">‚è≥ Pending</span>
                                <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">45 seconds (~120-140 words)</div>
                            </label>
                            <label style="flex: 1; min-width: 200px; cursor: pointer; background: white; padding: 12px; border-radius: 6px; border: 2px solid #FF5722; transition: all 0.2s;">
                                <input type="radio" name="compressionMode" value="ultra" onchange="updateCompressionInfo()">
                                <strong style="color: #FF5722;">‚ö° ULTRATHINK</strong>
                                <span id="status-ultra" style="margin-left: 8px; font-size: 0.75rem; padding: 2px 6px; border-radius: 3px; background: #e0e0e0; color: #666;">‚è≥ Pending</span>
                                <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">15 seconds (~35-50 words)</div>
                            </label>
                            <!-- Telegram mode temporarily disabled due to API safety filter issues -->
                            <!--
                            <label style="flex: 1; min-width: 200px; cursor: pointer; background: white; padding: 12px; border-radius: 6px; border: 2px solid #9C27B0; transition: all 0.2s;">
                                <input type="radio" name="compressionMode" value="telegram" onchange="updateCompressionInfo()">
                                <strong style="color: #9C27B0;">üì± Telegram</strong>
                                <span id="status-telegram" style="margin-left: 8px; font-size: 0.75rem; padding: 2px 6px; border-radius: 3px; background: #e0e0e0; color: #666;">‚è≥ Pending</span>
                                <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">5 seconds (~15-25 words)</div>
                            </label>
                            -->
                        </div>
                    </div>

                    <!-- Framework Info Display (changes based on mode) -->
                    <div id="compressionInfoBox" style="background: #e3f2fd; padding: 14px; border-radius: 6px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                        <strong>üìä DOAP Framework for Attending Presentation:</strong>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                            <li><strong>D</strong> - Diagnosis (5 sec): Age, Sex, PMHx, Primary diagnosis</li>
                            <li><strong>O</strong> - One-liner (10 sec): Exam findings + Imaging results</li>
                            <li><strong>A</strong> - Assessment (10 sec): Severity + Candidacy</li>
                            <li><strong>P</strong> - Plan (20 sec): Intervention + Timing + Main concern</li>
                        </ul>
                        <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 45-second presentation to impress attending staff</p>
                    </div>

                    <textarea id="attendingSummaryText"
                              style="width: 100%; min-height: 300px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 1rem; padding: 15px; border: 2px solid #2196F3; border-radius: 6px; line-height: 1.8; resize: both;"
                              placeholder="Attending summary will appear here after note generation..."></textarea>

                    <!-- Stats Display -->
                    <div style="display: flex; justify-content: space-around; margin-top: 12px; padding: 12px; background: #f9f9f9; border-radius: 6px;">
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #2196F3;" id="summaryWordCount">0</div>
                            <div style="font-size: 12px; color: #666;">Words</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #4CAF50;" id="summarySeconds">0</div>
                            <div style="font-size: 12px; color: #666;">Seconds</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #FF9800;" id="compressionRatio">0%</div>
                            <div style="font-size: 12px; color: #666;">Compression</div>
                        </div>
                    </div>

                    <div style="margin-top: 15px; display: flex; gap: 12px;">
                        <button onclick="testAttendingSummary()" style="flex: 1; padding: 12px; background: #FF9800; color: white;">
                            üß™ Test (Use Current Note)
                        </button>
                        <button onclick="copyAttendingSummary()" class="success" style="flex: 1; padding: 12px;">
                            üìã Copy Summary
                        </button>
                        <button onclick="regenerateAttendingSummary()" style="flex: 1; padding: 12px; background: #2196F3; color: white;">
                            üîÑ Regenerate
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Clinical Scales Database -->
    <script>
        // ============================================================
        // EMBEDDED CLINICAL SCALES DATABASE
        // ============================================================
        /**
         * Clinical Scales Database for NeuroScribe
         * Comprehensive collection of neurosurgical assessment scales
         */

const ClinicalScalesDatabase = {

    // ============================================================
    // SPINE SCALES (PRIORITY IMPLEMENTATION)
    // ============================================================

    'mjoa': {
        id: 'mjoa',
        name: 'Modified Japanese Orthopedic Association (mJOA) Score',
        shortName: 'mJOA',
        category: 'spine',
        pathologies: ['spine-degenerative'],
        description: 'Assessment scale for cervical myelopathy severity. Evaluates motor and sensory function in upper/lower extremities and bladder function.',
        questions: [
            {
                id: 'motor_upper',
                section: 'Motor Function',
                text: 'Motor dysfunction of the upper extremity',
                options: [
                    {value: 0, label: 'Unable to feed oneself', description: 'Severe impairment - cannot use utensils'},
                    {value: 1, label: 'Unable to handle chopsticks but able to eat with spoon', description: 'Significant impairment'},
                    {value: 2, label: 'Handles chopsticks with difficulty', description: 'Moderate impairment'},
                    {value: 3, label: 'Handles chopsticks with slight difficulty', description: 'Mild impairment'},
                    {value: 4, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['hand function', 'fine motor', 'buttons', 'writing', 'feeding', 'utensils', 'chopsticks', 'dropping objects']
            },
            {
                id: 'motor_lower',
                section: 'Motor Function',
                text: 'Motor dysfunction of the lower extremity',
                options: [
                    {value: 0, label: 'Unable to walk', description: 'Complete loss of ambulation'},
                    {value: 1, label: 'Needs cane or aid on flat ground', description: 'Significant assistance required'},
                    {value: 2, label: 'Needs cane or aid on stairs', description: 'Limited assistance'},
                    {value: 3, label: 'Lacks smooth reciprocation or speed', description: 'Mild gait abnormality'},
                    {value: 4, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['walking', 'gait', 'stairs', 'climbing', 'balance', 'cane', 'walker', 'ambulation', 'legs']
            },
            {
                id: 'sensory_upper',
                section: 'Sensory Function',
                text: 'Sensory dysfunction of the upper extremity',
                options: [
                    {value: 0, label: 'Severe sensory loss or pain', description: 'Marked impairment'},
                    {value: 1, label: 'Mild sensory loss or pain', description: 'Slight impairment'},
                    {value: 2, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['numbness', 'tingling', 'sensation', 'arms', 'hands', 'fingers', 'upper extremity', 'paresthesia']
            },
            {
                id: 'sensory_lower',
                section: 'Sensory Function',
                text: 'Sensory dysfunction of the lower extremity',
                options: [
                    {value: 0, label: 'Severe sensory loss or pain', description: 'Marked impairment'},
                    {value: 1, label: 'Mild sensory loss or pain', description: 'Slight impairment'},
                    {value: 2, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['numbness', 'tingling', 'sensation', 'legs', 'feet', 'toes', 'lower extremity', 'paresthesia']
            },
            {
                id: 'sensory_trunk',
                section: 'Sensory Function',
                text: 'Sensory dysfunction of the trunk',
                options: [
                    {value: 0, label: 'Severe sensory loss or pain', description: 'Marked impairment'},
                    {value: 1, label: 'Mild sensory loss or pain', description: 'Slight impairment'},
                    {value: 2, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['trunk', 'chest', 'abdomen', 'torso', 'body', 'sensory level']
            },
            {
                id: 'bladder',
                section: 'Bladder Function',
                text: 'Sphincter dysfunction (Bladder function)',
                options: [
                    {value: 0, label: 'Urinary retention and/or incontinence', description: 'Complete dysfunction'},
                    {value: 1, label: 'Sense of retention and/or incomplete continence', description: 'Moderate dysfunction'},
                    {value: 2, label: 'Urinary frequency and/or hesitation', description: 'Mild dysfunction'},
                    {value: 3, label: 'Normal', description: 'No impairment'}
                ],
                value: null,
                keywords: ['bladder', 'urinary', 'incontinence', 'retention', 'frequency', 'urgency', 'hesitation', 'catheter']
            }
        ],
        scoring: function(responses) {
            let total = 0;
            let answered = 0;
            for (const q of this.questions) {
                if (q.value !== null && q.value !== undefined) {
                    total += q.value;
                    answered++;
                }
            }
            return {
                total: total,
                max: this.maxScore,
                answered: answered,
                totalQuestions: this.questions.length,
                percentage: answered > 0 ? Math.round((answered / this.questions.length) * 100) : 0
            };
        },
        interpretation: function(score) {
            if (score >= 15) {
                return {
                    severity: 'Mild Myelopathy',
                    color: '#10b981',
                    description: 'Minimal functional impairment',
                    recommendation: 'Consider conservative management, close monitoring'
                };
            } else if (score >= 12) {
                return {
                    severity: 'Moderate Myelopathy',
                    color: '#f59e0b',
                    description: 'Moderate functional limitations',
                    recommendation: 'Consider surgical intervention if progressive or conservative treatment fails'
                };
            } else {
                return {
                    severity: 'Severe Myelopathy',
                    color: '#dc2626',
                    description: 'Significant functional impairment',
                    recommendation: 'Surgical intervention strongly recommended'
                };
            }
        },
        minScore: 0,
        maxScore: 17,
        ranges: [
            {min: 0, max: 11, severity: 'Severe', color: '#dc2626'},
            {min: 12, max: 14, severity: 'Moderate', color: '#f59e0b'},
            {min: 15, max: 17, severity: 'Mild', color: '#10b981'}
        ],
        evidenceLevel: 'Level II - Validated outcome measure',
        references: [
            'Benzel EC, et al. Cervical laminectomy and dentate ligament section for cervical spondylotic myelopathy. J Spinal Disord. 1991;4:286-295.',
            'Yonenobu K, et al. Interobserver and intraobserver reliability of the Japanese Orthopaedic Association scoring system. Spine. 2001;26:1890-1894.'
        ]
    },

    'nurick': {
        id: 'nurick',
        name: 'Nurick Classification/Grade',
        shortName: 'Nurick',
        category: 'spine',
        pathologies: ['spine-degenerative'],
        description: 'Classification system for cervical myelopathy based on walking ability and gait disturbance.',
        questions: [
            {
                id: 'grade',
                section: 'Functional Status',
                text: 'Cervical myelopathy grade based on walking ability',
                options: [
                    {value: 0, label: 'Grade 0: No signs or symptoms of cord involvement', description: 'Root signs only'},
                    {value: 1, label: 'Grade 1: Signs of cord involvement but no difficulty walking', description: 'Myelopathy present, ambulation normal'},
                    {value: 2, label: 'Grade 2: Slight difficulty walking, able to work', description: 'Mild gait impairment, employment maintained'},
                    {value: 3, label: 'Grade 3: Difficulty walking prevents work or full-time employment', description: 'Moderate impairment'},
                    {value: 4, label: 'Grade 4: Able to walk only with assistance', description: 'Severe impairment, requires aid'},
                    {value: 5, label: 'Grade 5: Wheelchair bound or bedridden', description: 'Non-ambulatory'}
                ],
                value: null,
                keywords: ['walking', 'gait', 'wheelchair', 'assistance', 'cane', 'walker', 'bedridden', 'employment', 'work']
            }
        ],
        scoring: function(responses) {
            const grade = this.questions[0].value;
            return {
                total: grade !== null ? grade : null,
                max: 5,
                answered: grade !== null ? 1 : 0,
                totalQuestions: 1,
                percentage: grade !== null ? 100 : 0
            };
        },
        interpretation: function(grade) {
            const interpretations = {
                0: {severity: 'Grade 0 - No Myelopathy', color: '#10b981', description: 'Radiculopathy only', recommendation: 'Conservative management typically appropriate'},
                1: {severity: 'Grade 1 - Very Mild', color: '#10b981', description: 'Signs present, no functional limitation', recommendation: 'Monitor, consider intervention if progressive'},
                2: {severity: 'Grade 2 - Mild', color: '#84cc16', description: 'Slight gait difficulty, maintains employment', recommendation: 'Consider surgical intervention, discuss risks/benefits'},
                3: {severity: 'Grade 3 - Moderate', color: '#f59e0b', description: 'Cannot work due to gait impairment', recommendation: 'Surgical intervention recommended'},
                4: {severity: 'Grade 4 - Severe', color: '#ef4444', description: 'Requires assistive device', recommendation: 'Surgical intervention strongly recommended'},
                5: {severity: 'Grade 5 - Very Severe', color: '#dc2626', description: 'Non-ambulatory', recommendation: 'Surgery indicated, but outcomes may be limited'}
            };
            return interpretations[grade] || {severity: 'Unknown', color: '#6b7280', description: 'Grade not assessed', recommendation: 'Complete assessment'};
        },
        minScore: 0,
        maxScore: 5,
        ranges: [
            {min: 0, max: 1, severity: 'No/Minimal', color: '#10b981'},
            {min: 2, max: 3, severity: 'Mild-Moderate', color: '#f59e0b'},
            {min: 4, max: 5, severity: 'Severe', color: '#dc2626'}
        ],
        evidenceLevel: 'Level II - Widely accepted classification',
        references: [
            'Nurick S. The pathogenesis of the spinal cord disorder associated with cervical spondylosis. Brain. 1972;95:87-100.'
        ]
    },

    'ndi': {
        id: 'ndi',
        name: 'Neck Disability Index (NDI)',
        shortName: 'NDI',
        category: 'spine',
        pathologies: ['spine-degenerative', 'spine-trauma'],
        description: 'Patient-reported outcome measure for neck pain and disability. 10 sections, each scored 0-5.',
        questions: [
            {
                id: 'pain_intensity',
                section: 'Section 1',
                text: 'Pain Intensity',
                options: [
                    {value: 0, label: 'I have no pain at the moment'},
                    {value: 1, label: 'The pain is very mild at the moment'},
                    {value: 2, label: 'The pain is moderate at the moment'},
                    {value: 3, label: 'The pain is fairly severe at the moment'},
                    {value: 4, label: 'The pain is very severe at the moment'},
                    {value: 5, label: 'The pain is the worst imaginable at the moment'}
                ],
                value: null,
                keywords: ['neck pain', 'pain intensity', 'pain level', 'how much pain']
            },
            {
                id: 'personal_care',
                section: 'Section 2',
                text: 'Personal Care (washing, dressing, etc.)',
                options: [
                    {value: 0, label: 'I can look after myself normally without causing extra pain'},
                    {value: 1, label: 'I can look after myself normally but it causes extra pain'},
                    {value: 2, label: 'It is painful to look after myself and I am slow and careful'},
                    {value: 3, label: 'I need some help but manage most of my personal care'},
                    {value: 4, label: 'I need help every day in most aspects of self care'},
                    {value: 5, label: 'I do not get dressed, wash with difficulty, and stay in bed'}
                ],
                value: null,
                keywords: ['dressing', 'washing', 'bathing', 'grooming', 'personal care', 'self care']
            },
            {
                id: 'lifting',
                section: 'Section 3',
                text: 'Lifting',
                options: [
                    {value: 0, label: 'I can lift heavy weights without extra pain'},
                    {value: 1, label: 'I can lift heavy weights but it gives extra pain'},
                    {value: 2, label: 'Pain prevents me from lifting heavy weights off the floor, but I can if items are conveniently positioned'},
                    {value: 3, label: 'Pain prevents me from lifting heavy weights, but I can manage light to medium weights'},
                    {value: 4, label: 'I can lift only very light weights'},
                    {value: 5, label: 'I cannot lift or carry anything at all'}
                ],
                value: null,
                keywords: ['lifting', 'carrying', 'heavy objects', 'weights']
            },
            {
                id: 'reading',
                section: 'Section 4',
                text: 'Reading',
                options: [
                    {value: 0, label: 'I can read as much as I want with no pain in my neck'},
                    {value: 1, label: 'I can read as much as I want with slight pain in my neck'},
                    {value: 2, label: 'I can read as much as I want with moderate pain in my neck'},
                    {value: 3, label: 'I cannot read as much as I want because of moderate pain in my neck'},
                    {value: 4, label: 'I can hardly read at all because of severe pain in my neck'},
                    {value: 5, label: 'I cannot read at all'}
                ],
                value: null,
                keywords: ['reading', 'looking down', 'neck flexion', 'computer work', 'phone use']
            },
            {
                id: 'headaches',
                section: 'Section 5',
                text: 'Headaches',
                options: [
                    {value: 0, label: 'I have no headaches at all'},
                    {value: 1, label: 'I have slight headaches which come infrequently'},
                    {value: 2, label: 'I have moderate headaches which come infrequently'},
                    {value: 3, label: 'I have moderate headaches which come frequently'},
                    {value: 4, label: 'I have severe headaches which come frequently'},
                    {value: 5, label: 'I have headaches almost all the time'}
                ],
                value: null,
                keywords: ['headache', 'head pain', 'cervicogenic headache', 'occipital pain']
            },
            {
                id: 'concentration',
                section: 'Section 6',
                text: 'Concentration',
                options: [
                    {value: 0, label: 'I can concentrate fully when I want with no difficulty'},
                    {value: 1, label: 'I can concentrate fully when I want with slight difficulty'},
                    {value: 2, label: 'I have a fair degree of difficulty concentrating when I want'},
                    {value: 3, label: 'I have a lot of difficulty concentrating when I want'},
                    {value: 4, label: 'I have a great deal of difficulty concentrating when I want'},
                    {value: 5, label: 'I cannot concentrate at all'}
                ],
                value: null,
                keywords: ['concentration', 'focus', 'attention', 'mental clarity', 'cognitive']
            },
            {
                id: 'work',
                section: 'Section 7',
                text: 'Work',
                options: [
                    {value: 0, label: 'I can do as much work as I want'},
                    {value: 1, label: 'I can only do my usual work but no more'},
                    {value: 2, label: 'I can do most of my usual work but no more'},
                    {value: 3, label: 'I cannot do my usual work'},
                    {value: 4, label: 'I can hardly do any work at all'},
                    {value: 5, label: 'I cannot do any work at all'}
                ],
                value: null,
                keywords: ['work', 'job', 'employment', 'occupation', 'working']
            },
            {
                id: 'driving',
                section: 'Section 8',
                text: 'Driving',
                options: [
                    {value: 0, label: 'I can drive my car without any neck pain'},
                    {value: 1, label: 'I can drive my car as long as I want with slight pain in my neck'},
                    {value: 2, label: 'I can drive my car as long as I want with moderate pain in my neck'},
                    {value: 3, label: 'I cannot drive my car as long as I want because of moderate pain in my neck'},
                    {value: 4, label: 'I can hardly drive at all because of severe pain in my neck'},
                    {value: 5, label: 'I cannot drive my car at all'}
                ],
                value: null,
                keywords: ['driving', 'car', 'vehicle', 'turning head', 'looking over shoulder']
            },
            {
                id: 'sleeping',
                section: 'Section 9',
                text: 'Sleeping',
                options: [
                    {value: 0, label: 'I have no trouble sleeping'},
                    {value: 1, label: 'My sleep is slightly disturbed (less than 1 hour sleepless)'},
                    {value: 2, label: 'My sleep is mildly disturbed (1-2 hours sleepless)'},
                    {value: 3, label: 'My sleep is moderately disturbed (2-3 hours sleepless)'},
                    {value: 4, label: 'My sleep is greatly disturbed (3-5 hours sleepless)'},
                    {value: 5, label: 'My sleep is completely disturbed (5-7 hours sleepless)'}
                ],
                value: null,
                keywords: ['sleep', 'sleeping', 'night pain', 'insomnia', 'rest']
            },
            {
                id: 'recreation',
                section: 'Section 10',
                text: 'Recreation',
                options: [
                    {value: 0, label: 'I am able to engage in all recreational activities with no neck pain'},
                    {value: 1, label: 'I am able to engage in all recreational activities with some pain in my neck'},
                    {value: 2, label: 'I am able to engage in most but not all recreational activities because of pain in my neck'},
                    {value: 3, label: 'I am able to engage in a few recreational activities because of pain in my neck'},
                    {value: 4, label: 'I can hardly do any recreational activities because of pain in my neck'},
                    {value: 5, label: 'I cannot do any recreational activities at all'}
                ],
                value: null,
                keywords: ['recreation', 'hobbies', 'activities', 'sports', 'exercise', 'leisure']
            }
        ],
        scoring: function(responses) {
            let total = 0;
            let answered = 0;
            for (const q of this.questions) {
                if (q.value !== null && q.value !== undefined) {
                    total += q.value;
                    answered++;
                }
            }
            // NDI is reported as percentage: (total score / max possible score) √ó 100
            const percentage = answered > 0 ? Math.round((total / (answered * 5)) * 100) : 0;
            return {
                total: total,
                max: this.maxScore,
                percentage: percentage,
                answered: answered,
                totalQuestions: this.questions.length,
                completionPercentage: Math.round((answered / this.questions.length) * 100)
            };
        },
        interpretation: function(percentage) {
            if (percentage <= 8) {
                return {
                    severity: 'No Disability',
                    color: '#10b981',
                    description: 'No significant neck-related functional impairment',
                    recommendation: 'Continue current management, reassess if symptoms change'
                };
            } else if (percentage <= 28) {
                return {
                    severity: 'Mild Disability',
                    color: '#84cc16',
                    description: 'Mild neck-related functional limitations',
                    recommendation: 'Conservative management: PT, medications, activity modification'
                };
            } else if (percentage <= 48) {
                return {
                    severity: 'Moderate Disability',
                    color: '#f59e0b',
                    description: 'Moderate functional limitations affecting daily activities',
                    recommendation: 'Consider advanced imaging, interventional options if conservative treatment fails'
                };
            } else if (percentage <= 68) {
                return {
                    severity: 'Severe Disability',
                    color: '#ef4444',
                    description: 'Severe functional impairment',
                    recommendation: 'Comprehensive evaluation, consider surgical consultation'
                };
            } else {
                return {
                    severity: 'Complete Disability',
                    color: '#dc2626',
                    description: 'Complete or near-complete disability',
                    recommendation: 'Urgent evaluation, multidisciplinary approach'
                };
            }
        },
        minScore: 0,
        maxScore: 50,
        ranges: [
            {min: 0, max: 8, severity: 'No Disability', color: '#10b981'},
            {min: 9, max: 28, severity: 'Mild', color: '#84cc16'},
            {min: 29, max: 48, severity: 'Moderate', color: '#f59e0b'},
            {min: 49, max: 68, severity: 'Severe', color: '#ef4444'},
            {min: 69, max: 100, severity: 'Complete', color: '#dc2626'}
        ],
        evidenceLevel: 'Level I - Validated, widely used outcome measure',
        references: [
            'Vernon H, Mior S. The Neck Disability Index: a study of reliability and validity. J Manipulative Physiol Ther. 1991;14:409-415.',
            'MacDermid JC, et al. Measurement properties of the neck disability index. J Orthop Sports Phys Ther. 2009;39:400-417.'
        ]
    },

    'odi': {
        id: 'odi',
        name: 'Oswestry Disability Index (ODI)',
        shortName: 'ODI',
        category: 'spine',
        pathologies: ['spine-degenerative', 'spine-trauma'],
        description: 'Patient-reported outcome measure for lower back pain and disability. 10 sections, each scored 0-5.',
        questions: [
            {
                id: 'pain_intensity',
                section: 'Section 1',
                text: 'Pain Intensity',
                options: [
                    {value: 0, label: 'I have no pain at the moment'},
                    {value: 1, label: 'The pain is very mild at the moment'},
                    {value: 2, label: 'The pain is moderate at the moment'},
                    {value: 3, label: 'The pain is fairly severe at the moment'},
                    {value: 4, label: 'The pain is very severe at the moment'},
                    {value: 5, label: 'The pain is the worst imaginable at the moment'}
                ],
                value: null,
                keywords: ['back pain', 'low back pain', 'pain intensity', 'pain level']
            },
            {
                id: 'personal_care',
                section: 'Section 2',
                text: 'Personal Care (washing, dressing, etc.)',
                options: [
                    {value: 0, label: 'I can look after myself normally without causing extra pain'},
                    {value: 1, label: 'I can look after myself normally but it causes extra pain'},
                    {value: 2, label: 'It is painful to look after myself and I am slow and careful'},
                    {value: 3, label: 'I need some help but manage most of my personal care'},
                    {value: 4, label: 'I need help every day in most aspects of self care'},
                    {value: 5, label: 'I do not get dressed, I wash with difficulty and stay in bed'}
                ],
                value: null,
                keywords: ['dressing', 'washing', 'bathing', 'grooming', 'personal care']
            },
            {
                id: 'lifting',
                section: 'Section 3',
                text: 'Lifting',
                options: [
                    {value: 0, label: 'I can lift heavy weights without extra pain'},
                    {value: 1, label: 'I can lift heavy weights but it gives extra pain'},
                    {value: 2, label: 'Pain prevents me lifting heavy weights off the floor, but I can if they are conveniently positioned'},
                    {value: 3, label: 'Pain prevents me from lifting heavy weights but I can manage light to medium weights'},
                    {value: 4, label: 'I can only lift very light weights'},
                    {value: 5, label: 'I cannot lift or carry anything'}
                ],
                value: null,
                keywords: ['lifting', 'carrying', 'heavy objects', 'weights']
            },
            {
                id: 'walking',
                section: 'Section 4',
                text: 'Walking',
                options: [
                    {value: 0, label: 'Pain does not prevent me walking any distance'},
                    {value: 1, label: 'Pain prevents me from walking more than 1 mile'},
                    {value: 2, label: 'Pain prevents me from walking more than 1/2 mile'},
                    {value: 3, label: 'Pain prevents me from walking more than 100 yards'},
                    {value: 4, label: 'I can only walk using a stick or crutches'},
                    {value: 5, label: 'I am in bed most of the time'}
                ],
                value: null,
                keywords: ['walking', 'ambulation', 'distance', 'mobility', 'gait']
            },
            {
                id: 'sitting',
                section: 'Section 5',
                text: 'Sitting',
                options: [
                    {value: 0, label: 'I can sit in any chair as long as I like'},
                    {value: 1, label: 'I can only sit in my favorite chair as long as I like'},
                    {value: 2, label: 'Pain prevents me sitting more than one hour'},
                    {value: 3, label: 'Pain prevents me from sitting more than 30 minutes'},
                    {value: 4, label: 'Pain prevents me from sitting more than 10 minutes'},
                    {value: 5, label: 'Pain prevents me from sitting at all'}
                ],
                value: null,
                keywords: ['sitting', 'prolonged sitting', 'desk work', 'chair']
            },
            {
                id: 'standing',
                section: 'Section 6',
                text: 'Standing',
                options: [
                    {value: 0, label: 'I can stand as long as I want without extra pain'},
                    {value: 1, label: 'I can stand as long as I want but it gives me extra pain'},
                    {value: 2, label: 'Pain prevents me from standing for more than 1 hour'},
                    {value: 3, label: 'Pain prevents me from standing for more than 30 minutes'},
                    {value: 4, label: 'Pain prevents me from standing for more than 10 minutes'},
                    {value: 5, label: 'Pain prevents me from standing at all'}
                ],
                value: null,
                keywords: ['standing', 'prolonged standing', 'upright posture']
            },
            {
                id: 'sleeping',
                section: 'Section 7',
                text: 'Sleeping',
                options: [
                    {value: 0, label: 'My sleep is never disturbed by pain'},
                    {value: 1, label: 'My sleep is occasionally disturbed by pain'},
                    {value: 2, label: 'Because of pain I have less than 6 hours sleep'},
                    {value: 3, label: 'Because of pain I have less than 4 hours sleep'},
                    {value: 4, label: 'Because of pain I have less than 2 hours sleep'},
                    {value: 5, label: 'Pain prevents me from sleeping at all'}
                ],
                value: null,
                keywords: ['sleep', 'sleeping', 'night pain', 'insomnia', 'rest']
            },
            {
                id: 'sex_life',
                section: 'Section 8',
                text: 'Sex Life (if applicable)',
                options: [
                    {value: 0, label: 'My sex life is normal and causes no extra pain'},
                    {value: 1, label: 'My sex life is normal but causes some extra pain'},
                    {value: 2, label: 'My sex life is nearly normal but is very painful'},
                    {value: 3, label: 'My sex life is severely restricted by pain'},
                    {value: 4, label: 'My sex life is nearly absent because of pain'},
                    {value: 5, label: 'Pain prevents any sex life at all'}
                ],
                value: null,
                keywords: ['sexual function', 'intimacy', 'sex life']
            },
            {
                id: 'social_life',
                section: 'Section 9',
                text: 'Social Life',
                options: [
                    {value: 0, label: 'My social life is normal and gives me no extra pain'},
                    {value: 1, label: 'My social life is normal but increases the degree of pain'},
                    {value: 2, label: 'Pain has no significant effect on my social life apart from limiting my more energetic interests'},
                    {value: 3, label: 'Pain has restricted my social life and I do not go out as often'},
                    {value: 4, label: 'Pain has restricted my social life to my home'},
                    {value: 5, label: 'I have no social life because of pain'}
                ],
                value: null,
                keywords: ['social life', 'socializing', 'going out', 'activities', 'friends']
            },
            {
                id: 'traveling',
                section: 'Section 10',
                text: 'Travelling',
                options: [
                    {value: 0, label: 'I can travel anywhere without pain'},
                    {value: 1, label: 'I can travel anywhere but it gives me extra pain'},
                    {value: 2, label: 'Pain is bad but I manage journeys over two hours'},
                    {value: 3, label: 'Pain restricts me to journeys of less than one hour'},
                    {value: 4, label: 'Pain restricts me to short necessary journeys under 30 minutes'},
                    {value: 5, label: 'Pain prevents me from travelling except to receive treatment'}
                ],
                value: null,
                keywords: ['traveling', 'driving', 'car rides', 'trips', 'journeys']
            }
        ],
        scoring: function(responses) {
            let total = 0;
            let answered = 0;
            for (const q of this.questions) {
                if (q.value !== null && q.value !== undefined) {
                    total += q.value;
                    answered++;
                }
            }
            // ODI is reported as percentage: (total score / max possible score) √ó 100
            const percentage = answered > 0 ? Math.round((total / (answered * 5)) * 100) : 0;
            return {
                total: total,
                max: this.maxScore,
                percentage: percentage,
                answered: answered,
                totalQuestions: this.questions.length,
                completionPercentage: Math.round((answered / this.questions.length) * 100)
            };
        },
        interpretation: function(percentage) {
            if (percentage <= 20) {
                return {
                    severity: 'Minimal Disability',
                    color: '#10b981',
                    description: 'Can cope with most activities of daily living',
                    recommendation: 'Continue activity, no treatment indicated'
                };
            } else if (percentage <= 40) {
                return {
                    severity: 'Moderate Disability',
                    color: '#84cc16',
                    description: 'Experiencing more pain, difficulty with sitting, lifting, standing',
                    recommendation: 'Conservative treatment: PT, pain management'
                };
            } else if (percentage <= 60) {
                return {
                    severity: 'Severe Disability',
                    color: '#f59e0b',
                    description: 'Pain remains main problem, interfering with all aspects of life',
                    recommendation: 'Detailed investigation, may require advanced treatment'
                };
            } else if (percentage <= 80) {
                return {
                    severity: 'Crippled',
                    color: '#ef4444',
                    description: 'Back pain impinging on all aspects of life',
                    recommendation: 'Active intervention required, consider surgical consultation'
                };
            } else {
                return {
                    severity: 'Bed-bound or Exaggerating',
                    color: '#dc2626',
                    description: 'Confined to bed or exaggerating symptoms',
                    recommendation: 'Careful reassessment, multidisciplinary evaluation'
                };
            }
        },
        minScore: 0,
        maxScore: 50,
        ranges: [
            {min: 0, max: 20, severity: 'Minimal', color: '#10b981'},
            {min: 21, max: 40, severity: 'Moderate', color: '#84cc16'},
            {min: 41, max: 60, severity: 'Severe', color: '#f59e0b'},
            {min: 61, max: 80, severity: 'Crippled', color: '#ef4444'},
            {min: 81, max: 100, severity: 'Bed-bound', color: '#dc2626'}
        ],
        evidenceLevel: 'Level I - Gold standard for low back disability',
        references: [
            'Fairbank JC, Pynsent PB. The Oswestry Disability Index. Spine. 2000;25:2940-2952.',
            'Ostelo RW, et al. Interpreting change scores for pain and functional status in low back pain. Spine. 2008;33:90-94.'
        ]
    },

    'vas_pain': {
        id: 'vas_pain',
        name: 'Visual Analog Scale (VAS) for Pain',
        shortName: 'VAS Pain',
        category: 'pain',
        pathologies: ['spine-degenerative', 'spine-trauma', 'brain-tumor', 'vascular', 'functional'],
        description: 'Simple pain intensity rating scale from 0-10. 0 = no pain, 10 = worst pain imaginable.',
        questions: [
            {
                id: 'current_pain',
                section: 'Pain Assessment',
                text: 'Current Pain Level (0-10)',
                type: 'slider',
                options: [], // Slider from 0-10
                value: null,
                keywords: ['pain', 'pain level', 'how much pain', 'pain intensity', 'hurts']
            },
            {
                id: 'worst_pain',
                section: 'Pain Assessment',
                text: 'Worst Pain in Last 24 Hours (0-10)',
                type: 'slider',
                options: [],
                value: null,
                keywords: ['worst pain', 'maximum pain', 'peak pain']
            },
            {
                id: 'average_pain',
                section: 'Pain Assessment',
                text: 'Average Pain Level (0-10)',
                type: 'slider',
                options: [],
                value: null,
                keywords: ['average pain', 'typical pain', 'usual pain']
            }
        ],
        scoring: function(responses) {
            const current = this.questions[0].value;
            const worst = this.questions[1].value;
            const average = this.questions[2].value;
            let answered = 0;
            let total = 0;

            if (current !== null) { answered++; total += current; }
            if (worst !== null) { answered++; total += worst; }
            if (average !== null) { answered++; total += average; }

            const avgScore = answered > 0 ? Math.round(total / answered) : null;

            return {
                current: current,
                worst: worst,
                average: average,
                overallAverage: avgScore,
                answered: answered,
                totalQuestions: this.questions.length,
                percentage: Math.round((answered / this.questions.length) * 100)
            };
        },
        interpretation: function(score) {
            if (score === null || score === undefined) {
                return {severity: 'Not Assessed', color: '#6b7280', description: 'Pain not evaluated', recommendation: 'Complete pain assessment'};
            }
            if (score <= 2) {
                return {severity: 'Mild Pain', color: '#10b981', description: 'Minimal pain, no/minimal functional impact', recommendation: 'No intervention or simple analgesics prn'};
            } else if (score <= 5) {
                return {severity: 'Moderate Pain', color: '#f59e0b', description: 'Noticeable pain affecting some activities', recommendation: 'Regular analgesics, consider PT or other modalities'};
            } else if (score <= 7) {
                return {severity: 'Severe Pain', color: '#ef4444', description: 'Significant pain interfering with daily function', recommendation: 'Multimodal pain management, consider advanced therapies'};
            } else {
                return {severity: 'Very Severe Pain', color: '#dc2626', description: 'Worst possible pain, unable to function', recommendation: 'Urgent pain management, evaluate for acute intervention'};
            }
        },
        minScore: 0,
        maxScore: 10,
        ranges: [
            {min: 0, max: 2, severity: 'Mild', color: '#10b981'},
            {min: 3, max: 5, severity: 'Moderate', color: '#f59e0b'},
            {min: 6, max: 7, severity: 'Severe', color: '#ef4444'},
            {min: 8, max: 10, severity: 'Very Severe', color: '#dc2626'}
        ],
        evidenceLevel: 'Level I - Universally accepted pain measure',
        references: [
            'Hawker GA, et al. Measures of adult pain. Arthritis Care Res. 2011;63(S11):S240-252.'
        ]
    },

    // ============================================================
    // FUNCTIONAL SCALES
    // ============================================================

    'gcs': {
        id: 'gcs',
        name: 'Glasgow Coma Scale (GCS)',
        shortName: 'GCS',
        category: 'functional',
        pathologies: ['spine-trauma', 'brain-tumor', 'vascular', 'hydrocephalus'],
        description: 'Neurological scale to assess consciousness level. Evaluates eye, verbal, and motor responses.',
        questions: [
            {
                id: 'eye',
                section: 'Eye Opening Response',
                text: 'Eye Opening',
                options: [
                    {value: 4, label: 'Spontaneous - Opens eyes spontaneously'},
                    {value: 3, label: 'To verbal command - Opens eyes to verbal stimulation'},
                    {value: 2, label: 'To pain - Opens eyes to painful stimulus'},
                    {value: 1, label: 'No response - Does not open eyes'}
                ],
                value: null,
                keywords: ['eye opening', 'opens eyes', 'spontaneous', 'to voice', 'to pain']
            },
            {
                id: 'verbal',
                section: 'Verbal Response',
                text: 'Verbal Response',
                options: [
                    {value: 5, label: 'Oriented - Oriented to person, place, time'},
                    {value: 4, label: 'Confused - Disoriented conversation'},
                    {value: 3, label: 'Inappropriate words - Intelligible but inappropriate'},
                    {value: 2, label: 'Incomprehensible sounds - Moaning/groaning only'},
                    {value: 1, label: 'No response - No verbal response'}
                ],
                value: null,
                keywords: ['speaking', 'talking', 'oriented', 'confused', 'verbal', 'speech', 'alert']
            },
            {
                id: 'motor',
                section: 'Motor Response',
                text: 'Best Motor Response',
                options: [
                    {value: 6, label: 'Obeys commands - Follows simple commands'},
                    {value: 5, label: 'Localizes pain - Purposeful movement to painful stimulus'},
                    {value: 4, label: 'Withdraws from pain - Pulls limb away from pain'},
                    {value: 3, label: 'Flexion to pain - Abnormal flexion (decorticate)'},
                    {value: 2, label: 'Extension to pain - Abnormal extension (decerebrate)'},
                    {value: 1, label: 'No response - No motor response'}
                ],
                value: null,
                keywords: ['motor', 'movement', 'follows commands', 'localizes', 'withdraws', 'flexion', 'extension', 'posturing']
            }
        ],
        scoring: function(responses) {
            let total = 0;
            let answered = 0;
            for (const q of this.questions) {
                if (q.value !== null && q.value !== undefined) {
                    total += q.value;
                    answered++;
                }
            }
            return {
                total: total,
                eye: this.questions[0].value,
                verbal: this.questions[1].value,
                motor: this.questions[2].value,
                answered: answered,
                totalQuestions: this.questions.length,
                percentage: Math.round((answered / this.questions.length) * 100)
            };
        },
        interpretation: function(score) {
            if (score >= 14) {
                return {severity: 'Mild TBI', color: '#10b981', description: 'Minimal neurological impairment', recommendation: 'Observation, may not require admission'};
            } else if (score >= 9) {
                return {severity: 'Moderate TBI', color: '#f59e0b', description: 'Moderate neurological impairment', recommendation: 'Admission, close monitoring, CT scan'};
            } else if (score >= 3) {
                return {severity: 'Severe TBI', color: '#dc2626', description: 'Severe neurological impairment', recommendation: 'ICU admission, intubation consideration, neurosurgical consultation'};
            } else {
                return {severity: 'Unknown', color: '#6b7280', description: 'Not assessed', recommendation: 'Complete GCS assessment'};
            }
        },
        minScore: 3,
        maxScore: 15,
        ranges: [
            {min: 3, max: 8, severity: 'Severe', color: '#dc2626'},
            {min: 9, max: 13, severity: 'Moderate', color: '#f59e0b'},
            {min: 14, max: 15, severity: 'Mild', color: '#10b981'}
        ],
        evidenceLevel: 'Level I - Gold standard for consciousness assessment',
        references: [
            'Teasdale G, Jennett B. Assessment of coma and impaired consciousness. Lancet. 1974;2:81-84.'
        ]
    }

    // Additional scales to be implemented in future iterations:
    // - KPS (Karnofsky Performance Scale)
    // - mRS (Modified Rankin Scale)
    // - NIHSS (NIH Stroke Scale)
    // - ASIA (Spinal Cord Injury)
    // - Hunt-Hess (SAH grading)
    // - Fisher Scale (SAH)
    // - WFNS (SAH)
    // - Spetzler-Martin (AVM)
    // - TLICS/SLIC (Spine trauma)
    // - Frankel Grade
    // - UPDRS (Parkinson's)
    // - etc.
};

// Export for use in main application
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ClinicalScalesDatabase;
}

        // ============================================================
        // GLOBAL ERROR HANDLER
        // ============================================================
        window.addEventListener('error', function(e) {
            console.error('üö® JavaScript Error:', e.message, 'at', e.filename, ':', e.lineno);
            console.error('Stack:', e.error?.stack);
        });

        window.addEventListener('unhandledrejection', function(e) {
            console.error('üö® Unhandled Promise Rejection:', e.reason);
        });

        console.log('üöÄ NeuroScribe V10.2.4 ENHANCED ULTRATHINK - Semantic-AI-Only ULTRATHINK + Real-Time Progress Indicator');
        console.log('üìã V10.2.4 PHASE 1 KEY FEATURES (Quick Wins - November 10, 2025):');
        console.log('  üéØ NEW: Semantic-AI-Only ULTRATHINK validation (PHASE 1.1)');
        console.log('      ‚Üí ULTRATHINK now uses dedicated high-precision detector');
        console.log('      ‚Üí Zero term-based false positives for compression');
        console.log('      ‚Üí Only AI-vetted, contextually-aware fabrication detection');
        console.log('      ‚Üí Full clinical notes still use dual-mode (term-based + semantic)');
        console.log('  üéØ NEW: Real-time resolution progress indicator (PHASE 1.2)');
        console.log('      ‚Üí Beautiful gradient progress bar with 6 stages');
        console.log('      ‚Üí Live updates: Applying corrections ‚Üí Regenerating ULTRATHINK ‚Üí Complete');
        console.log('      ‚Üí Dynamic color changes (purple ‚Üí blue ‚Üí green)');
        console.log('      ‚Üí Estimated time remaining display');
        console.log('      ‚Üí Smooth animations and auto-hide on completion');
        console.log('  ‚úÖ All V10.2.3 features preserved:');
        console.log('      ‚Üí Sentence-level location tracking');
        console.log('      ‚Üí Multiple fix options (Remove/Conservative/Moderate)');
        console.log('      ‚Üí Score transparency breakdown');
        console.log('      ‚Üí Fabrication score details');
        console.log('  ‚úÖ Layer-grouped issue display (V10.2.2)');
        console.log('  ‚úÖ Interactive validation resolution system (V10.2)');
        console.log('  ‚úÖ Quality score system fixed (V10.1)');
        console.log('  ‚úÖ Pure mode: Zero auto-briefing (V10)');
        console.log('üìÖ Loading at:', new Date().toLocaleString());
        console.log('üîß V10.2.4 Architecture: Enhanced ULTRATHINK Validation | Real-Time Progress Feedback | All Previous V10.2.3 Features');
        console.log('üõ°Ô∏è Protection Layers: 8-layer FIREWALL + V10-V10.2.3 enhancements + V10.2.4 ULTRATHINK optimizations');
        console.log('üéØ [V10.2.4] ULTRATHINK validation enhanced - semantic-AI-only mode eliminates false positives, progress indicator provides real-time feedback');

        // ============================================================
        // GLOBAL VARIABLES
        // ============================================================

        /**
         * =====================================================
         * CONFIGURATION CONSTANTS
         * =====================================================
         * All magic numbers and configuration values in one place
         */
        const CONSTANTS = {
            // API and Rate Limiting
            API: {
                RATE_LIMIT_CALLS: 10,           // Max API calls per time window
                RATE_LIMIT_WINDOW: 60000,       // Time window in milliseconds (60 seconds)
                TIMEOUT_DURATION: 30000,        // API timeout in milliseconds (30 seconds)
                MAX_RETRIES: 3,                 // Maximum retry attempts for failed requests
                RETRY_DELAY_BASE: 1000         // Base delay for exponential backoff (milliseconds)
            },

            // Validation Thresholds
            VALIDATION: {
                FABRICATION_CRITICAL: 0.7,      // Critical fabrication confidence threshold
                FABRICATION_WARNING: 0.4,       // Warning fabrication confidence threshold
                GROUNDING_MINIMUM: 0.6,         // Minimum grounding score required
                COMPLETENESS_MINIMUM: 0.7,      // Minimum completeness score required
                CONSISTENCY_MINIMUM: 0.7,       // Minimum consistency score required
                PROPORTIONALITY_MIN_RATIO: 2,   // Minimum output/input ratio
                PROPORTIONALITY_MAX_RATIO: 5,   // Maximum output/input ratio
                OVERALL_PASS_THRESHOLD: 75      // Overall quality score to pass (%)
            },

            // Clinical Scales Score Ranges
            SCALES: {
                MJOA: {
                    MILD: 15,                   // mJOA score >= 15 = mild myelopathy
                    MODERATE: 12,               // mJOA score >= 12 = moderate myelopathy
                    SEVERE: 0,                  // mJOA score < 12 = severe myelopathy
                    MAX: 18                     // Maximum possible mJOA score
                },
                GCS: {
                    SEVERE_MAX: 8,              // GCS <= 8 = severe
                    MODERATE_MAX: 12,           // GCS 9-12 = moderate
                    MILD_MIN: 13,               // GCS >= 13 = mild
                    NORMAL_MIN: 14,             // GCS >= 14 = normal
                    MAX: 15                     // Maximum GCS score
                },
                NURICK: {
                    GRADE_0: 0,                 // No symptoms
                    GRADE_1: 1,                 // Symptoms but no gait abnormality
                    GRADE_2: 2,                 // Mild gait abnormality
                    GRADE_3: 3,                 // Severe gait abnormality
                    GRADE_4: 4,                 // Needs assistance
                    GRADE_5: 5                  // Wheelchair/bedridden
                },
                MRS: {
                    NO_SYMPTOMS: 0,
                    NO_DISABILITY: 1,
                    SLIGHT_DISABILITY: 2,
                    MODERATE_DISABILITY: 3,
                    MODERATE_SEVERE_DISABILITY: 4,
                    SEVERE_DISABILITY: 5,
                    DEAD: 6
                }
            },

            // DOAP Format Word Limits
            DOAP: {
                DIAGNOSIS_MAX_WORDS: 20,        // D section word limit
                ONE_LINER_MAX_WORDS: 35,        // O section word limit
                ASSESSMENT_MAX_WORDS: 35,       // A section word limit
                PLAN_MAX_WORDS: 60,             // P section word limit
                TOTAL_MAX_WORDS: 150            // Total DOAP word limit
            },

            // UI Delays and Timeouts
            UI: {
                CHECKLIST_INIT_DELAY: 500,      // Delay before initializing checklist (ms)
                AUTOSAVE_DELAY: 2000,           // Delay before autosaving (ms)
                TOAST_DURATION: 3000,           // Toast notification duration (ms)
                ERROR_DISPLAY_DURATION: 5000,   // Error message display duration (ms)
                SETTINGS_RELOAD_DELAY: 1500,    // Delay before reloading after saving settings (ms)
                STATUS_UPDATE_INTERVAL: 1000    // Interval for status updates (ms)
            },

            // File and Storage Limits
            STORAGE: {
                MAX_DOCUMENT_SIZE: 5242880,     // 5MB in bytes
                MAX_TOTAL_STORAGE: 10485760,    // 10MB in bytes
                MAX_DOCUMENTS: 10,              // Maximum number of uploaded documents
                LOCALSTORAGE_WARNING_SIZE: 4718592  // Warn at 90% of 5MB
            },

            // Text Processing
            TEXT: {
                MAX_OUTPUT_LINES: 2000,         // Maximum lines to read from output
                MAX_LINE_LENGTH: 2000,          // Maximum characters per line
                WORD_COUNT_LIMIT_BRIEFING: 1000, // Word count for briefing generation
                MIN_TRANSCRIPT_WORDS: 50        // Minimum words required for transcript
            },

            // Encryption
            ENCRYPTION: {
                VERSION: 'v1',                  // Current encryption version
                PBKDF2_ITERATIONS: 100000,      // PBKDF2 iteration count
                AES_KEY_LENGTH: 256,            // AES key length in bits
                IV_LENGTH: 12,                  // Initialization vector length
                SALT: 'neuroscribe-salt-v1'    // Salt for key derivation
            }
        };

        // Get API key from localStorage
        let API_KEY = null;
        let recognition = null;
        let isRecording = false;
        let isPaused = false;
        let startTime = null;
        let timerInterval = null;
        let confidenceScores = [];
        let selectedPathology = null;
        let activeRedFlags = [];

        // V5 Expert Analysis Variables
        let customPathology = '';
        let generatedBriefing = null;  // Stores full briefing text
        let briefingChecklist = null;  // Stores structured checklist
        let briefingUsed = false;      // Tracks if briefing was integrated

        // Auto Deep Search Activation Variables (V8 Enhancement)
        let reasonForConsult = '';              // User-provided or AI-extracted chief complaint
        let reasonSource = null;                // 'manual' | 'extracted' | null - tracks how reason was obtained
        let autoDeepSearchEnabled = false;      // V9.1: User preference toggle - DISABLED by default (only generate briefing on explicit request)
        let autoDeepSearchTriggered = false;    // Prevents duplicate auto-activation in same session
        let reasonExtractionAttempted = false;  // Tracks if AI extraction was already attempted

        // V8 MITIGATION: Checklist Tracking System
        let checklistState = {};       // Tracks checkbox status {index: {text, checked, timestamp}}
        let checklistCoverageAnalysis = null;  // Stores algorithmic coverage analysis

        // Clinical Scales Variables
        let currentScale = null;       // Currently selected scale object
        let scaleResponses = {};       // Stores all scale responses {scaleId: {questionId: value}}
        let calculatedScores = {};     // Stores calculated scores {scaleId: scoreObject}

        // Expert Document Upload Variables
        let uploadedDocuments = [];    // Stores uploaded document content
        let uploadedDocText = '';      // Combined text from all uploaded documents

        // Consultation Type Variable
        let consultationType = 'new';  // 'new' or 'followup'

        // SOAP Quick-Entry Variables
        let soapQuickEntry = {
            subjective: '',
            objective: '',
            assessment: '',
            plan: ''
        };
        let soapEnhanceMode = false;  // false = expand only, true = expand + analysis
        let activeInputPanel = 'transcript';  // 'transcript' or 'soap'

        // Transcript Enhancement Variable
        let transcriptEnhanceMode = false;  // false = expand only, true = enhanced with briefing

        // V6 Interactive Review System Variables
        let currentSuggestions = [];  // Stores parsed AI suggestions for review

        // Attending Summary Variables
        let lastGeneratedNote = '';  // Stores last generated note for attending summary

        // Compression Versions Storage (for auto-generated compressed/ultracompressed notes)
        let currentNoteVersions = {
            full: '',           // Full finalized note
            standard: '',       // Compressed: Standard DOAP (45 sec, ~120-140 words)
            ultra: '',          // Ultracompressed: ULTRATHINK (15 sec, ~35-50 words)
            telegram: '',       // Super-compressed: Telegram (5 sec, ~15-25 words)
            // Status tracking for UI indicators
            status: {
                standard: 'pending',  // 'pending', 'generating', 'ready', 'failed'
                ultra: 'pending',     // 'pending', 'generating', 'ready', 'failed'
                telegram: 'pending'   // 'pending', 'generating', 'ready', 'failed'
            }
        };

        // V8 Validation Results Storage
        let lastValidationResult = null;  // Stores most recent validation analysis

        // V10.2: Interactive Validation Resolution System
        let currentValidationIssues = [];  // Array of interactive validation issue objects

        /**
         * V10.2: Validation Issue Object Structure
         * Each issue represents a validation concern that can be interactively resolved
         *
         * Structure:
         * {
         *   id: 'fab-001',                    // Unique identifier
         *   layer: 'fabrication',             // Which validation layer (grounding, fabrication, completeness, etc.)
         *   severity: 'CRITICAL',             // 'CRITICAL', 'HIGH', 'MEDIUM', 'LOW'
         *   type: 'fabrication',              // Specific issue type
         *   statement: 'Patient has severe disc herniation',  // The problematic text
         *   message: 'No imaging mentioned in transcript',    // Error/warning message
         *   confidence: 0.85,                 // AI confidence in detection (0-1)
         *   suggestedCorrection: 'Replace with "Patient reports..."',  // AI suggestion for fix
         *   resolution: 'pending',            // Resolution state: 'pending', 'approved', 'rejected', 'fixed'
         *   correctionText: null,             // User's custom correction (if resolution='fixed')
         *   affectedText: 'Patient has severe disc herniation',  // Text to replace/remove
         *   context: 'Assessment section line 3',  // Where in the note this appears
         *   sourceQuote: null                 // Expected source quote (for grounding issues)
         * }
         */

        class GroundingValidator {
            constructor(sourceText) {
                this.sourceText = sourceText;
                this.lastValidation = null;
            }

            /**
             * Validate grounding quality of extracted data
             */
            async validate(extractedData) {
                if (!extractedData || !this.sourceText) {
                    throw new Error('Both extracted data and source text are required');
                }

                console.log('üîç [Grounding] Starting validation...');

                // Defensive check: Validate data structure before processing
                if (!this.hasValidStructure(extractedData)) {
                    console.error('‚ùå [Grounding] Invalid data structure - expected {section: {field: {value, sourceQuote, confidence}}}');
                    console.error('   [Grounding] Received keys:', Object.keys(extractedData));
                    console.error('   [Grounding] Sample data:', JSON.stringify(extractedData, null, 2).substring(0, 500));
                    return {
                        valid: false,
                        passed: false,
                        error: 'Invalid extractedData structure - expected fields with {value, sourceQuote, confidence} properties',
                        errors: [{
                            type: 'structure_invalid',
                            message: 'extractedData does not match expected structure. See console for details.',
                            severity: 'CRITICAL'
                        }],
                        warnings: [{
                            type: 'structure_mismatch',
                            message: 'This may indicate the extraction step was skipped or returned incompatible data format',
                            severity: 'WARNING'
                        }],
                        scores: { overall: 0, coverage: 0, quality: 0 }
                    };
                }

                try {
                    const warnings = [];
                    const errors = [];
                    const fieldValidations = [];

                    // Traverse extraction and validate each grounded field
                    const groundingAnalysis = this.analyzeGrounding(
                        extractedData,
                        '',
                        fieldValidations
                    );

                    console.log(`   [Grounding] Fields analyzed: ${groundingAnalysis.totalFields}`);
                    console.log(`   [Grounding] Grounded fields: ${groundingAnalysis.groundedFields}`);
                    console.log(`   [Grounding] Orphaned fields: ${groundingAnalysis.orphanedFields.length}`);

                    // Validate orphaned fields (no sourceQuote)
                    if (groundingAnalysis.orphanedFields.length > 0) {
                        groundingAnalysis.orphanedFields.forEach(field => {
                            errors.push({
                                type: 'orphaned_field',
                                field: field.path,
                                value: field.value,
                                message: `Field "${field.path}" has no sourceQuote - possible fabrication`,
                                severity: 'CRITICAL'
                            });
                        });
                    }

                    // Validate sourceQuote quality
                    const qualityIssues = this.validateSourceQuoteQuality(fieldValidations);
                    qualityIssues.errors.forEach(err => errors.push(err));
                    qualityIssues.warnings.forEach(warn => warnings.push(warn));

                    // Calculate grounding quality scores
                    const scores = this.calculateGroundingScores(fieldValidations, groundingAnalysis);

                    console.log(`   [Grounding] Quality score: ${scores.overall}/100`);
                    console.log(`   [Grounding] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastValidation = {
                        valid: errors.length === 0,
                        passed: scores.coverage >= (CONSTANTS.VALIDATION.GROUNDING_MINIMUM * 100),
                        errors: errors,
                        warnings: warnings,
                        scores: scores,
                        fieldValidations: fieldValidations,
                        groundingAnalysis: groundingAnalysis,
                        validatedAt: new Date().toISOString()
                    };

                    console.log(this.lastValidation.passed ?
                        '‚úÖ [Grounding] Validation PASSED' :
                        '‚ö†Ô∏è  [Grounding] Validation FAILED'
                    );

                    return this.lastValidation;

                } catch (error) {
                    console.error('‚ùå [Grounding] Validation error:', error);
                    return {
                        valid: false,
                        passed: false,
                        error: error.message,
                        scores: { overall: 0 }
                    };
                }
            }

            /**
             * Analyze grounding coverage recursively
             */
            analyzeGrounding(data, path = '', fieldValidations = []) {
                const analysis = {
                    totalFields: 0,
                    groundedFields: 0,
                    orphanedFields: [],
                    inferredFields: [],
                    calculatedFields: []
                };

                if (!data || typeof data !== 'object') {
                    return analysis;
                }

                for (const [key, value] of Object.entries(data)) {
                    const currentPath = path ? `${path}.${key}` : key;

                    if (value === null || value === undefined) {
                        continue;
                    }

                    // Check if this is a grounded field
                    if (this.isGroundedField(value)) {
                        analysis.totalFields++;

                        const validation = {
                            path: currentPath,
                            value: value.value,
                            sourceQuote: value.sourceQuote,
                            confidence: value.confidence,
                            quoteExists: false,
                            quoteQuality: 'NONE',
                            wordCount: 0,
                            deduced: value.deductionMetadata?.deduced || false,
                            calculated: value.calculationMetadata?.method ? true : false
                        };

                        // Check if sourceQuote exists
                        if (value.sourceQuote && value.sourceQuote.trim().length > 0) {
                            analysis.groundedFields++;

                            validation.quoteExists = this.quoteExistsInText(value.sourceQuote);
                            validation.wordCount = value.sourceQuote.split(/\s+/).length;
                            validation.quoteQuality = this.assessQuoteQuality(
                                value.sourceQuote,
                                value.value
                            );
                        } else {
                            analysis.orphanedFields.push({
                                path: currentPath,
                                value: value.value
                            });
                        }

                        if (validation.deduced) {
                            analysis.inferredFields.push(currentPath);
                        }
                        if (validation.calculated) {
                            analysis.calculatedFields.push(currentPath);
                        }

                        fieldValidations.push(validation);

                    } else if (typeof value === 'object' && !Array.isArray(value)) {
                        // Recurse into nested objects
                        const nestedAnalysis = this.analyzeGrounding(value, currentPath, fieldValidations);
                        analysis.totalFields += nestedAnalysis.totalFields;
                        analysis.groundedFields += nestedAnalysis.groundedFields;
                        analysis.orphanedFields.push(...nestedAnalysis.orphanedFields);
                        analysis.inferredFields.push(...nestedAnalysis.inferredFields);
                        analysis.calculatedFields.push(...nestedAnalysis.calculatedFields);
                    }
                }

                return analysis;
            }

            /**
             * Check if extractedData has valid structure with at least one grounded field
             */
            hasValidStructure(data) {
                if (!data || typeof data !== 'object') {
                    console.warn('   [Grounding] Data is null or not an object');
                    return false;
                }

                // Check if at least one field has the expected structure
                let hasValidField = false;
                const traverse = (obj, depth = 0) => {
                    if (depth > 10) return; // Prevent infinite recursion

                    for (const value of Object.values(obj)) {
                        if (value && typeof value === 'object') {
                            if (this.isGroundedField(value)) {
                                hasValidField = true;
                                return;
                            }
                            if (!Array.isArray(value)) {
                                traverse(value, depth + 1);
                            }
                        }
                    }
                };

                traverse(data);

                if (!hasValidField) {
                    console.warn('   [Grounding] No fields found with expected structure {value, sourceQuote, confidence}');
                }

                return hasValidField;
            }

            /**
             * Check if field has grounding metadata
             */
            isGroundedField(value) {
                if (typeof value !== 'object' || value === null) {
                    return false;
                }
                return (
                    value.hasOwnProperty('value') &&
                    value.hasOwnProperty('sourceQuote') &&
                    value.hasOwnProperty('confidence')
                );
            }

            /**
             * Check if sourceQuote exists in original text
             */
            quoteExistsInText(sourceQuote) {
                if (!sourceQuote || !this.sourceText) {
                    return false;
                }
                const normalizedQuote = sourceQuote.trim().toLowerCase().replace(/\s+/g, ' ');
                const normalizedText = this.sourceText.toLowerCase().replace(/\s+/g, ' ');
                return normalizedText.includes(normalizedQuote);
            }

            /**
             * Assess sourceQuote quality
             */
            assessQuoteQuality(sourceQuote, extractedValue) {
                if (!sourceQuote || sourceQuote.trim().length === 0) {
                    return 'NONE';
                }

                const wordCount = sourceQuote.split(/\s+/).length;
                const exists = this.quoteExistsInText(sourceQuote);

                let score = 0;

                // Factor 1: Quote exists in text
                if (exists) score += 40;

                // Factor 2: Quote length (3-10 words ideal)
                if (wordCount >= 3 && wordCount <= 10) {
                    score += 30;
                } else if (wordCount >= 2) {
                    score += 15;
                }

                // Factor 3: Quote relevance
                const relevance = this.assessQuoteRelevance(sourceQuote, extractedValue);
                score += relevance * 30;

                // Map to quality tier
                if (score >= 85) return 'EXCELLENT';
                if (score >= 70) return 'GOOD';
                if (score >= 50) return 'ACCEPTABLE';
                if (score >= 25) return 'POOR';
                return 'VERY_POOR';
            }

            /**
             * Assess relevance of sourceQuote to extracted value
             */
            assessQuoteRelevance(sourceQuote, extractedValue) {
                if (!sourceQuote || !extractedValue) return 0.0;

                const quoteLower = sourceQuote.toLowerCase();
                const valueLower = String(extractedValue).toLowerCase();

                if (quoteLower.includes(valueLower)) return 1.0;

                const valueTerms = valueLower.split(/\s+/).filter(t => t.length > 3);
                const quoteTerms = quoteLower.split(/\s+/);

                if (valueTerms.length === 0) return 0.5;

                const foundTerms = valueTerms.filter(term =>
                    quoteTerms.some(qt => qt.includes(term) || term.includes(qt))
                );

                return foundTerms.length / valueTerms.length;
            }

            /**
             * Validate sourceQuote quality and generate errors/warnings
             */
            validateSourceQuoteQuality(fieldValidations) {
                const errors = [];
                const warnings = [];

                fieldValidations.forEach(field => {
                    // Error: SourceQuote doesn't exist in text
                    if (field.sourceQuote && !field.quoteExists) {
                        errors.push({
                            type: 'quote_not_found',
                            field: field.path,
                            sourceQuote: field.sourceQuote,
                            message: `SourceQuote not found: "${field.sourceQuote.substring(0, 50)}..."`,
                            severity: 'CRITICAL'
                        });
                    }

                    // Error: SourceQuote too short
                    if (field.sourceQuote && field.wordCount < 2) {
                        errors.push({
                            type: 'quote_too_short',
                            field: field.path,
                            wordCount: field.wordCount,
                            message: `SourceQuote too short (${field.wordCount} words)`,
                            severity: 'HIGH'
                        });
                    }

                    // Warning: Poor quality
                    if (['POOR', 'VERY_POOR'].includes(field.quoteQuality)) {
                        warnings.push({
                            type: 'poor_quote_quality',
                            field: field.path,
                            quality: field.quoteQuality,
                            message: `Poor sourceQuote quality (${field.quoteQuality})`
                        });
                    }

                    // Warning: Quote too long
                    if (field.wordCount > 15) {
                        warnings.push({
                            type: 'quote_too_long',
                            field: field.path,
                            wordCount: field.wordCount,
                            message: `SourceQuote very long (${field.wordCount} words)`
                        });
                    }
                });

                return { errors, warnings };
            }

            /**
             * Calculate comprehensive grounding scores
             */
            calculateGroundingScores(fieldValidations, groundingAnalysis) {
                const scores = {
                    overall: 0,
                    coverage: 0,
                    averageQuoteQuality: 0,
                    existenceRate: 0,
                    relevanceAverage: 0
                };

                if (groundingAnalysis.totalFields === 0) {
                    return scores;
                }

                // Coverage score (0-100)
                scores.coverage = Math.round(
                    (groundingAnalysis.groundedFields / groundingAnalysis.totalFields) * 100
                );

                // Average quote quality
                const qualityMap = {
                    'EXCELLENT': 100,
                    'GOOD': 80,
                    'ACCEPTABLE': 60,
                    'POOR': 40,
                    'VERY_POOR': 20,
                    'NONE': 0
                };

                const qualityScores = fieldValidations.map(f => qualityMap[f.quoteQuality] || 0);
                scores.averageQuoteQuality = qualityScores.length > 0
                    ? Math.round(qualityScores.reduce((a, b) => a + b, 0) / qualityScores.length)
                    : 0;

                // Existence rate
                const existingQuotes = fieldValidations.filter(f => f.quoteExists).length;
                scores.existenceRate = fieldValidations.length > 0
                    ? Math.round((existingQuotes / fieldValidations.length) * 100)
                    : 0;

                // Relevance average
                const relevances = fieldValidations
                    .filter(f => f.sourceQuote)
                    .map(f => this.assessQuoteRelevance(f.sourceQuote, f.value));

                scores.relevanceAverage = relevances.length > 0
                    ? Math.round((relevances.reduce((a, b) => a + b, 0) / relevances.length) * 100)
                    : 0;

                // Overall score (weighted)
                scores.overall = Math.round(
                    scores.coverage * 0.3 +
                    scores.averageQuoteQuality * 0.3 +
                    scores.existenceRate * 0.25 +
                    scores.relevanceAverage * 0.15
                );

                return scores;
            }
        }

        console.log('‚úÖ GroundingValidator loaded');

        // ============================================================
        // SECTION 9: FABRICATION DETECTOR
        // ============================================================

        /**
         * FabricationDetector Class
         * Detects fabricated, unsupported, or over-elaborated content using semantic analysis
         * Ported from NeuroScribe V8
         */
        class FabricationDetector {
            constructor(apiClient, options = {}) {
                this.apiClient = apiClient;
                this.lastDetection = null;
                // V10.2.3 FIX #3: Configuration option to disable term-based detection
                // Set to false to rely only on semantic AI detection (eliminates false positives)
                this.enableTermBasedDetection = options.enableTermBasedDetection !== undefined
                    ? options.enableTermBasedDetection
                    : true; // Default: enabled (backward compatible)
            }

            /**
             * Detect fabrications in generated text
             * @param {string} generatedText - Generated output text
             * @param {object} extractedData - Source extraction with grounded fields
             * @param {string} originalText - Original clinical notes
             * @param {object} options - Detection options
             * @returns {Promise<object>} - Detection result with fabricated statements
             */
            async detect(generatedText, extractedData, originalText, options = {}) {
                if (!generatedText) {
                    throw new Error('Generated text is required');
                }

                console.log('üîç [Fabrication] Starting detection...');

                try {
                    const warnings = [];
                    const errors = [];

                    // V10.1 FIX: Handle empty/null extractedData gracefully
                    let sourceQuotes = [];
                    let sourceCorpus = '';

                    if (extractedData && typeof extractedData === 'object' && Object.keys(extractedData).length > 0) {
                        // Use extracted data if available and non-empty
                        sourceQuotes = this.extractAllSourceQuotes(extractedData);
                        sourceCorpus = sourceQuotes.join(' ');
                        console.log(`   [Fabrication] Using extractedData - quotes collected: ${sourceQuotes.length}`);
                    } else if (originalText) {
                        // Fallback: use original text as source corpus
                        console.warn('‚ö†Ô∏è [Fabrication] No extractedData provided, using originalText as source');
                        sourceCorpus = originalText;
                        sourceQuotes = [originalText];  // Treat entire text as one quote
                        console.log(`   [Fabrication] Using originalText - corpus length: ${sourceCorpus.length} chars`);
                    } else {
                        throw new Error('Either extractedData or originalText must be provided for validation');
                    }

                    console.log(`   [Fabrication] Source quotes collected: ${sourceQuotes.length}`);

                    // Split generated text into checkable statements
                    const statements = this.extractStatements(generatedText);
                    console.log(`   [Fabrication] Statements to validate: ${statements.length}`);

                    // Method 1: Term-based detection (fast, preliminary)
                    // V10.2.3 FIX #3: Conditional execution based on configuration
                    let termBasedResults = [];
                    if (this.enableTermBasedDetection) {
                        console.log('   [Fabrication] Running term-based detection (enabled)...');
                        termBasedResults = this.detectFabricationsByTerms(
                            statements,
                            sourceCorpus
                        );
                    } else {
                        console.log('   [Fabrication] ‚è≠Ô∏è  Skipping term-based detection (disabled) - using semantic AI only');
                    }

                    // Method 2: Semantic AI detection (accurate, comprehensive)
                    const semanticResults = await this.detectFabricationsBySemantic(
                        statements,
                        sourceQuotes,
                        originalText,
                        options
                    );

                    // Merge results (semantic takes precedence)
                    const fabrications = this.mergeDetectionResults(
                        termBasedResults,
                        semanticResults,
                        statements
                    );

                    console.log(`   [Fabrication] Detected: ${fabrications.length}`);

                    // V10.2.3 DIAGNOSTIC: Verify V10.2.3 features are present in detected fabrications
                    if (fabrications.length > 0) {
                        const withStatementIndex = fabrications.filter(f => f.statementIndex !== undefined && f.statementIndex !== null).length;
                        const withFixOptions = fabrications.filter(f => f.fixOptions && Array.isArray(f.fixOptions) && f.fixOptions.length > 0).length;
                        console.log(`   üîç [V10.2.3 DIAGNOSTIC] Fabrications with statementIndex: ${withStatementIndex}/${fabrications.length}`);
                        console.log(`   üîç [V10.2.3 DIAGNOSTIC] Fabrications with fixOptions array: ${withFixOptions}/${fabrications.length}`);
                        console.log(`   üîç [V10.2.3 DIAGNOSTIC] First fabrication structure:`, {
                            hasStatement: !!fabrications[0].statement,
                            hasStatementIndex: fabrications[0].statementIndex !== undefined,
                            statementIndexValue: fabrications[0].statementIndex,
                            hasFixOptions: !!fabrications[0].fixOptions,
                            fixOptionsLength: fabrications[0].fixOptions?.length || 0,
                            confidence: fabrications[0].confidence,
                            reason: fabrications[0].reason?.substring(0, 50) + '...'
                        });
                    } else {
                        console.warn(`   ‚ö†Ô∏è [V10.2.3 DIAGNOSTIC] ZERO fabrications detected - this may indicate clean output OR detection failure`);
                    }

                    // Generate errors for fabrications
                    fabrications.forEach(fab => {
                        if (fab.confidence >= 0.7) {
                            errors.push({
                                type: 'fabricated_content',
                                statement: fab.statement,
                                confidence: fab.confidence,
                                reason: fab.reason,
                                correction: fab.suggestedCorrection,
                                message: `Fabricated content detected: "${fab.statement.substring(0, 100)}..." (confidence: ${(fab.confidence * 100).toFixed(0)}%)`,
                                severity: 'CRITICAL'
                            });
                        } else if (fab.confidence >= 0.4) {
                            warnings.push({
                                type: 'possible_fabrication',
                                statement: fab.statement,
                                confidence: fab.confidence,
                                reason: fab.reason,
                                message: `Possible unsupported content: "${fab.statement.substring(0, 100)}..." (confidence: ${(fab.confidence * 100).toFixed(0)}%)`
                            });
                        }
                    });

                    // Check for over-elaboration
                    const elaborationCheck = this.checkOverElaboration(
                        generatedText,
                        sourceQuotes,
                        statements.length
                    );

                    if (elaborationCheck.overElaborated) {
                        warnings.push({
                            type: 'over_elaboration',
                            message: elaborationCheck.message,
                            details: elaborationCheck.details
                        });
                    }

                    // Calculate fabrication score
                    const fabricationScore = this.calculateFabricationScore(
                        fabrications,
                        statements.length,
                        elaborationCheck
                    );

                    console.log(`   [Fabrication] Score: ${fabricationScore}/100`);
                    console.log(`   [Fabrication] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastDetection = {
                        passed: errors.length === 0,
                        errors: errors,
                        warnings: warnings,
                        fabrications: fabrications,
                        fabricationScore: fabricationScore,
                        statementsChecked: statements.length,
                        detectedAt: new Date().toISOString()
                    };

                    console.log(errors.length === 0 ? '‚úÖ [Fabrication] Passed' : '‚ùå [Fabrication] Failed');

                    return {
                        success: true,
                        validation: this.lastDetection,
                        metadata: {
                            statementsChecked: statements.length,
                            fabricationsFound: fabrications.length,
                            fabricationScore: fabricationScore
                        }
                    };

                } catch (error) {
                    console.error('‚ùå [Fabrication] Detection error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        metadata: null
                    };
                }
            }

            /**
             * Extract all sourceQuotes from extracted data recursively
             */
            extractAllSourceQuotes(data, quotes = []) {
                if (!data || typeof data !== 'object') {
                    return quotes;
                }

                // Check if this is a grounded field
                if (data.hasOwnProperty('sourceQuote') && data.sourceQuote) {
                    quotes.push(data.sourceQuote.trim());
                }

                // Recurse into nested structures
                for (const value of Object.values(data)) {
                    if (typeof value === 'object' && value !== null) {
                        this.extractAllSourceQuotes(value, quotes);
                    }
                }

                return quotes;
            }

            /**
             * Extract checkable statements from generated text
             */
            extractStatements(text) {
                // Split by sentence boundaries
                const sentences = text
                    .split(/[.!?]\s+/)
                    .map(s => s.trim())
                    .filter(s => s.length > 10); // Ignore very short fragments

                return sentences;
            }

            /**
             * Term-based fabrication detection (fast, preliminary)
             */
            detectFabricationsByTerms(statements, sourceCorpus) {
                const results = [];
                const corpusLower = sourceCorpus.toLowerCase();

                statements.forEach(statement => {
                    // Extract medical terms (>3 chars, not common words)
                    const terms = statement.toLowerCase()
                        .split(/\s+/)
                        .filter(word =>
                            word.length > 3 &&
                            !/^(the|and|with|for|from|that|this|have|been|were|was)$/.test(word)
                        );

                    if (terms.length === 0) {
                        return; // Skip statements with no medical terms
                    }

                    // Check how many terms exist in source corpus
                    const foundTerms = terms.filter(term => corpusLower.includes(term));
                    const foundRatio = foundTerms.length / terms.length;

                    // V10.2.3 FIX #1: Lowered threshold from 0.5 (50%) to 0.25 (25%) to reduce false positives
                    // If <25% of terms found, possible fabrication
                    if (foundRatio < 0.25) {
                        results.push({
                            statement: statement,
                            foundRatio: foundRatio,
                            method: 'term-based',
                            confidence: 1.0 - foundRatio // Low foundRatio = high fabrication confidence
                        });
                    }
                });

                return results;
            }

            /**
             * Semantic AI-based fabrication detection (accurate, comprehensive)
             */
            async detectFabricationsBySemantic(statements, sourceQuotes, originalText, options = {}) {
                if (statements.length === 0) {
                    return [];
                }

                console.log('   [Fabrication] Running semantic analysis...');

                // Prepare prompt for AI analysis
                const prompt = this.buildSemanticDetectionPrompt(
                    statements,
                    sourceQuotes,
                    originalText
                );

                try {
                    // Use validation temperature (0.1 for deterministic validation)
                    const response = await this.apiClient.generateText(
                        prompt,
                        {
                            temperature: 0.1,
                            maxOutputTokens: 4096
                        }
                    );

                    if (!response) {
                        console.warn('‚ö†Ô∏è [Fabrication] Semantic detection failed, using term-based only');
                        return [];
                    }

                    // Parse AI response
                    const analysisResults = this.parseSemanticDetectionResponse(response);

                    console.log(`   [Fabrication] Semantic analysis complete: ${analysisResults.length} potential fabrications`);

                    return analysisResults;

                } catch (error) {
                    console.warn('‚ö†Ô∏è [Fabrication] Semantic detection error:', error.message);
                    return [];
                }
            }

            /**
             * Build prompt for semantic fabrication detection
             */
            buildSemanticDetectionPrompt(statements, sourceQuotes, originalText) {
                return `You are a medical documentation validator. Your task is to identify fabricated, unsupported, or over-elaborated statements.

**ORIGINAL CLINICAL NOTES:**
${originalText.substring(0, 2000)}...

**EXTRACTED SOURCE QUOTES (Ground Truth):**
${sourceQuotes.slice(0, 30).map((q, i) => `${i + 1}. "${q}"`).join('\n')}

**STATEMENTS TO VALIDATE:**
${statements.slice(0, 50).map((s, i) => `[${i + 1}] ${s}`).join('\n\n')}

**TASK:**
For each statement, determine if it is:
1. **SUPPORTED**: Directly supported by source quotes or original notes
2. **FABRICATED**: Contains information not in source material
3. **OVER-ELABORATED**: Contains source information but with added interpretation/detail

**RULES:**
- A statement is SUPPORTED if its key medical facts appear in source quotes
- A statement is FABRICATED if it introduces new medical facts not documented
- Paraphrasing is acceptable IF the medical meaning is preserved
- Clinical terminology changes (e.g., "SAH" ‚Üí "subarachnoid hemorrhage") are acceptable
- Added interpretations, assumptions, or explanations = FABRICATION

**OUTPUT FORMAT (STRICT JSON) - CRITICALLY IMPORTANT:**

You MUST respond with ONLY valid JSON. No explanatory text before or after. No markdown code blocks. No comments.

Format (if fabrications found):
\`\`\`json
{
  "fabrications": [
    {
      "statementIndex": <number>,
      "statement": "<full statement text>",
      "status": "FABRICATED" or "OVER_ELABORATED",
      "confidence": <0.0-1.0>,
      "reason": "<why this is fabricated>",
      "missingSupport": "<what information lacks grounding>",
      "fixOptions": [
        {
          "option": "remove",
          "text": null,
          "description": "Delete this statement entirely (safest)",
          "confidence": <0.0-1.0>
        },
        {
          "option": "conservative",
          "text": "<minimal safe rephrasing>",
          "description": "Most conservative fix",
          "confidence": <0.0-1.0>
        },
        {
          "option": "moderate",
          "text": "<balanced rephrasing>",
          "description": "Balanced approach",
          "confidence": <0.0-1.0>
        }
      ]
    }
  ]
}
\`\`\`

IMPORTANT: Provide 2-3 fix options per fabrication, ranked from most conservative (safest) to most detailed.

Format (if NO fabrications found):
\`\`\`json
{
  "fabrications": []
}
\`\`\`

CRITICAL RULES:
1. Your response must be parseable by JSON.parse()
2. Do NOT include any text outside the JSON object
3. Do NOT use markdown formatting around the JSON
4. Do NOT include comments in the JSON
5. ALL string values must be properly escaped
6. If response is long, ensure JSON is complete - do not truncate arrays mid-element
7. Test your JSON is valid before responding

Analyze all statements and return ONLY the JSON object:`;
            }

            /**
             * Parse AI response for semantic detection
             */
            parseSemanticDetectionResponse(responseText) {
                try {
                    // Find FIRST complete JSON object, not greedy match
                    const jsonStart = responseText.indexOf('{');
                    const jsonEnd = responseText.lastIndexOf('}');

                    if (jsonStart === -1 || jsonEnd === -1) {
                        console.warn('‚ö†Ô∏è [Fabrication] No JSON found in semantic detection response');
                        console.warn('   Response preview:', responseText.substring(0, 500));
                        return [];
                    }

                    const jsonStr = responseText.substring(jsonStart, jsonEnd + 1);

                    // Pre-validate JSON before parsing
                    let parsed;
                    try {
                        parsed = JSON.parse(jsonStr);
                    } catch (parseError) {
                        console.error('‚ùå [Fabrication] JSON parse error:', parseError.message);

                        // Extract position from error message if available
                        const posMatch = parseError.message.match(/position (\d+)/);
                        if (posMatch) {
                            const errorPos = parseInt(posMatch[1]);
                            const start = Math.max(0, errorPos - 100);
                            const end = Math.min(jsonStr.length, errorPos + 100);
                            console.error('   Error context:', jsonStr.substring(start, end));
                            console.error('   Error at position:', errorPos, 'of', jsonStr.length);
                        }

                        // Log first and last 500 chars of response for debugging
                        console.error('   Response start:', responseText.substring(0, 500));
                        console.error('   Response end:', responseText.substring(Math.max(0, responseText.length - 500)));
                        console.error('   JSON string length:', jsonStr.length);

                        // CRITICAL: Don't silently return empty array - log for debugging
                        console.error('‚ö†Ô∏è [Fabrication] Returning empty array due to parse failure - actual fabrications may be hidden');
                        return [];
                    }

                    if (!parsed.fabrications || !Array.isArray(parsed.fabrications)) {
                        console.warn('‚ö†Ô∏è [Fabrication] Invalid response format - missing fabrications array');
                        console.warn('   Parsed object keys:', Object.keys(parsed));
                        console.warn('   Parsed object type:', typeof parsed.fabrications);
                        return [];
                    }

                    console.log(`‚úÖ [Fabrication] Successfully parsed ${parsed.fabrications.length} fabrications from AI response`);

                    // V10.2.3 DIAGNOSTIC: Log V10.2.3 feature presence in AI response
                    if (parsed.fabrications.length > 0) {
                        const firstFab = parsed.fabrications[0];
                        console.log(`   üîç [V10.2.3 DIAGNOSTIC] AI response structure check:`, {
                            hasStatementIndex: firstFab.hasOwnProperty('statementIndex'),
                            statementIndexValue: firstFab.statementIndex,
                            hasFixOptions: firstFab.hasOwnProperty('fixOptions'),
                            fixOptionsIsArray: Array.isArray(firstFab.fixOptions),
                            fixOptionsCount: firstFab.fixOptions?.length || 0,
                            sampleFixOption: firstFab.fixOptions?.[0]
                        });
                    }

                    return parsed.fabrications.map(fab => ({
                        statement: fab.statement,
                        confidence: fab.confidence || 0.5,
                        reason: fab.reason,
                        missingSupport: fab.missingSupport,
                        // V10.2.3: Parse multiple fix options
                        fixOptions: fab.fixOptions?.map((opt, idx) => ({
                            id: `fix-${idx}`,
                            label: opt.option.charAt(0).toUpperCase() + opt.option.slice(1),
                            text: opt.text,
                            description: opt.description,
                            confidence: opt.confidence,
                            type: opt.option
                        })) || [],
                        // Backward compatibility: use first option as default suggestedCorrection
                        suggestedCorrection: fab.fixOptions?.[0]?.text || fab.suggestedCorrection || null,
                        statementIndex: fab.statementIndex || null,  // V10.2.3: Capture sentence number for pinpoint location
                        method: 'semantic-ai',
                        status: fab.status
                    }));

                } catch (error) {
                    console.error('‚ùå [Fabrication] Failed to parse response:', error.message);
                    console.error('   Stack trace:', error.stack);
                    return [];
                }
            }

            /**
             * Merge term-based and semantic detection results
             * V10.2.3 FIX #2: Improved to preserve fixOptions and statementIndex from semantic results
             */
            mergeDetectionResults(termBased, semantic, allStatements) {
                const merged = [];
                const processedStatements = new Set();

                // Helper: Normalize statement for better duplicate detection
                const normalize = (stmt) => stmt.toLowerCase().trim().replace(/[.!?,;:]/g, '');

                // Phase 1: Add ALL semantic results with ALL properties intact (highest priority)
                // Semantic AI provides: fixOptions, statementIndex, detailed reasoning
                semantic.forEach(result => {
                    merged.push({...result}); // Spread to ensure we get all properties
                    processedStatements.add(normalize(result.statement));
                });

                console.log(`   [Merge] Added ${semantic.length} semantic results (with V10.2.3 features)`);

                // Phase 2: Add term-based results ONLY if not already caught by semantic
                // Use normalized comparison to avoid duplicates with slight text variations
                let termBasedAdded = 0;
                termBased.forEach(result => {
                    const normalized = normalize(result.statement);
                    if (!processedStatements.has(normalized)) {
                        merged.push({
                            statement: result.statement,
                            confidence: result.confidence,
                            reason: `Low source term coverage (${(result.foundRatio * 100).toFixed(0)}%)`,
                            method: result.method,
                            suggestedCorrection: null,
                            fixOptions: [], // V10.2.3: Empty array for consistency
                            statementIndex: null // V10.2.3: No sentence number for term-based
                        });
                        processedStatements.add(normalized);
                        termBasedAdded++;
                    }
                });

                console.log(`   [Merge] Added ${termBasedAdded}/${termBased.length} term-based results (${termBased.length - termBasedAdded} duplicates skipped)`);

                // V10.2.3 FIX #2: Verify semantic features preserved
                const semanticInMerged = merged.filter(f => f.method === 'semantic-ai');
                const withFixOptions = semanticInMerged.filter(f => f.fixOptions && f.fixOptions.length > 0).length;
                const withStatementIndex = semanticInMerged.filter(f => f.statementIndex !== null && f.statementIndex !== undefined).length;
                console.log(`   [Merge] ‚úÖ V10.2.3 feature preservation check:`);
                console.log(`      ‚Üí Semantic results in final: ${semanticInMerged.length}/${semantic.length}`);
                console.log(`      ‚Üí With fixOptions: ${withFixOptions}`);
                console.log(`      ‚Üí With statementIndex: ${withStatementIndex}`);

                return merged;
            }

            /**
             * Check for over-elaboration
             */
            checkOverElaboration(generatedText, sourceQuotes, statementCount) {
                const generatedWordCount = generatedText.split(/\s+/).length;
                const sourceWordCount = sourceQuotes.join(' ').split(/\s+/).length;

                // Calculate expansion ratio
                const expansionRatio = sourceWordCount > 0 ? generatedWordCount / sourceWordCount : 0;

                let overElaborated = false;
                let message = '';
                let details = {};

                if (expansionRatio > 3.0 && sourceQuotes.length < 10) {
                    // More than 3x expansion with sparse source data
                    overElaborated = true;
                    message = `Generated text (${generatedWordCount} words) is ${expansionRatio.toFixed(1)}x longer than source material (${sourceWordCount} words) - possible over-elaboration`;
                    details = {
                        generatedWords: generatedWordCount,
                        sourceWords: sourceWordCount,
                        expansionRatio: expansionRatio.toFixed(2),
                        sourceQuoteCount: sourceQuotes.length
                    };
                } else if (statementCount > sourceQuotes.length * 2) {
                    // More than 2x statements compared to source quotes
                    overElaborated = true;
                    message = `Generated ${statementCount} statements from ${sourceQuotes.length} source quotes - possible over-elaboration`;
                    details = {
                        statementsGenerated: statementCount,
                        sourceQuotes: sourceQuotes.length,
                        ratio: (statementCount / sourceQuotes.length).toFixed(2)
                    };
                }

                return {
                    overElaborated: overElaborated,
                    message: message,
                    details: details
                };
            }

            /**
             * Calculate fabrication score (0-100, higher is better)
             */
            calculateFabricationScore(fabrications, totalStatements, elaborationCheck) {
                if (totalStatements === 0) {
                    return 100;
                }

                let score = 100;

                // Deduct for fabrications
                const criticalFabrications = fabrications.filter(f => f.confidence >= 0.7).length;
                const possibleFabrications = fabrications.filter(f => f.confidence >= 0.4 && f.confidence < 0.7).length;

                score -= criticalFabrications * 15; // -15 per critical fabrication
                score -= possibleFabrications * 5;  // -5 per possible fabrication

                // Deduct for over-elaboration
                if (elaborationCheck.overElaborated) {
                    score -= 10;
                }

                // Calculate fabrication rate
                const fabricationRate = fabrications.length / totalStatements;
                if (fabricationRate > 0.3) {
                    score -= 20; // High fabrication rate penalty
                }

                return Math.max(0, Math.min(100, score));
            }

            /**
             * Get last detection result
             */
            getLastDetection() {
                return this.lastDetection;
            }

            /**
             * Get fabricated statements only
             */
            getFabricatedStatements() {
                if (!this.lastDetection) {
                    return [];
                }
                return this.lastDetection.fabrications;
            }
        }

        console.log('‚úÖ FabricationDetector loaded');

        // ============================================================
        // SECTION 10: COMPLETENESS CHECKER
        // ============================================================

        /**
         * CompletenessChecker Class
         * Bidirectional validation to ensure all documented facts are extracted
         * Ported from NeuroScribe V8
         */
        class CompletenessChecker {
            constructor(apiClient) {
                this.apiClient = apiClient;
                this.lastCheck = null;
            }

            /**
             * Check completeness of extraction
             * @param {object} extractedData - Extraction result
             * @param {string} originalText - Original clinical text
             * @param {object} options - Check options
             * @returns {Promise<object>} - Completeness validation result
             */
            async check(extractedData, originalText, options = {}) {
                if (!extractedData || !originalText) {
                    throw new Error('Both extracted data and original text are required');
                }

                console.log('üîç [Completeness] Starting check...');

                try {
                    const warnings = [];
                    const errors = [];

                    // 1. Backward validation: Extraction ‚Üí Notes
                    console.log('   [Completeness] Backward validation (extraction ‚Üí notes)...');
                    const backwardCheck = this.checkBackwardCompleteness(extractedData, originalText);

                    // 2. Forward validation: Notes ‚Üí Extraction (AI-powered)
                    console.log('   [Completeness] Forward validation (notes ‚Üí extraction)...');
                    const forwardCheck = await this.checkForwardCompleteness(
                        originalText,
                        extractedData,
                        options
                    );

                    // 3. Section coverage analysis
                    console.log('   [Completeness] Analyzing section coverage...');
                    const sectionCoverage = this.analyzeSectionCoverage(extractedData, originalText);

                    // 4. Critical field coverage
                    const criticalFieldsCheck = this.checkCriticalFields(extractedData);

                    // Generate warnings and errors
                    if (backwardCheck.unmatchedFields.length > 0) {
                        backwardCheck.unmatchedFields.forEach(field => {
                            warnings.push({
                                type: 'ungrounded_extraction',
                                field: field.path,
                                value: field.value,
                                message: `Extracted field not found in original text: ${field.path}`
                            });
                        });
                    }

                    // Forward completeness issues
                    if (forwardCheck.missingExtractions.length > 0) {
                        forwardCheck.missingExtractions.forEach(missing => {
                            if (missing.importance === 'CRITICAL') {
                                errors.push({
                                    type: 'missing_critical_extraction',
                                    category: missing.category,
                                    information: missing.information,
                                    sourceQuote: missing.sourceQuote,
                                    message: `Critical information not extracted: ${missing.information}`,
                                    severity: 'HIGH'
                                });
                            } else {
                                warnings.push({
                                    type: 'missing_extraction',
                                    category: missing.category,
                                    information: missing.information,
                                    sourceQuote: missing.sourceQuote,
                                    message: `Information may not be extracted: ${missing.information}`
                                });
                            }
                        });
                    }

                    // Section coverage issues
                    if (sectionCoverage.missingImportantSections.length > 0) {
                        sectionCoverage.missingImportantSections.forEach(section => {
                            warnings.push({
                                type: 'missing_section',
                                section: section.name,
                                message: `Important section "${section.name}" mentioned in notes but not extracted`
                            });
                        });
                    }

                    // Critical field issues
                    if (criticalFieldsCheck.missingCritical.length > 0) {
                        criticalFieldsCheck.missingCritical.forEach(field => {
                            errors.push({
                                type: 'missing_critical_field',
                                field: field,
                                message: `Critical required field missing: ${field}`,
                                severity: 'CRITICAL'
                            });
                        });
                    }

                    // Calculate completeness scores
                    const scores = this.calculateCompletenessScores(
                        backwardCheck,
                        forwardCheck,
                        sectionCoverage,
                        criticalFieldsCheck
                    );

                    console.log(`   [Completeness] Score: ${scores.overall}/100`);
                    console.log(`   [Completeness] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastCheck = {
                        passed: errors.length === 0,
                        errors: errors,
                        warnings: warnings,
                        scores: scores,
                        backwardCheck: backwardCheck,
                        forwardCheck: forwardCheck,
                        sectionCoverage: sectionCoverage,
                        criticalFieldsCheck: criticalFieldsCheck,
                        checkedAt: new Date().toISOString()
                    };

                    console.log(errors.length === 0 ? '‚úÖ [Completeness] Passed' : '‚ùå [Completeness] Issues detected');

                    return {
                        success: true,
                        validation: this.lastCheck,
                        metadata: {
                            extractedFields: backwardCheck.totalFields,
                            groundedFields: backwardCheck.matchedFields,
                            missingExtractions: forwardCheck.missingExtractions.length,
                            sectionsCovered: sectionCoverage.coveredSections.length,
                            completenessScore: scores.overall
                        }
                    };

                } catch (error) {
                    console.error('‚ùå [Completeness] Check error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        metadata: null
                    };
                }
            }

            /**
             * Backward completeness: Extraction ‚Üí Notes
             */
            checkBackwardCompleteness(extractedData, originalText) {
                const normalizedText = originalText.toLowerCase().replace(/\s+/g, ' ');
                const unmatchedFields = [];
                let totalFields = 0;
                let matchedFields = 0;

                this.traverseExtraction(extractedData, '', (path, field) => {
                    totalFields++;

                    if (field.sourceQuote) {
                        const normalizedQuote = field.sourceQuote.toLowerCase().replace(/\s+/g, ' ');

                        if (normalizedText.includes(normalizedQuote)) {
                            matchedFields++;
                        } else {
                            unmatchedFields.push({
                                path: path,
                                value: field.value,
                                sourceQuote: field.sourceQuote
                            });
                        }
                    } else {
                        unmatchedFields.push({
                            path: path,
                            value: field.value,
                            sourceQuote: null
                        });
                    }
                });

                return {
                    totalFields: totalFields,
                    matchedFields: matchedFields,
                    unmatchedFields: unmatchedFields,
                    backwardCompleteness: totalFields > 0 ? matchedFields / totalFields : 1.0
                };
            }

            /**
             * Forward completeness: Notes ‚Üí Extraction
             */
            async checkForwardCompleteness(originalText, extractedData, options = {}) {
                console.log('   [Completeness] Running AI-powered forward analysis...');

                const extractedSummary = this.buildExtractionSummary(extractedData);
                const prompt = this.buildForwardCompletenessPrompt(originalText, extractedSummary);

                try {
                    const response = await this.apiClient.generateText(
                        prompt,
                        {
                            temperature: 0.2,
                            maxOutputTokens: 3072
                        }
                    );

                    if (!response) {
                        console.warn('‚ö†Ô∏è [Completeness] Forward check failed');
                        return { missingExtractions: [], forwardCompleteness: 1.0 };
                    }

                    const missingExtractions = this.parseForwardCompletenessResponse(response);

                    console.log(`   [Completeness] Missing extractions: ${missingExtractions.length}`);

                    const totalMentioned = extractedSummary.fieldCount + missingExtractions.length;
                    const forwardCompleteness = totalMentioned > 0
                        ? extractedSummary.fieldCount / totalMentioned
                        : 1.0;

                    return {
                        missingExtractions: missingExtractions,
                        forwardCompleteness: forwardCompleteness
                    };

                } catch (error) {
                    console.warn('‚ö†Ô∏è [Completeness] Forward check error:', error.message);
                    return { missingExtractions: [], forwardCompleteness: 1.0 };
                }
            }

            /**
             * Build summary of what was extracted
             */
            buildExtractionSummary(data) {
                const summary = {
                    fields: [],
                    fieldCount: 0,
                    sections: new Set()
                };

                this.traverseExtraction(data, '', (path, field) => {
                    summary.fieldCount++;
                    summary.fields.push({
                        path: path,
                        value: field.value,
                        sourceQuote: field.sourceQuote
                    });

                    const topSection = path.split('.')[0];
                    summary.sections.add(topSection);
                });

                return summary;
            }

            /**
             * Build prompt for forward completeness check
             */
            buildForwardCompletenessPrompt(originalText, extractedSummary) {
                return `You are a medical documentation completeness auditor. Identify clinical information in notes NOT captured in extraction.

**ORIGINAL CLINICAL NOTES:**
${originalText.substring(0, 3000)}

**WHAT WAS EXTRACTED:**
${extractedSummary.fields.slice(0, 50).map(f => `- ${f.path}: ${f.value}`).join('\n')}

**SECTIONS COVERED:** ${Array.from(extractedSummary.sections).join(', ')}

**TASK:**
Identify clinically significant information NOT extracted. Focus on:

1. **Patient demographics** (age, sex, medical history)
2. **Symptoms and presentation**
3. **Physical exam findings** (neurological)
4. **Imaging findings** (measurements, locations)
5. **Diagnoses** (primary and secondary)
6. **Procedures** (past, current, planned)
7. **Medications**
8. **Clinical scores** (GCS, mRS, KPS, etc.)
9. **Plans and follow-up**

**RULES:**
- Only flag EXPLICIT mentions
- Medical measurements, scores, laterality are CRITICAL
- Vague references don't need extraction
- Background context is acceptable to omit

**OUTPUT FORMAT (JSON):**
\`\`\`json
{
  "missingExtractions": [
    {
      "category": "imaging|diagnosis|procedure|medication|symptoms|scores|demographics",
      "information": "<what information is missing>",
      "sourceQuote": "<exact quote from notes>",
      "importance": "CRITICAL" | "IMPORTANT" | "MINOR",
      "suggestedField": "<where this should be extracted>"
    }
  ]
}
\`\`\`

Return ONLY JSON. If nothing missing, return empty array.`;
            }

            /**
             * Parse AI response for forward completeness
             */
            parseForwardCompletenessResponse(responseText) {
                try {
                    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    if (!jsonMatch) {
                        console.warn('‚ö†Ô∏è [Completeness] No JSON in response');
                        return [];
                    }

                    const parsed = JSON.parse(jsonMatch[0]);

                    if (!parsed.missingExtractions || !Array.isArray(parsed.missingExtractions)) {
                        console.warn('‚ö†Ô∏è [Completeness] Invalid response format');
                        return [];
                    }

                    return parsed.missingExtractions;

                } catch (error) {
                    console.warn('‚ö†Ô∏è [Completeness] Parse error:', error.message);
                    return [];
                }
            }

            /**
             * Analyze section coverage
             */
            analyzeSectionCoverage(extractedData, originalText) {
                const expectedSections = [
                    { name: 'demographics', keywords: ['age', 'year old', 'male', 'female', 'patient'] },
                    { name: 'symptoms', keywords: ['presents', 'complains', 'symptoms', 'history of present'] },
                    { name: 'examination', keywords: ['exam', 'examination', 'neurological', 'motor', 'sensory'] },
                    { name: 'imaging', keywords: ['MRI', 'CT', 'CTA', 'scan', 'imaging', 'shows'] },
                    { name: 'diagnosis', keywords: ['diagnosis', 'impression', 'assessment'] },
                    { name: 'procedures', keywords: ['surgery', 'procedure', 'operation', 'craniotomy', 'laminectomy'] },
                    { name: 'medications', keywords: ['medication', 'drug', 'prescribed', 'started'] },
                    { name: 'plan', keywords: ['plan', 'will', 'scheduled', 'follow-up'] }
                ];

                const textLower = originalText.toLowerCase();
                const coveredSections = [];
                const missingImportantSections = [];

                expectedSections.forEach(section => {
                    const mentioned = section.keywords.some(keyword => textLower.includes(keyword));

                    if (mentioned) {
                        const extracted = this.sectionHasData(extractedData, section.name);

                        if (extracted) {
                            coveredSections.push(section.name);
                        } else {
                            missingImportantSections.push({
                                name: section.name,
                                keywords: section.keywords
                            });
                        }
                    }
                });

                return {
                    coveredSections: coveredSections,
                    missingImportantSections: missingImportantSections,
                    coverageRatio: expectedSections.length > 0
                        ? coveredSections.length / expectedSections.length
                        : 1.0
                };
            }

            /**
             * Check if section has extracted data
             */
            sectionHasData(data, sectionName) {
                if (!data || typeof data !== 'object') {
                    return false;
                }

                const section = data[sectionName] || data[sectionName + 's'];
                if (!section) {
                    return false;
                }

                let hasData = false;
                this.traverseExtraction(section, '', (path, field) => {
                    if (field.sourceQuote && field.sourceQuote.trim().length > 0) {
                        hasData = true;
                    }
                });

                return hasData;
            }

            /**
             * Check critical required fields
             */
            checkCriticalFields(extractedData) {
                const criticalFields = [
                    'demographics.age',
                    'pathology.primaryDiagnosis.name'
                ];

                const missingCritical = [];

                criticalFields.forEach(fieldPath => {
                    const value = this.getFieldByPath(extractedData, fieldPath);
                    if (!value || (value.value === null || value.value === undefined || value.value === '')) {
                        missingCritical.push(fieldPath);
                    }
                });

                return {
                    missingCritical: missingCritical,
                    criticalFieldsPresent: criticalFields.length - missingCritical.length,
                    totalCriticalFields: criticalFields.length
                };
            }

            /**
             * Get field value by path
             */
            getFieldByPath(data, path) {
                const parts = path.split('.');
                let current = data;

                for (const part of parts) {
                    if (!current || typeof current !== 'object') {
                        return null;
                    }
                    current = current[part];
                }

                return current;
            }

            /**
             * Traverse extraction and call callback for each grounded field
             */
            traverseExtraction(data, path = '', callback) {
                if (!data || typeof data !== 'object') {
                    return;
                }

                for (const [key, value] of Object.entries(data)) {
                    if (value === null || value === undefined) {
                        continue;
                    }

                    const currentPath = path ? `${path}.${key}` : key;

                    // Check if grounded field
                    if (typeof value === 'object' &&
                        value.hasOwnProperty('value') &&
                        value.hasOwnProperty('sourceQuote') &&
                        value.hasOwnProperty('confidence')) {

                        callback(currentPath, value);

                    } else if (typeof value === 'object' && !Array.isArray(value)) {
                        this.traverseExtraction(value, currentPath, callback);
                    } else if (Array.isArray(value)) {
                        value.forEach((item, index) => {
                            this.traverseExtraction(item, `${currentPath}[${index}]`, callback);
                        });
                    }
                }
            }

            /**
             * Calculate completeness scores
             */
            calculateCompletenessScores(backwardCheck, forwardCheck, sectionCoverage, criticalFieldsCheck) {
                const scores = {
                    overall: 0,
                    backwardCompleteness: Math.round(backwardCheck.backwardCompleteness * 100),
                    forwardCompleteness: Math.round(forwardCheck.forwardCompleteness * 100),
                    sectionCoverage: Math.round(sectionCoverage.coverageRatio * 100),
                    criticalFields: Math.round(
                        (criticalFieldsCheck.criticalFieldsPresent / criticalFieldsCheck.totalCriticalFields) * 100
                    )
                };

                // Overall score (weighted average)
                scores.overall = Math.round(
                    scores.backwardCompleteness * 0.25 +
                    scores.forwardCompleteness * 0.40 + // Most important
                    scores.sectionCoverage * 0.20 +
                    scores.criticalFields * 0.15
                );

                return scores;
            }

            /**
             * Get last check result
             */
            getLastCheck() {
                return this.lastCheck;
            }

            /**
             * Get missing extractions
             */
            getMissingExtractions() {
                if (!this.lastCheck) {
                    return [];
                }
                return this.lastCheck.forwardCheck.missingExtractions;
            }
        }

        console.log('‚úÖ CompletenessChecker loaded');

        // ============================================================
        // SECTION 11: CONSISTENCY VALIDATOR
        // ============================================================

        /**
         * ConsistencyValidator Class
         * Medical knowledge-based consistency checking
         * CRITICAL: Detects medically implausible or contradictory information
         * Ported from NeuroScribe V8
         */
        class ConsistencyValidator {
            constructor(apiClient) {
                this.apiClient = apiClient;
                this.lastValidation = null;
                this.medicalKnowledge = this.initializeMedicalKnowledge();
            }

            /**
             * Initialize medical knowledge base
             */
            initializeMedicalKnowledge() {
                return {
                    // Spinal levels
                    spinalLevels: {
                        cervical: ['C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7'],
                        thoracic: ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12'],
                        lumbar: ['L1', 'L2', 'L3', 'L4', 'L5'],
                        sacral: ['S1', 'S2', 'S3', 'S4', 'S5']
                    },

                    // GCS score ranges
                    gcsScores: {
                        severe: { range: [3, 8], meaning: 'severe impairment' },
                        moderate: { range: [9, 12], meaning: 'moderate impairment' },
                        mild: { range: [13, 14], meaning: 'mild impairment' },
                        normal: { range: [15, 15], meaning: 'fully alert' }
                    },

                    // mRS score meanings
                    mrsScores: {
                        0: 'no symptoms',
                        1: 'no significant disability',
                        2: 'slight disability',
                        3: 'moderate disability',
                        4: 'moderately severe disability',
                        5: 'severe disability',
                        6: 'dead'
                    },

                    // KPS score ranges
                    kpsScores: {
                        high: { range: [80, 100], meaning: 'normal activity' },
                        moderate: { range: [50, 70], meaning: 'requires assistance' },
                        low: { range: [10, 40], meaning: 'disabled, requires care' }
                    },

                    // Laterality rules (neuroanatomical decussation)
                    lateralityRules: {
                        cerebral: 'contralateral',  // Right brain ‚Üí Left body
                        cerebellar: 'ipsilateral',  // Right cerebellum ‚Üí Right body
                        spinal: 'ipsilateral'       // Right spinal ‚Üí Right symptoms
                    },

                    // Pathology keywords
                    pathologyKeywords: {
                        vascular: ['hemorrhage', 'aneurysm', 'stroke', 'ischemia', 'SAH', 'ICH', 'infarct'],
                        tumor: ['glioblastoma', 'meningioma', 'tumor', 'mass', 'neoplasm', 'metastasis'],
                        degenerative: ['stenosis', 'spondylosis', 'herniation', 'disc', 'DDD'],
                        trauma: ['fracture', 'TBI', 'SCI', 'contusion', 'hematoma'],
                        infection: ['abscess', 'meningitis', 'osteomyelitis', 'infection']
                    }
                };
            }

            /**
             * Validate consistency of extracted data
             */
            async validate(extractedData, originalText, options = {}) {
                if (!extractedData) {
                    throw new Error('Extracted data is required');
                }

                console.log('üîç [Consistency] Starting validation...');

                try {
                    const warnings = [];
                    const errors = [];

                    // 1. Laterality consistency
                    console.log('   [Consistency] Checking laterality...');
                    const lateralityIssues = this.checkLateralityConsistency(extractedData);
                    lateralityIssues.forEach(issue => {
                        errors.push({
                            type: 'laterality_inconsistency',
                            ...issue,
                            severity: 'HIGH'
                        });
                    });

                    // 2. Anatomical level consistency
                    console.log('   [Consistency] Checking anatomical levels...');
                    const anatomicalIssues = this.checkAnatomicalConsistency(extractedData);
                    anatomicalIssues.forEach(issue => {
                        errors.push({
                            type: 'anatomical_inconsistency',
                            ...issue,
                            severity: 'HIGH'
                        });
                    });

                    // 3. Clinical score consistency
                    console.log('   [Consistency] Checking clinical scores...');
                    const scoreIssues = this.checkScoreConsistency(extractedData);
                    scoreIssues.forEach(issue => {
                        if (issue.severity === 'HIGH') {
                            errors.push({
                                type: 'score_inconsistency',
                                ...issue
                            });
                        } else {
                            warnings.push({
                                type: 'score_warning',
                                ...issue
                            });
                        }
                    });

                    // 4. Temporal consistency
                    console.log('   [Consistency] Checking temporal order...');
                    const temporalIssues = this.checkTemporalConsistency(extractedData);
                    temporalIssues.forEach(issue => {
                        errors.push({
                            type: 'temporal_inconsistency',
                            ...issue,
                            severity: 'MEDIUM'
                        });
                    });

                    // 5. Pathology consistency
                    console.log('   [Consistency] Checking pathology-procedure match...');
                    const pathologyIssues = this.checkPathologyConsistency(extractedData);
                    pathologyIssues.forEach(issue => {
                        warnings.push({
                            type: 'pathology_mismatch',
                            ...issue
                        });
                    });

                    // Calculate consistency score
                    const consistencyScore = this.calculateConsistencyScore(
                        errors.length,
                        warnings.length
                    );

                    console.log(`   [Consistency] Score: ${consistencyScore}/100`);
                    console.log(`   [Consistency] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastValidation = {
                        passed: errors.length === 0,
                        errors: errors,
                        warnings: warnings,
                        consistencyScore: consistencyScore,
                        validatedAt: new Date().toISOString()
                    };

                    console.log(errors.length === 0 ? '‚úÖ [Consistency] Passed' : '‚ùå [Consistency] Issues detected');

                    return {
                        success: true,
                        validation: this.lastValidation,
                        metadata: {
                            totalIssues: errors.length + warnings.length,
                            criticalIssues: errors.length,
                            consistencyScore: consistencyScore
                        }
                    };

                } catch (error) {
                    console.error('‚ùå [Consistency] Validation error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        metadata: null
                    };
                }
            }

            /**
             * Check laterality consistency (neuroanatomical decussation rules)
             */
            checkLateralityConsistency(data) {
                const issues = [];

                // Extract lateralized findings
                const lesionSide = this.extractLaterality(data, 'imaging.findings', 'lesion');
                const symptomSide = this.extractLaterality(data, 'symptoms', 'symptom');
                const diagnosisSide = this.extractLaterality(data, 'pathology', 'diagnosis');

                // Determine pathology location
                const pathologyLocation = this.determinePathologyLocation(data);

                // Apply decussation rules
                if (pathologyLocation === 'cerebral') {
                    // Cerebral lesions: contralateral symptoms
                    if (lesionSide && symptomSide && lesionSide === symptomSide) {
                        issues.push({
                            field1: 'imaging.findings (lesion)',
                            field2: 'symptoms',
                            value1: `${lesionSide} sided lesion`,
                            value2: `${symptomSide} sided symptoms`,
                            message: `${lesionSide} cerebral lesion should cause contralateral (${this.oppositeSide(lesionSide)}) symptoms, not ${symptomSide}-sided`,
                            expectedValue: `${this.oppositeSide(lesionSide)} sided symptoms`
                        });
                    }

                } else if (pathologyLocation === 'spinal') {
                    // Spinal lesions: ipsilateral symptoms
                    if (lesionSide && symptomSide && lesionSide !== symptomSide) {
                        issues.push({
                            field1: 'imaging.findings (lesion)',
                            field2: 'symptoms',
                            value1: `${lesionSide} sided lesion`,
                            value2: `${symptomSide} sided symptoms`,
                            message: `${lesionSide} spinal lesion should cause ipsilateral (${lesionSide}) symptoms, not ${symptomSide}-sided`,
                            expectedValue: `${lesionSide} sided symptoms`
                        });
                    }
                }

                return issues;
            }

            /**
             * Extract laterality from data section
             */
            extractLaterality(data, sectionPath, context) {
                const section = this.getFieldByPath(data, sectionPath);
                if (!section) return null;

                const lateralityKeywords = {
                    left: /\b(left|l(?:eft)?)\b/i,
                    right: /\b(right|r(?:ight)?)\b/i
                };

                let foundSide = null;
                this.traverseSection(section, (field) => {
                    if (!foundSide && field.value) {
                        const valueStr = String(field.value).toLowerCase();
                        if (lateralityKeywords.left.test(valueStr)) {
                            foundSide = 'left';
                        } else if (lateralityKeywords.right.test(valueStr)) {
                            foundSide = 'right';
                        }
                    }

                    if (!foundSide && field.sourceQuote) {
                        const quoteStr = field.sourceQuote.toLowerCase();
                        if (lateralityKeywords.left.test(quoteStr)) {
                            foundSide = 'left';
                        } else if (lateralityKeywords.right.test(quoteStr)) {
                            foundSide = 'right';
                        }
                    }
                });

                return foundSide;
            }

            /**
             * Determine pathology location
             */
            determinePathologyLocation(data) {
                const diagnosis = this.getFieldValue(data, 'pathology.primaryDiagnosis.name');
                const imagingFindings = this.getAllSourceQuotes(data.imaging);

                const allText = `${diagnosis} ${imagingFindings}`.toLowerCase();

                if (/\b(cervical|thoracic|lumbar|sacral|spine|spinal|vertebra|disc)\b/i.test(allText)) {
                    return 'spinal';
                } else if (/\b(cerebellar|cerebellum)\b/i.test(allText)) {
                    return 'cerebellar';
                } else if (/\b(cerebral|brain|frontal|parietal|temporal|occipital|hemisphere)\b/i.test(allText)) {
                    return 'cerebral';
                }

                return 'unknown';
            }

            /**
             * Get opposite side for laterality
             */
            oppositeSide(side) {
                if (side === 'left') return 'right';
                if (side === 'right') return 'left';
                return null;
            }

            /**
             * Check anatomical level consistency
             */
            checkAnatomicalConsistency(data) {
                const issues = [];

                const diagnosisLevel = this.extractSpinalLevel(data, 'pathology');
                const procedureLevel = this.extractSpinalLevel(data, 'procedures');

                if (diagnosisLevel && procedureLevel) {
                    const diagnosisRegion = this.getSpinalRegion(diagnosisLevel);
                    const procedureRegion = this.getSpinalRegion(procedureLevel);

                    if (diagnosisRegion !== procedureRegion && diagnosisRegion !== 'unknown' && procedureRegion !== 'unknown') {
                        issues.push({
                            field1: 'pathology (diagnosis level)',
                            field2: 'procedures (procedure level)',
                            value1: `${diagnosisLevel} (${diagnosisRegion})`,
                            value2: `${procedureLevel} (${procedureRegion})`,
                            message: `Diagnosis at ${diagnosisLevel} (${diagnosisRegion}) but procedure at ${procedureLevel} (${procedureRegion}) - region mismatch`,
                            expectedValue: `Procedure should be in ${diagnosisRegion} region`
                        });
                    }
                }

                return issues;
            }

            /**
             * Extract spinal level from section
             */
            extractSpinalLevel(data, sectionPath) {
                const section = this.getFieldByPath(data, sectionPath);
                if (!section) return null;

                const levelPattern = /\b([CTLS])(\d{1,2})(?:-([CTLS])?(\d{1,2}))?\b/gi;

                let foundLevel = null;
                this.traverseSection(section, (field) => {
                    if (!foundLevel) {
                        const text = `${field.value} ${field.sourceQuote}`;
                        const match = levelPattern.exec(text);
                        if (match) {
                            foundLevel = match[0].toUpperCase();
                        }
                    }
                });

                return foundLevel;
            }

            /**
             * Get spinal region from level
             */
            getSpinalRegion(level) {
                if (!level) return 'unknown';

                const levelUpper = level.toUpperCase();

                for (const [region, levels] of Object.entries(this.medicalKnowledge.spinalLevels)) {
                    if (levels.some(l => levelUpper.includes(l))) {
                        return region;
                    }
                }

                return 'unknown';
            }

            /**
             * Check clinical score consistency
             */
            checkScoreConsistency(data) {
                const issues = [];

                // Check GCS consistency
                const gcs = this.getFieldValue(data, 'clinicalScores.gcs.total');
                if (gcs !== null && gcs !== undefined) {
                    const gcsNum = parseInt(gcs);

                    // Validate GCS range (3-15)
                    if (gcsNum < 3 || gcsNum > 15) {
                        issues.push({
                            field: 'clinicalScores.gcs.total',
                            value: gcs,
                            message: `GCS score ${gcs} is outside valid range (3-15)`,
                            severity: 'HIGH'
                        });
                    }

                    // Check GCS components
                    const gcsComponents = this.getFieldValue(data, 'clinicalScores.gcs.components');
                    if (gcsComponents) {
                        const componentMatch = gcsComponents.match(/E(\d+)V(\d+)M(\d+)/i);
                        if (componentMatch) {
                            const e = parseInt(componentMatch[1]);
                            const v = parseInt(componentMatch[2]);
                            const m = parseInt(componentMatch[3]);
                            const calculatedTotal = e + v + m;

                            if (calculatedTotal !== gcsNum) {
                                issues.push({
                                    field: 'clinicalScores.gcs',
                                    value: `Total: ${gcs}, Components: ${gcsComponents}`,
                                    message: `GCS components (E${e}V${v}M${m}) sum to ${calculatedTotal}, but total is ${gcs}`,
                                    severity: 'HIGH'
                                });
                            }
                        }
                    }
                }

                // Check mRS consistency
                const mrs = this.getFieldValue(data, 'outcomes.functionalStatus.mRS');
                if (mrs !== null && mrs !== undefined) {
                    const mrsNum = parseInt(mrs);

                    if (mrsNum < 0 || mrsNum > 6) {
                        issues.push({
                            field: 'outcomes.functionalStatus.mRS',
                            value: mrs,
                            message: `mRS score ${mrs} is outside valid range (0-6)`,
                            severity: 'HIGH'
                        });
                    }
                }

                // Check KPS consistency
                const kps = this.getFieldValue(data, 'outcomes.functionalStatus.KPS');
                if (kps !== null && kps !== undefined) {
                    const kpsNum = parseInt(kps);

                    if (kpsNum < 0 || kpsNum > 100 || kpsNum % 10 !== 0) {
                        issues.push({
                            field: 'outcomes.functionalStatus.KPS',
                            value: kps,
                            message: `KPS score ${kps} should be 0-100 in increments of 10`,
                            severity: 'HIGH'
                        });
                    }
                }

                return issues;
            }

            /**
             * Check temporal consistency (dates in logical order)
             */
            checkTemporalConsistency(data) {
                const issues = [];

                const dob = this.parseDate(this.getFieldValue(data, 'demographics.dateOfBirth'));
                const admission = this.parseDate(this.getFieldValue(data, 'timeline.admissionDate'));
                const discharge = this.parseDate(this.getFieldValue(data, 'timeline.dischargeDate'));

                // Check chronological order
                if (dob && admission && dob > admission) {
                    issues.push({
                        field1: 'demographics.dateOfBirth',
                        field2: 'timeline.admissionDate',
                        value1: this.getFieldValue(data, 'demographics.dateOfBirth'),
                        value2: this.getFieldValue(data, 'timeline.admissionDate'),
                        message: 'Date of birth is after admission date - impossible'
                    });
                }

                if (admission && discharge && admission > discharge) {
                    issues.push({
                        field1: 'timeline.admissionDate',
                        field2: 'timeline.dischargeDate',
                        value1: this.getFieldValue(data, 'timeline.admissionDate'),
                        value2: this.getFieldValue(data, 'timeline.dischargeDate'),
                        message: 'Admission date is after discharge date - impossible'
                    });
                }

                return issues;
            }

            /**
             * Check pathology-procedure consistency
             */
            checkPathologyConsistency(data) {
                const issues = [];

                const diagnosis = this.getFieldValue(data, 'pathology.primaryDiagnosis.name');
                const procedures = this.getAllFieldValues(data, 'procedures');

                if (!diagnosis || procedures.length === 0) {
                    return issues;
                }

                const diagnosisLower = diagnosis.toLowerCase();
                const pathologyType = this.classifyPathology(diagnosisLower);
                const procedureTypes = procedures.map(p => this.classifyProcedure(p.toLowerCase()));

                if (pathologyType && !procedureTypes.includes(pathologyType) && procedureTypes.length > 0) {
                    issues.push({
                        field1: 'pathology.primaryDiagnosis.name',
                        field2: 'procedures',
                        value1: diagnosis,
                        value2: procedures.join(', '),
                        message: `Diagnosis suggests ${pathologyType} pathology but procedures suggest ${procedureTypes.join('/')} approach`
                    });
                }

                return issues;
            }

            /**
             * Classify pathology type
             */
            classifyPathology(diagnosisText) {
                for (const [type, keywords] of Object.entries(this.medicalKnowledge.pathologyKeywords)) {
                    if (keywords.some(keyword => diagnosisText.includes(keyword.toLowerCase()))) {
                        return type;
                    }
                }
                return null;
            }

            /**
             * Classify procedure type
             */
            classifyProcedure(procedureText) {
                if (/clip|coil|embolization|aneurysm|vascular/.test(procedureText)) {
                    return 'vascular';
                } else if (/resection|craniotomy|tumor|mass/.test(procedureText)) {
                    return 'tumor';
                } else if (/fusion|laminectomy|discectomy|decompress/.test(procedureText)) {
                    return 'degenerative';
                } else if (/evacuation|hematoma|hemorrhage/.test(procedureText)) {
                    return 'trauma';
                }
                return null;
            }

            /**
             * Parse date string to Date object
             */
            parseDate(dateStr) {
                if (!dateStr) return null;
                const parsed = new Date(dateStr);
                return isNaN(parsed.getTime()) ? null : parsed;
            }

            /**
             * Calculate consistency score
             */
            calculateConsistencyScore(errorCount, warningCount) {
                let score = 100;
                score -= errorCount * 20;   // -20 per error
                score -= warningCount * 5;  // -5 per warning
                return Math.max(0, Math.min(100, score));
            }

            /**
             * Helper: Get field value by path
             */
            getFieldValue(data, path) {
                const field = this.getFieldByPath(data, path);
                return field?.value ?? null;
            }

            /**
             * Helper: Get field by path
             */
            getFieldByPath(data, path) {
                const parts = path.split('.');
                let current = data;

                for (const part of parts) {
                    if (!current || typeof current !== 'object') {
                        return null;
                    }
                    current = current[part];
                }

                return current;
            }

            /**
             * Helper: Get all field values from section
             */
            getAllFieldValues(data, sectionPath) {
                const section = this.getFieldByPath(data, sectionPath);
                if (!section) return [];

                const values = [];
                this.traverseSection(section, (field) => {
                    if (field.value) {
                        values.push(String(field.value));
                    }
                });

                return values;
            }

            /**
             * Helper: Get all source quotes from section
             */
            getAllSourceQuotes(section) {
                const quotes = [];
                this.traverseSection(section, (field) => {
                    if (field.sourceQuote) {
                        quotes.push(field.sourceQuote);
                    }
                });
                return quotes.join(' ');
            }

            /**
             * Helper: Traverse section
             */
            traverseSection(section, callback) {
                if (!section || typeof section !== 'object') {
                    return;
                }

                for (const value of Object.values(section)) {
                    if (value && typeof value === 'object') {
                        if (value.hasOwnProperty('value') && value.hasOwnProperty('sourceQuote')) {
                            callback(value);
                        } else {
                            this.traverseSection(value, callback);
                        }
                    }
                }
            }

            /**
             * Get last validation result
             */
            getLastValidation() {
                return this.lastValidation;
            }
        }

        console.log('‚úÖ ConsistencyValidator loaded');

        // ============================================================
        // SECTION 12: PROPORTIONALITY VALIDATOR
        // ============================================================

        /**
         * ProportionalityValidator Class
         * Dynamic output sizing validation based on data richness
         * CRITICAL: Ensures output length matches data density (no padding in sparse cases)
         * Ported from NeuroScribe V8
         */
        class ProportionalityValidator {
            constructor(apiClient) {
                this.apiClient = apiClient;
                this.lastValidation = null;
            }

            /**
             * Validate output proportionality
             * @param {string} generatedOutput - Generated text
             * @param {object} extractedData - Source extraction data
             * @param {string} outputType - 'ultrathink', 'doap', 'narrative'
             * @param {object} options - Validation options
             * @returns {Promise<object>} - Validation result
             */
            async validate(generatedOutput, extractedData, outputType, options = {}) {
                if (!generatedOutput || !extractedData || !outputType) {
                    throw new Error('Generated output, extracted data, and output type are required');
                }

                console.log(`üîç [Proportionality] Starting validation (${outputType})...`);

                try {
                    const warnings = [];
                    const errors = [];

                    // Analyze data richness
                    const dataAnalysis = this.analyzeDataRichness(extractedData);
                    console.log(`   [Proportionality] Data richness: ${dataAnalysis.richness} (${dataAnalysis.totalFacts} facts)`);

                    // Defensive check: Warn if 0 facts found (indicates structure mismatch)
                    if (dataAnalysis.totalFacts === 0) {
                        console.warn('‚ö†Ô∏è [Proportionality] extractedData contains 0 facts - may indicate structure mismatch');
                        console.warn('   Expected structure: {section: {field: {value, sourceQuote}}}');
                        console.warn('   Received keys:', Object.keys(extractedData));
                        console.warn('   Sample data:', JSON.stringify(extractedData, null, 2).substring(0, 300));
                        warnings.push({
                            type: 'data_structure_warning',
                            message: 'extractedData contains 0 facts. This may indicate missing extraction step or incompatible data format.',
                            severity: 'WARNING'
                        });
                    }

                    // Calculate output metrics
                    const outputMetrics = this.calculateOutputMetrics(generatedOutput);
                    console.log(`   [Proportionality] Output length: ${outputMetrics.wordCount} words`);

                    // Get expected range
                    const expectedRange = this.getExpectedRange(outputType, dataAnalysis);
                    console.log(`   [Proportionality] Expected range: ${expectedRange.min}-${expectedRange.max} words`);

                    // Check if output is within expected range
                    const withinRange = outputMetrics.wordCount >= expectedRange.min &&
                                       outputMetrics.wordCount <= expectedRange.max;

                    if (!withinRange) {
                        if (outputMetrics.wordCount < expectedRange.min) {
                            warnings.push({
                                type: 'output_too_brief',
                                wordCount: outputMetrics.wordCount,
                                expectedMin: expectedRange.min,
                                expectedMax: expectedRange.max,
                                message: `Output too brief (${outputMetrics.wordCount} words) for ${dataAnalysis.richness} data. Expected ${expectedRange.min}-${expectedRange.max} words.`
                            });
                        } else {
                            if (dataAnalysis.richness === 'sparse') {
                                // Sparse data + verbose output = padding (ERROR)
                                errors.push({
                                    type: 'output_padding',
                                    wordCount: outputMetrics.wordCount,
                                    expectedMax: expectedRange.max,
                                    dataRichness: dataAnalysis.richness,
                                    message: `Output too verbose (${outputMetrics.wordCount} words) for sparse data (${dataAnalysis.totalFacts} facts). Expected ‚â§${expectedRange.max} words. Possible padding.`,
                                    severity: 'HIGH'
                                });
                            } else {
                                warnings.push({
                                    type: 'output_too_verbose',
                                    wordCount: outputMetrics.wordCount,
                                    expectedMax: expectedRange.max,
                                    message: `Output verbose (${outputMetrics.wordCount} words). Expected ‚â§${expectedRange.max} words.`
                                });
                            }
                        }
                    }

                    // Check information density
                    const densityCheck = this.checkInformationDensity(
                        outputMetrics,
                        dataAnalysis,
                        outputType
                    );

                    if (!densityCheck.adequate) {
                        if (densityCheck.density < densityCheck.expectedMin) {
                            errors.push({
                                type: 'low_information_density',
                                density: densityCheck.density.toFixed(2),
                                expectedMin: densityCheck.expectedMin,
                                message: `Low information density (${densityCheck.density.toFixed(2)} facts/100 words). Expected ‚â•${densityCheck.expectedMin}. Possible padding.`,
                                severity: 'MEDIUM'
                            });
                        }
                    }

                    // Check for repetition
                    const repetitionCheck = this.checkRepetition(generatedOutput);
                    if (repetitionCheck.hasRepetition) {
                        warnings.push({
                            type: 'content_repetition',
                            repetitionScore: repetitionCheck.score,
                            examples: repetitionCheck.examples.slice(0, 3),
                            message: `Content repetition detected (score: ${repetitionCheck.score.toFixed(2)}). May indicate padding.`
                        });
                    }

                    // Check section balance (for narratives)
                    if (outputType === 'narrative') {
                        const balanceCheck = this.checkSectionBalance(generatedOutput, dataAnalysis);
                        balanceCheck.imbalances.forEach(imbalance => {
                            warnings.push({
                                type: 'section_imbalance',
                                ...imbalance
                            });
                        });
                    }

                    // Calculate proportionality score
                    const proportionalityScore = this.calculateProportionalityScore(
                        outputMetrics,
                        dataAnalysis,
                        expectedRange,
                        densityCheck,
                        repetitionCheck
                    );

                    console.log(`   [Proportionality] Score: ${proportionalityScore}/100`);
                    console.log(`   [Proportionality] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastValidation = {
                        passed: errors.length === 0,
                        errors: errors,
                        warnings: warnings,
                        proportionalityScore: proportionalityScore,
                        dataAnalysis: dataAnalysis,
                        outputMetrics: outputMetrics,
                        expectedRange: expectedRange,
                        densityCheck: densityCheck,
                        validatedAt: new Date().toISOString()
                    };

                    console.log(errors.length === 0 ? '‚úÖ [Proportionality] Passed' : '‚ùå [Proportionality] Issues detected');

                    return {
                        success: true,
                        validation: this.lastValidation,
                        metadata: {
                            outputType: outputType,
                            wordCount: outputMetrics.wordCount,
                            dataRichness: dataAnalysis.richness,
                            proportionalityScore: proportionalityScore
                        }
                    };

                } catch (error) {
                    console.error('‚ùå [Proportionality] Validation error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        metadata: null
                    };
                }
            }

            /**
             * Analyze data richness from extraction
             */
            analyzeDataRichness(data) {
                const analysis = {
                    totalFacts: 0,
                    sectionsPopulated: [],
                    sectionFactCounts: {},
                    richness: 'sparse',
                    criticalFactsPresent: 0
                };

                // Count facts in each section
                const topLevelSections = ['demographics', 'symptoms', 'examination', 'imaging',
                                           'pathology', 'procedures', 'medications', 'outcomes', 'timeline'];

                topLevelSections.forEach(section => {
                    if (data[section]) {
                        const factCount = this.countFacts(data[section]);
                        if (factCount > 0) {
                            analysis.sectionsPopulated.push(section);
                            analysis.sectionFactCounts[section] = factCount;
                            analysis.totalFacts += factCount;
                        }
                    }
                });

                // Check critical facts
                const criticalFields = [
                    'demographics.age',
                    'pathology.primaryDiagnosis.name'
                ];

                criticalFields.forEach(field => {
                    if (this.hasValue(data, field)) {
                        analysis.criticalFactsPresent++;
                    }
                });

                // Classify richness
                if (analysis.totalFacts < 10) {
                    analysis.richness = 'sparse';
                } else if (analysis.totalFacts < 25) {
                    analysis.richness = 'moderate';
                } else if (analysis.totalFacts < 50) {
                    analysis.richness = 'rich';
                } else {
                    analysis.richness = 'very_rich';
                }

                return analysis;
            }

            /**
             * Count facts in section
             */
            countFacts(section, count = 0, path = '', depth = 0) {
                if (!section || typeof section !== 'object') {
                    return count;
                }

                // Prevent infinite recursion
                if (depth > 10) {
                    console.warn(`   [Proportionality] Max recursion depth reached at path: ${path}`);
                    return count;
                }

                for (const [key, value] of Object.entries(section)) {
                    const currentPath = path ? `${path}.${key}` : key;

                    if (value && typeof value === 'object') {
                        if (value.hasOwnProperty('value') && value.hasOwnProperty('sourceQuote')) {
                            if (value.value !== null && value.value !== undefined && value.value !== '') {
                                count++;
                                // Log discovered facts for debugging
                                const valueStr = String(value.value).substring(0, 50);
                                console.log(`   [Proportionality] Found fact at ${currentPath}: "${valueStr}${valueStr.length >= 50 ? '...' : ''}"`);
                            }
                        } else {
                            count = this.countFacts(value, count, currentPath, depth + 1);
                        }
                    }
                }

                return count;
            }

            /**
             * Check if field has value
             */
            hasValue(data, path) {
                const parts = path.split('.');
                let current = data;

                for (const part of parts) {
                    if (!current || typeof current !== 'object') {
                        return false;
                    }
                    current = current[part];
                }

                if (current && typeof current === 'object' && current.value) {
                    return current.value !== null && current.value !== undefined && current.value !== '';
                }

                return false;
            }

            /**
             * Calculate output metrics
             */
            calculateOutputMetrics(output) {
                const words = output.split(/\s+/).filter(w => w.length > 0);
                const sentences = output.split(/[.!?]+/).filter(s => s.trim().length > 0);

                return {
                    wordCount: words.length,
                    sentenceCount: sentences.length,
                    averageSentenceLength: sentences.length > 0 ? words.length / sentences.length : 0,
                    characterCount: output.length
                };
            }

            /**
             * Get expected word range
             */
            getExpectedRange(outputType, dataAnalysis) {
                const ranges = {
                    ultrathink: {
                        sparse: { min: 25, max: 40 },
                        moderate: { min: 35, max: 50 },
                        rich: { min: 40, max: 50 },
                        very_rich: { min: 45, max: 50 }
                    },
                    doap: {
                        sparse: { min: 50, max: 100 },
                        moderate: { min: 80, max: 150 },
                        rich: { min: 120, max: 180 },
                        very_rich: { min: 150, max: 200 }
                    },
                    narrative: {
                        sparse: { min: 100, max: 300 },
                        moderate: { min: 400, max: 800 },
                        rich: { min: 1000, max: 2000 },
                        very_rich: { min: 1500, max: 3000 }
                    }
                };

                const typeRanges = ranges[outputType] || ranges.narrative;
                return typeRanges[dataAnalysis.richness] || typeRanges.moderate;
            }

            /**
             * Check information density
             */
            checkInformationDensity(outputMetrics, dataAnalysis, outputType) {
                const actualDensity = outputMetrics.wordCount > 0
                    ? (dataAnalysis.totalFacts / outputMetrics.wordCount) * 100
                    : 0;

                const expectedMinDensity = {
                    ultrathink: 8,   // ~8 facts per 100 words
                    doap: 5,         // ~5 facts per 100 words
                    narrative: 2     // ~2 facts per 100 words
                };

                const minDensity = expectedMinDensity[outputType] || 2;

                return {
                    density: actualDensity,
                    expectedMin: minDensity,
                    adequate: actualDensity >= minDensity
                };
            }

            /**
             * Check for content repetition
             */
            checkRepetition(output) {
                const sentences = output.split(/[.!?]+/).map(s => s.trim().toLowerCase()).filter(s => s.length > 10);

                if (sentences.length < 2) {
                    return { hasRepetition: false, score: 0, examples: [] };
                }

                let repetitionCount = 0;
                const repetitions = [];

                // Check for similar sentences (>70% word overlap)
                for (let i = 0; i < sentences.length; i++) {
                    for (let j = i + 1; j < sentences.length; j++) {
                        const similarity = this.calculateSentenceSimilarity(sentences[i], sentences[j]);
                        if (similarity > 0.7) {
                            repetitionCount++;
                            repetitions.push({
                                sentence1: sentences[i].substring(0, 100),
                                sentence2: sentences[j].substring(0, 100),
                                similarity: similarity.toFixed(2)
                            });
                        }
                    }
                }

                const repetitionScore = sentences.length > 0 ? repetitionCount / sentences.length : 0;

                return {
                    hasRepetition: repetitionScore > 0.1,
                    score: repetitionScore,
                    examples: repetitions
                };
            }

            /**
             * Calculate sentence similarity (Jaccard coefficient)
             */
            calculateSentenceSimilarity(sent1, sent2) {
                const words1 = new Set(sent1.split(/\s+/));
                const words2 = new Set(sent2.split(/\s+/));

                const intersection = new Set([...words1].filter(w => words2.has(w)));
                const union = new Set([...words1, ...words2]);

                return union.size > 0 ? intersection.size / union.size : 0;
            }

            /**
             * Check section balance
             */
            checkSectionBalance(output, dataAnalysis) {
                const imbalances = [];
                const outputLower = output.toLowerCase();

                dataAnalysis.sectionsPopulated.forEach(section => {
                    const factCount = dataAnalysis.sectionFactCounts[section];
                    const sectionKeywords = this.getSectionKeywords(section);
                    const mentioned = sectionKeywords.some(keyword => outputLower.includes(keyword));

                    if (!mentioned && factCount > 2) {
                        imbalances.push({
                            section: section,
                            factCount: factCount,
                            message: `Section "${section}" has ${factCount} facts but is not covered in narrative`
                        });
                    }
                });

                return { imbalances };
            }

            /**
             * Get section keywords
             */
            getSectionKeywords(section) {
                const keywords = {
                    demographics: ['age', 'patient', 'year old'],
                    symptoms: ['presents', 'symptoms', 'complains'],
                    examination: ['exam', 'examination', 'neurological'],
                    imaging: ['imaging', 'mri', 'ct', 'scan'],
                    pathology: ['diagnosis', 'pathology'],
                    procedures: ['surgery', 'procedure', 'operation'],
                    medications: ['medication', 'drug'],
                    outcomes: ['outcome', 'discharge', 'functional'],
                    timeline: ['admission', 'discharge', 'hospital']
                };

                return keywords[section] || [section];
            }

            /**
             * Calculate proportionality score
             */
            calculateProportionalityScore(outputMetrics, dataAnalysis, expectedRange, densityCheck, repetitionCheck) {
                let score = 100;

                // Factor 1: Length appropriateness (40 points)
                const withinRange = outputMetrics.wordCount >= expectedRange.min &&
                                   outputMetrics.wordCount <= expectedRange.max;

                if (withinRange) {
                    score += 0;
                } else if (outputMetrics.wordCount < expectedRange.min) {
                    const shortfall = (expectedRange.min - outputMetrics.wordCount) / expectedRange.min;
                    score -= Math.min(20, shortfall * 40);
                } else {
                    const excess = (outputMetrics.wordCount - expectedRange.max) / expectedRange.max;
                    score -= Math.min(40, excess * 60);
                }

                // Factor 2: Information density (30 points)
                if (densityCheck.adequate) {
                    score += 0;
                } else {
                    const densityShortfall = (densityCheck.expectedMin - densityCheck.density) / densityCheck.expectedMin;
                    score -= Math.min(30, densityShortfall * 30);
                }

                // Factor 3: Repetition (20 points)
                if (repetitionCheck.hasRepetition) {
                    score -= Math.min(20, repetitionCheck.score * 100);
                }

                return Math.max(0, Math.min(100, Math.round(score)));
            }

            /**
             * Get last validation result
             */
            getLastValidation() {
                return this.lastValidation;
            }

            /**
             * Get data richness analysis
             */
            getDataAnalysis() {
                if (!this.lastValidation) {
                    return null;
                }
                return this.lastValidation.dataAnalysis;
            }
        }

        console.log('‚úÖ ProportionalityValidator loaded');

        // ==================================================================================
        // SECTION 13: CONFIDENCE CALIBRATOR
        // ==================================================================================
        // Re-calibrates AI-reported confidence scores based on validation results
        // CRITICAL: Ensures confidence scores accurately reflect data quality
        //
        // Key Features:
        // - Grounding-based calibration (quote quality adjustments)
        // - Fabrication-based calibration (reduces confidence for related fields)
        // - Consistency-based calibration (penalizes inconsistent data)
        // - Completeness-based calibration (overall reduction for low completeness)
        // - Inference constraint validation (inferred fields must be <0.8)
        // - Over-confidence detection (flags high confidence despite validation issues)
        //
        // Ported from: /Users/ramihatoum/Downloads/neuroscribe-v8/src/validation/confidence-calibrator.js
        // ==================================================================================

        /**
         * Confidence Calibrator
         * Adjusts extraction confidence scores based on validation findings
         */
        class ConfidenceCalibrator {
            constructor(apiClient) {
                this.apiClient = apiClient;
                this.lastCalibration = null;
            }

            /**
             * Calibrate confidence scores
             * @param {object} extractedData - Extraction with confidence scores
             * @param {object} validationResults - Results from validators
             * @param {object} options - Calibration options
             * @returns {Promise<object>} - Calibration result with adjusted confidences
             */
            async calibrate(extractedData, validationResults, options = {}) {
                if (!extractedData || !validationResults) {
                    throw new Error('Extracted data and validation results are required');
                }

                console.log('üîç [Confidence] Starting confidence calibration...');

                try {
                    const warnings = [];
                    const errors = [];
                    const adjustments = [];

                    // Create calibrated copy of extraction data
                    const calibratedData = JSON.parse(JSON.stringify(extractedData));

                    // 1. Apply grounding-based adjustments
                    if (validationResults.grounding) {
                        console.log('   [Confidence] Applying grounding-based calibration...');
                        const groundingAdjustments = this.applyGroundingCalibration(
                            calibratedData,
                            validationResults.grounding
                        );
                        adjustments.push(...groundingAdjustments);
                    }

                    // 2. Apply fabrication-based adjustments
                    if (validationResults.fabrication) {
                        console.log('   [Confidence] Applying fabrication-based calibration...');
                        const fabricationAdjustments = this.applyFabricationCalibration(
                            calibratedData,
                            validationResults.fabrication
                        );
                        adjustments.push(...fabricationAdjustments);
                    }

                    // 3. Apply consistency-based adjustments
                    if (validationResults.consistency) {
                        console.log('   [Confidence] Applying consistency-based calibration...');
                        const consistencyAdjustments = this.applyConsistencyCalibration(
                            calibratedData,
                            validationResults.consistency
                        );
                        adjustments.push(...consistencyAdjustments);
                    }

                    // 4. Apply completeness-based adjustments
                    if (validationResults.completeness) {
                        console.log('   [Confidence] Applying completeness-based calibration...');
                        const completenessAdjustments = this.applyCompletenessCalibration(
                            calibratedData,
                            validationResults.completeness
                        );
                        adjustments.push(...completenessAdjustments);
                    }

                    // 5. Validate inference constraints (inferred fields must have confidence <0.8)
                    console.log('   [Confidence] Validating inference constraints...');
                    const inferenceViolations = this.validateInferenceConstraints(calibratedData);
                    inferenceViolations.forEach(violation => {
                        errors.push({
                            type: 'inference_constraint_violation',
                            ...violation,
                            severity: 'HIGH'
                        });
                    });

                    // 6. Check for over-confident extractions
                    console.log('   [Confidence] Checking for over-confidence...');
                    const overconfidentFields = this.detectOverconfidence(calibratedData, validationResults);
                    overconfidentFields.forEach(field => {
                        warnings.push({
                            type: 'overconfident_extraction',
                            ...field
                        });
                    });

                    // Calculate calibration metrics
                    const metrics = this.calculateCalibrationMetrics(
                        extractedData,
                        calibratedData,
                        adjustments
                    );

                    console.log(`   [Confidence] Total adjustments: ${adjustments.length}`);
                    console.log(`   [Confidence] Average confidence change: ${metrics.averageChange.toFixed(3)}`);
                    console.log(`   [Confidence] Errors: ${errors.length}, Warnings: ${warnings.length}`);

                    // Store result
                    this.lastCalibration = {
                        valid: errors.length === 0,
                        errors: errors,
                        warnings: warnings,
                        calibratedData: calibratedData,
                        adjustments: adjustments,
                        metrics: metrics,
                        calibratedAt: new Date().toISOString()
                    };

                    console.log(errors.length === 0 ? '‚úÖ [Confidence] Calibration complete' : '‚ùå [Confidence] Issues detected');

                    return {
                        success: true,
                        validation: this.lastCalibration,
                        calibratedData: calibratedData,
                        metadata: {
                            adjustmentCount: adjustments.length,
                            averageChange: metrics.averageChange,
                            fieldsAdjusted: metrics.fieldsAdjusted
                        }
                    };

                } catch (error) {
                    console.error('‚ùå [Confidence] Calibration error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        calibratedData: null,
                        metadata: null
                    };
                }
            }

            /**
             * Apply grounding-based confidence adjustments
             */
            applyGroundingCalibration(data, groundingValidation) {
                const adjustments = [];

                if (!groundingValidation.fieldValidations) {
                    return adjustments;
                }

                // Traverse data and adjust based on grounding quality
                this.traverseAndAdjust(data, '', (path, field, parent, key) => {
                    // Find corresponding grounding validation
                    const validation = groundingValidation.fieldValidations.find(v => v.path === path);

                    if (!validation) {
                        return;
                    }

                    const originalConfidence = field.confidence;
                    let adjustedConfidence = originalConfidence;
                    const reasons = [];

                    // Adjust based on quote quality
                    switch (validation.quoteQuality) {
                        case 'EXCELLENT':
                            // No adjustment needed
                            break;

                        case 'GOOD':
                            // Minor adjustment down
                            adjustedConfidence = Math.min(adjustedConfidence, 0.95);
                            reasons.push('Good grounding (capped at 0.95)');
                            break;

                        case 'ACCEPTABLE':
                            // Moderate adjustment down
                            adjustedConfidence = Math.min(adjustedConfidence, 0.85);
                            reasons.push('Acceptable grounding (capped at 0.85)');
                            break;

                        case 'POOR':
                            // Significant adjustment down
                            adjustedConfidence = Math.min(adjustedConfidence, 0.60);
                            reasons.push('Poor grounding quality (capped at 0.60)');
                            break;

                        case 'VERY_POOR':
                            // Severe adjustment
                            adjustedConfidence = Math.min(adjustedConfidence, 0.40);
                            reasons.push('Very poor grounding (capped at 0.40)');
                            break;

                        case 'NONE':
                            // No grounding = very low confidence
                            adjustedConfidence = 0.20;
                            reasons.push('No grounding (set to 0.20)');
                            break;
                    }

                    // Additional adjustment if quote doesn't exist in text
                    if (!validation.quoteExists && validation.sourceQuote) {
                        adjustedConfidence = Math.min(adjustedConfidence, 0.30);
                        reasons.push('Source quote not found in text');
                    }

                    // Apply adjustment
                    if (Math.abs(adjustedConfidence - originalConfidence) > 0.01) {
                        field.confidence = parseFloat(adjustedConfidence.toFixed(3));

                        adjustments.push({
                            path: path,
                            originalConfidence: originalConfidence,
                            adjustedConfidence: adjustedConfidence,
                            change: adjustedConfidence - originalConfidence,
                            reasons: reasons,
                            source: 'grounding'
                        });
                    }
                });

                return adjustments;
            }

            /**
             * Apply fabrication-based confidence adjustments
             */
            applyFabricationCalibration(data, fabricationValidation) {
                const adjustments = [];

                if (!fabricationValidation.fabrications || fabricationValidation.fabrications.length === 0) {
                    return adjustments;
                }

                // For each fabrication, find and adjust related fields
                fabricationValidation.fabrications.forEach(fab => {
                    // Extract key terms from fabricated statement
                    const keyTerms = this.extractKeyTerms(fab.statement);

                    // Find fields that might be related to this fabrication
                    this.traverseAndAdjust(data, '', (path, field) => {
                        const fieldText = `${field.value} ${field.sourceQuote}`.toLowerCase();

                        // Check if this field is related to the fabrication
                        const related = keyTerms.some(term => fieldText.includes(term.toLowerCase()));

                        if (related) {
                            const originalConfidence = field.confidence;

                            // Reduce confidence based on fabrication confidence
                            const reduction = fab.confidence * 0.5; // Reduce by up to 50%
                            const adjustedConfidence = Math.max(0.10, originalConfidence * (1 - reduction));

                            if (Math.abs(adjustedConfidence - originalConfidence) > 0.01) {
                                field.confidence = parseFloat(adjustedConfidence.toFixed(3));

                                adjustments.push({
                                    path: path,
                                    originalConfidence: originalConfidence,
                                    adjustedConfidence: adjustedConfidence,
                                    change: adjustedConfidence - originalConfidence,
                                    reasons: [`Related to fabricated content: "${fab.statement.substring(0, 50)}..."`],
                                    source: 'fabrication'
                                });
                            }
                        }
                    });
                });

                return adjustments;
            }

            /**
             * Apply consistency-based confidence adjustments
             */
            applyConsistencyCalibration(data, consistencyValidation) {
                const adjustments = [];

                if (!consistencyValidation.errors || consistencyValidation.errors.length === 0) {
                    return adjustments;
                }

                // For each consistency error, reduce confidence of involved fields
                consistencyValidation.errors.forEach(error => {
                    if (error.field1) {
                        this.adjustFieldConfidence(data, error.field1, 0.5, `Consistency issue: ${error.message}`, adjustments);
                    }
                    if (error.field2) {
                        this.adjustFieldConfidence(data, error.field2, 0.5, `Consistency issue: ${error.message}`, adjustments);
                    }
                    if (error.field && !error.field1) {
                        this.adjustFieldConfidence(data, error.field, 0.5, `Consistency issue: ${error.message}`, adjustments);
                    }
                });

                return adjustments;
            }

            /**
             * Apply completeness-based confidence adjustments
             */
            applyCompletenessCalibration(data, completenessValidation) {
                const adjustments = [];

                // If overall completeness is low, reduce all confidences slightly
                if (completenessValidation.scores && completenessValidation.scores.overall < 70) {
                    const reductionFactor = 0.9; // 10% reduction

                    this.traverseAndAdjust(data, '', (path, field) => {
                        const originalConfidence = field.confidence;
                        const adjustedConfidence = originalConfidence * reductionFactor;

                        if (Math.abs(adjustedConfidence - originalConfidence) > 0.01) {
                            field.confidence = parseFloat(adjustedConfidence.toFixed(3));

                            adjustments.push({
                                path: path,
                                originalConfidence: originalConfidence,
                                adjustedConfidence: adjustedConfidence,
                                change: adjustedConfidence - originalConfidence,
                                reasons: [`Low overall completeness (${completenessValidation.scores.overall}%)`],
                                source: 'completeness'
                            });
                        }
                    });
                }

                return adjustments;
            }

            /**
             * Adjust specific field confidence by path
             */
            adjustFieldConfidence(data, fieldPath, reductionFactor, reason, adjustments) {
                this.traverseAndAdjust(data, '', (path, field) => {
                    if (path === fieldPath || path.includes(fieldPath)) {
                        const originalConfidence = field.confidence;
                        const adjustedConfidence = originalConfidence * reductionFactor;

                        if (Math.abs(adjustedConfidence - originalConfidence) > 0.01) {
                            field.confidence = parseFloat(adjustedConfidence.toFixed(3));

                            adjustments.push({
                                path: path,
                                originalConfidence: originalConfidence,
                                adjustedConfidence: adjustedConfidence,
                                change: adjustedConfidence - originalConfidence,
                                reasons: [reason],
                                source: 'consistency'
                            });
                        }
                    }
                });
            }

            /**
             * Validate inference constraints (inferred fields < 0.8 confidence)
             */
            validateInferenceConstraints(data) {
                const violations = [];

                this.traverseAndAdjust(data, '', (path, field) => {
                    // Check if field is inferred
                    if (field.deductionMetadata && field.deductionMetadata.deduced) {
                        if (field.confidence >= 0.8) {
                            violations.push({
                                field: path,
                                confidence: field.confidence,
                                deductionMethod: field.deductionMetadata.deducedFrom,
                                message: `Inferred field has confidence ‚â•0.8 (${field.confidence}), must be <0.8`
                            });

                            // Auto-correct
                            field.confidence = 0.79;
                        }
                    }
                });

                return violations;
            }

            /**
             * Detect over-confident extractions
             */
            detectOverconfidence(data, validationResults) {
                const overconfident = [];

                // If validation failed but field has high confidence, flag it
                const hasIssues = (validationResults.grounding && !validationResults.grounding.valid) ||
                                 (validationResults.consistency && !validationResults.consistency.valid) ||
                                 (validationResults.completeness && !validationResults.completeness.valid);

                if (hasIssues) {
                    this.traverseAndAdjust(data, '', (path, field) => {
                        if (field.confidence >= 0.95) {
                            overconfident.push({
                                field: path,
                                confidence: field.confidence,
                                message: `Very high confidence (${field.confidence}) despite validation issues`
                            });
                        }
                    });
                }

                return overconfident;
            }

            /**
             * Extract key terms from statement
             */
            extractKeyTerms(statement) {
                return statement
                    .toLowerCase()
                    .split(/\s+/)
                    .filter(word => word.length > 4 && !/^(the|and|with|for|from|that|this)$/.test(word))
                    .slice(0, 5); // Top 5 key terms
            }

            /**
             * Traverse data and apply adjustment callback
             */
            traverseAndAdjust(data, path = '', callback) {
                if (!data || typeof data !== 'object') {
                    return;
                }

                for (const [key, value] of Object.entries(data)) {
                    if (value === null || value === undefined) {
                        continue;
                    }

                    const currentPath = path ? `${path}.${key}` : key;

                    // Check if this is a grounded field
                    if (typeof value === 'object' &&
                        value.hasOwnProperty('value') &&
                        value.hasOwnProperty('sourceQuote') &&
                        value.hasOwnProperty('confidence')) {

                        callback(currentPath, value, data, key);

                    } else if (typeof value === 'object' && !Array.isArray(value)) {
                        // Recurse into nested objects
                        this.traverseAndAdjust(value, currentPath, callback);

                    } else if (Array.isArray(value)) {
                        // Recurse into arrays
                        value.forEach((item, index) => {
                            this.traverseAndAdjust(item, `${currentPath}[${index}]`, callback);
                        });
                    }
                }
            }

            /**
             * Calculate calibration metrics
             */
            calculateCalibrationMetrics(originalData, calibratedData, adjustments) {
                const metrics = {
                    fieldsAdjusted: adjustments.length,
                    averageChange: 0,
                    totalChangeSum: 0,
                    maxIncrease: 0,
                    maxDecrease: 0,
                    adjustmentsBySource: {}
                };

                if (adjustments.length === 0) {
                    return metrics;
                }

                // Calculate average change
                metrics.totalChangeSum = adjustments.reduce((sum, adj) => sum + adj.change, 0);
                metrics.averageChange = metrics.totalChangeSum / adjustments.length;

                // Find max changes
                adjustments.forEach(adj => {
                    if (adj.change > metrics.maxIncrease) {
                        metrics.maxIncrease = adj.change;
                    }
                    if (adj.change < metrics.maxDecrease) {
                        metrics.maxDecrease = adj.change;
                    }

                    // Count by source
                    metrics.adjustmentsBySource[adj.source] = (metrics.adjustmentsBySource[adj.source] || 0) + 1;
                });

                return metrics;
            }

            /**
             * Get last calibration result
             */
            getLastCalibration() {
                return this.lastCalibration;
            }

            /**
             * Get calibrated data
             */
            getCalibratedData() {
                if (!this.lastCalibration) {
                    return null;
                }
                return this.lastCalibration.calibratedData;
            }

            /**
             * Get confidence adjustments
             */
            getAdjustments() {
                if (!this.lastCalibration) {
                    return [];
                }
                return this.lastCalibration.adjustments;
            }
        }

        console.log('‚úÖ ConfidenceCalibrator loaded');

        // ==================================================================================
        // üéâ ALL 6 VALIDATION LAYERS COMPLETE!
        // ==================================================================================
        // ‚úÖ 1. GroundingValidator - Source quote verification
        // ‚úÖ 2. FabricationDetector - AI hallucination detection
        // ‚úÖ 3. CompletenessChecker - Bidirectional extraction validation
        // ‚úÖ 4. ConsistencyValidator - Medical logic & anatomical consistency
        // ‚úÖ 5. ProportionalityValidator - Output sizing & padding detection
        // ‚úÖ 6. ConfidenceCalibrator - Score adjustment based on validation
        //
        // Total validation code: ~2,550 lines
        // Next: ValidationPipeline Orchestrator to coordinate all 6 layers
        // ==================================================================================

        console.log('‚úÖ All 6 validation classes loaded successfully');

        // ==================================================================================
        // SECTION 14: VALIDATION PIPELINE ORCHESTRATOR
        // ==================================================================================
        // Unified validator that orchestrates all 6 validation components
        // CRITICAL: Main validation interface for extraction and generation
        //
        // Validation Workflows:
        // 1. validateExtraction() - Pre-generation validation
        //    ‚Üí Grounding ‚Üí Completeness ‚Üí Consistency ‚Üí Calibration
        // 2. validateGeneration() - Post-generation validation
        //    ‚Üí Fabrication ‚Üí Proportionality
        // 3. validateComplete() - Full pipeline (extraction + all outputs)
        //    ‚Üí All validators + system quality score
        //
        // Ported from: /Users/ramihatoum/Downloads/neuroscribe-v8/src/validation/validator.js
        // ==================================================================================

        /**
         * Unified Validator
         * Comprehensive validation pipeline for extraction and generation
         */
        class ValidationPipeline {
            constructor(apiClient) {
                this.apiClient = apiClient;

                // Initialize all validators (instantiate directly, not via create functions)
                this.groundingValidator = new GroundingValidator(''); // Will receive source text per validation

                // V10.2.3 FIX #3: FabricationDetector with optional configuration
                // To disable term-based detection (eliminates false positives, uses only semantic AI):
                //   this.fabricationDetector = new FabricationDetector(apiClient, { enableTermBasedDetection: false });
                // Default (backward compatible): both term-based and semantic AI detection enabled
                this.fabricationDetector = new FabricationDetector(apiClient);
                // UNCOMMENT LINE BELOW to disable term-based detection:
                // this.fabricationDetector = new FabricationDetector(apiClient, { enableTermBasedDetection: false });

                // V10.2.4 PHASE 1.1: ULTRATHINK-specific detector with semantic-AI-only mode
                // ULTRATHINK requires highest precision - use only semantic AI to eliminate false positives
                // Term-based detection creates noise for ultra-compressed content
                this.ultrathinkFabricationDetector = new FabricationDetector(apiClient, {
                    enableTermBasedDetection: false
                });
                console.log('üéØ [V10.2.4] ULTRATHINK-specific fabrication detector initialized (semantic-AI-only mode)');

                this.completenessChecker = new CompletenessChecker(apiClient);
                this.consistencyValidator = new ConsistencyValidator(apiClient);
                this.proportionalityValidator = new ProportionalityValidator(apiClient);
                this.confidenceCalibrator = new ConfidenceCalibrator(apiClient);

                this.lastValidation = null;
            }

            /**
             * Validate extraction (pre-generation)
             * @param {object} extractedData - Extraction result
             * @param {string} originalText - Original clinical text
             * @param {object} options - Validation options
             * @returns {Promise<object>} - Comprehensive validation result
             */
            async validateExtraction(extractedData, originalText, options = {}) {
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('PHASE 4: EXTRACTION VALIDATION PIPELINE');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                try {
                    // V10.1 FIX: Check if extractedData is empty/null
                    const hasExtractedData = extractedData && typeof extractedData === 'object' && Object.keys(extractedData).length > 0;

                    if (!hasExtractedData) {
                        console.warn('‚ö†Ô∏è [Extraction Validation] No extractedData provided - skipping extraction-specific validations');
                        console.warn('   This is expected for direct transcript-to-note generation without structured extraction');
                        return {
                            success: true,
                            skipped: true,
                            reason: 'No extractedData available',
                            validation: {
                                scores: {
                                    overall: 100,  // Pass with full score since no extraction to validate
                                    grounding: 100,
                                    completeness: 100,
                                    consistency: 100
                                },
                                status: 'PASSED',
                                errors: [],
                                warnings: [{
                                    type: 'extraction_skipped',
                                    message: 'Extraction validation skipped - no extractedData provided',
                                    severity: 'INFO'
                                }]
                            },
                            calibratedData: null
                        };
                    }

                    const validationResults = {
                        grounding: null,
                        completeness: null,
                        consistency: null,
                        calibration: null
                    };

                    // Step 1: Grounding Validation
                    console.log('üìã Step 1: Grounding Validation');
                    console.log('‚îÄ'.repeat(60));

                    // Create grounding validator with source text
                    const groundingValidator = new GroundingValidator(originalText);
                    validationResults.grounding = await groundingValidator.validate(extractedData);

                    if (validationResults.grounding.success) {
                        console.log(`‚úÖ Grounding: ${validationResults.grounding.validation.scores.overall}/100`);
                    } else {
                        console.log(`‚ùå Grounding validation failed: ${validationResults.grounding.error}`);
                    }

                    // Step 2: Completeness Check
                    console.log('\nüìã Step 2: Completeness Check');
                    console.log('‚îÄ'.repeat(60));
                    validationResults.completeness = await this.completenessChecker.check(
                        extractedData,
                        originalText,
                        options
                    );

                    if (validationResults.completeness.success) {
                        console.log(`‚úÖ Completeness: ${validationResults.completeness.validation.scores.overall}/100`);
                    } else {
                        console.log(`‚ùå Completeness check failed: ${validationResults.completeness.error}`);
                    }

                    // Step 3: Consistency Validation
                    console.log('\nüìã Step 3: Consistency Validation');
                    console.log('‚îÄ'.repeat(60));
                    validationResults.consistency = await this.consistencyValidator.validate(
                        extractedData,
                        originalText,
                        options
                    );

                    if (validationResults.consistency.success) {
                        console.log(`‚úÖ Consistency: ${validationResults.consistency.validation.consistencyScore}/100`);
                    } else {
                        console.log(`‚ùå Consistency validation failed: ${validationResults.consistency.error}`);
                    }

                    // Step 4: Confidence Calibration
                    console.log('\nüìã Step 4: Confidence Calibration');
                    console.log('‚îÄ'.repeat(60));
                    validationResults.calibration = await this.confidenceCalibrator.calibrate(
                        extractedData,
                        {
                            grounding: validationResults.grounding?.validation,
                            completeness: validationResults.completeness?.validation,
                            consistency: validationResults.consistency?.validation
                        },
                        options
                    );

                    if (validationResults.calibration.success) {
                        console.log(`‚úÖ Calibration: ${validationResults.calibration.metadata.adjustmentCount} adjustments`);
                    } else {
                        console.log(`‚ùå Confidence calibration failed: ${validationResults.calibration.error}`);
                    }

                    // Aggregate results
                    const aggregated = this.aggregateExtractionValidation(validationResults);

                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log('EXTRACTION VALIDATION SUMMARY');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log(`Overall Quality Score: ${aggregated.overallScore}/100`);
                    console.log(`Status: ${aggregated.status}`);
                    console.log(`Critical Issues: ${aggregated.summary.criticalIssues}`);
                    console.log(`Warnings: ${aggregated.summary.warnings}`);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                    return {
                        success: true,
                        validation: aggregated,
                        calibratedData: validationResults.calibration?.calibratedData || extractedData
                    };

                } catch (error) {
                    console.error('‚ùå Extraction validation pipeline error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        calibratedData: extractedData
                    };
                }
            }

            /**
             * Validate generation (post-generation)
             * @param {string} generatedText - Generated output
             * @param {object} extractedData - Source extraction
             * @param {string} originalText - Original clinical text
             * @param {string} outputType - Type of output (ultrathink, doap, narrative)
             * @param {object} options - Validation options
             * @returns {Promise<object>} - Comprehensive validation result
             */
            async validateGeneration(generatedText, extractedData, originalText, outputType, options = {}) {
                console.log(`\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                console.log(`PHASE 4: ${outputType.toUpperCase()} VALIDATION PIPELINE`);
                console.log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);

                try {
                    const validationResults = {
                        fabrication: null,
                        proportionality: null
                    };

                    // Step 1: Fabrication Detection
                    console.log('üìã Step 1: Fabrication Detection');
                    console.log('‚îÄ'.repeat(60));

                    // V10.2.4 PHASE 1.1: Use ULTRATHINK-specific detector for ULTRATHINK validation
                    // ULTRATHINK uses semantic-AI-only mode (no term-based detection) for highest precision
                    const detectorToUse = outputType.toLowerCase() === 'ultrathink'
                        ? this.ultrathinkFabricationDetector
                        : this.fabricationDetector;

                    if (outputType.toLowerCase() === 'ultrathink') {
                        console.log('   üéØ [V10.2.4] Using ULTRATHINK-specific detector (semantic-AI-only, zero false positives)');
                    }

                    validationResults.fabrication = await detectorToUse.detect(
                        generatedText,
                        extractedData,
                        originalText,
                        options
                    );

                    if (validationResults.fabrication.success) {
                        console.log(`‚úÖ Fabrication: ${validationResults.fabrication.validation.fabricationScore}/100`);
                    } else {
                        console.log(`‚ùå Fabrication detection failed: ${validationResults.fabrication.error}`);
                    }

                    // Step 2: Proportionality Validation
                    console.log('\nüìã Step 2: Proportionality Validation');
                    console.log('‚îÄ'.repeat(60));
                    validationResults.proportionality = await this.proportionalityValidator.validate(
                        generatedText,
                        extractedData,
                        outputType,
                        options
                    );

                    if (validationResults.proportionality.success) {
                        console.log(`‚úÖ Proportionality: ${validationResults.proportionality.validation.proportionalityScore}/100`);
                    } else {
                        console.log(`‚ùå Proportionality validation failed: ${validationResults.proportionality.error}`);
                    }

                    // Aggregate results
                    const aggregated = this.aggregateGenerationValidation(validationResults, outputType);

                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log(`${outputType.toUpperCase()} VALIDATION SUMMARY`);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log(`Overall Quality Score: ${aggregated.overallScore}/100`);
                    console.log(`Status: ${aggregated.status}`);
                    console.log(`Critical Issues: ${aggregated.summary.criticalIssues}`);
                    console.log(`Warnings: ${aggregated.summary.warnings}`);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                    return {
                        success: true,
                        validation: aggregated
                    };

                } catch (error) {
                    console.error(`‚ùå ${outputType} validation pipeline error:`, error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null
                    };
                }
            }

            /**
             * Complete validation pipeline (extraction + all outputs)
             * @param {object} extractedData - Extraction result
             * @param {string} originalText - Original clinical text
             * @param {object} outputs - Generated outputs {ultrathink, doap, narrative}
             * @param {object} options - Validation options
             * @returns {Promise<object>} - Complete validation result
             */
            async validateComplete(extractedData, originalText, outputs = {}, options = {}) {
                console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                console.log('‚ïë        PHASE 4: COMPLETE VALIDATION PIPELINE         ‚ïë');
                console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

                try {
                    // 1. Validate extraction
                    const extractionValidation = await this.validateExtraction(
                        extractedData,
                        originalText,
                        options
                    );

                    // Use calibrated data for generation validation
                    const calibratedData = extractionValidation.calibratedData || extractedData;

                    // 2. Validate each output type
                    const outputValidations = {};

                    if (outputs.ultrathink) {
                        outputValidations.ultrathink = await this.validateGeneration(
                            outputs.ultrathink,
                            calibratedData,
                            originalText,
                            'ultrathink',
                            options
                        );
                    }

                    if (outputs.doap) {
                        outputValidations.doap = await this.validateGeneration(
                            outputs.doap,
                            calibratedData,
                            originalText,
                            'doap',
                            options
                        );
                    }

                    if (outputs.narrative) {
                        outputValidations.narrative = await this.validateGeneration(
                            outputs.narrative,
                            calibratedData,
                            originalText,
                            'narrative',
                            options
                        );
                    }

                    // 3. Aggregate complete validation
                    const completeValidation = this.aggregateCompleteValidation(
                        extractionValidation,
                        outputValidations
                    );

                    console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                    console.log('‚ïë           COMPLETE VALIDATION SUMMARY                ‚ïë');
                    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                    console.log(`\nüìä Overall System Quality: ${completeValidation.systemQualityScore}/100`);
                    console.log(`   Status: ${completeValidation.status}`);
                    console.log(`\nüìã Validation Breakdown:`);
                    console.log(`   Extraction Quality: ${completeValidation.extractionScore}/100`);
                    if (outputValidations.ultrathink) {
                        console.log(`   ULTRATHINK Quality: ${completeValidation.outputScores.ultrathink}/100`);
                    }
                    if (outputValidations.doap) {
                        console.log(`   DOAP Quality: ${completeValidation.outputScores.doap}/100`);
                    }
                    if (outputValidations.narrative) {
                        console.log(`   Narrative Quality: ${completeValidation.outputScores.narrative}/100`);
                    }
                    console.log(`\n‚ö†Ô∏è  Total Issues:`);
                    console.log(`   Critical: ${completeValidation.totalIssues.critical}`);
                    console.log(`   Warnings: ${completeValidation.totalIssues.warnings}`);
                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                    // Store complete validation
                    this.lastValidation = completeValidation;

                    return {
                        success: true,
                        validation: completeValidation,
                        calibratedData: calibratedData
                    };

                } catch (error) {
                    console.error('‚ùå Complete validation pipeline error:', error);
                    return {
                        success: false,
                        error: error.message,
                        validation: null,
                        calibratedData: extractedData
                    };
                }
            }

            /**
             * Aggregate extraction validation results
             */
            aggregateExtractionValidation(results) {
                const allErrors = [];
                const allWarnings = [];

                // Collect errors and warnings
                if (results.grounding?.validation) {
                    allErrors.push(...(results.grounding.validation.errors || []));
                    allWarnings.push(...(results.grounding.validation.warnings || []));
                }

                if (results.completeness?.validation) {
                    allErrors.push(...(results.completeness.validation.errors || []));
                    allWarnings.push(...(results.completeness.validation.warnings || []));
                }

                if (results.consistency?.validation) {
                    allErrors.push(...(results.consistency.validation.errors || []));
                    allWarnings.push(...(results.consistency.validation.warnings || []));
                }

                if (results.calibration?.validation) {
                    allErrors.push(...(results.calibration.validation.errors || []));
                    allWarnings.push(...(results.calibration.validation.warnings || []));
                }

                // Calculate overall score (weighted average)
                const groundingScore = results.grounding?.validation?.scores?.overall || 0;
                const completenessScore = results.completeness?.validation?.scores?.overall || 0;
                const consistencyScore = results.consistency?.validation?.consistencyScore || 0;

                const overallScore = Math.round(
                    groundingScore * 0.35 +      // 35% grounding weight
                    completenessScore * 0.35 +   // 35% completeness weight
                    consistencyScore * 0.30      // 30% consistency weight
                );

                // Determine status
                let status = 'EXCELLENT';
                if (allErrors.length > 0) {
                    status = 'FAILED';
                } else if (overallScore < 70) {
                    status = 'POOR';
                } else if (overallScore < 85) {
                    status = 'ACCEPTABLE';
                } else if (overallScore < 95) {
                    status = 'GOOD';
                }

                return {
                    valid: allErrors.length === 0,
                    status: status,
                    overallScore: overallScore,
                    scores: {
                        grounding: groundingScore,
                        completeness: completenessScore,
                        consistency: consistencyScore
                    },
                    errors: allErrors,
                    warnings: allWarnings,
                    summary: {
                        criticalIssues: allErrors.length,
                        warnings: allWarnings.length,
                        totalIssues: allErrors.length + allWarnings.length
                    },
                    detailedResults: results
                };
            }

            /**
             * Aggregate generation validation results
             */
            aggregateGenerationValidation(results, outputType) {
                const allErrors = [];
                const allWarnings = [];

                // Collect errors and warnings
                if (results.fabrication?.validation) {
                    allErrors.push(...(results.fabrication.validation.errors || []));
                    allWarnings.push(...(results.fabrication.validation.warnings || []));
                }

                if (results.proportionality?.validation) {
                    allErrors.push(...(results.proportionality.validation.errors || []));
                    allWarnings.push(...(results.proportionality.validation.warnings || []));
                }

                // Calculate overall score (weighted average)
                const fabricationScore = results.fabrication?.validation?.fabricationScore || 0;
                const proportionalityScore = results.proportionality?.validation?.proportionalityScore || 0;

                const overallScore = Math.round(
                    fabricationScore * 0.60 +        // Fabrication is more critical (60%)
                    proportionalityScore * 0.40      // Proportionality (40%)
                );

                // Determine status
                let status = 'EXCELLENT';
                if (allErrors.length > 0) {
                    status = 'FAILED';
                } else if (overallScore < 70) {
                    status = 'POOR';
                } else if (overallScore < 85) {
                    status = 'ACCEPTABLE';
                } else if (overallScore < 95) {
                    status = 'GOOD';
                }

                return {
                    valid: allErrors.length === 0,
                    status: status,
                    overallScore: overallScore,
                    outputType: outputType,
                    scores: {
                        fabrication: fabricationScore,
                        proportionality: proportionalityScore
                    },
                    errors: allErrors,
                    warnings: allWarnings,
                    summary: {
                        criticalIssues: allErrors.length,
                        warnings: allWarnings.length,
                        totalIssues: allErrors.length + allWarnings.length
                    },
                    detailedResults: results
                };
            }

            /**
             * Aggregate complete validation results
             */
            aggregateCompleteValidation(extractionValidation, outputValidations) {
                // Calculate system quality score
                const extractionScore = extractionValidation.validation?.overallScore || 0;
                const outputScores = {};

                let totalOutputScore = 0;
                let outputCount = 0;

                Object.entries(outputValidations).forEach(([type, validation]) => {
                    if (validation?.validation?.overallScore !== undefined) {
                        outputScores[type] = validation.validation.overallScore;
                        totalOutputScore += validation.validation.overallScore;
                        outputCount++;
                    }
                });

                const avgOutputScore = outputCount > 0 ? totalOutputScore / outputCount : 0;

                // System quality = 60% extraction + 40% outputs
                const systemQualityScore = Math.round(
                    extractionScore * 0.60 +
                    avgOutputScore * 0.40
                );

                // Aggregate all issues
                const totalIssues = {
                    critical: (extractionValidation.validation?.summary?.criticalIssues || 0),
                    warnings: (extractionValidation.validation?.summary?.warnings || 0)
                };

                Object.values(outputValidations).forEach(validation => {
                    if (validation?.validation?.summary) {
                        totalIssues.critical += validation.validation.summary.criticalIssues || 0;
                        totalIssues.warnings += validation.validation.summary.warnings || 0;
                    }
                });

                // Determine overall status
                let status = 'EXCELLENT';
                if (totalIssues.critical > 0) {
                    status = 'FAILED';
                } else if (systemQualityScore < 70) {
                    status = 'POOR';
                } else if (systemQualityScore < 85) {
                    status = 'ACCEPTABLE';
                } else if (systemQualityScore < 95) {
                    status = 'GOOD';
                }

                // V10.1 FIX #3: Extract and flatten individual layer scores for display
                const groundingScore = extractionValidation.validation?.scores?.overall ||
                                     extractionValidation.validation?.scores?.grounding || 0;
                const completenessScore = extractionValidation.validation?.scores?.completeness || 0;
                const consistencyScore = extractionValidation.validation?.consistencyScore ||
                                        extractionValidation.validation?.scores?.consistency || 0;

                const fabricationScore = outputValidations.ultrathink?.validation?.scores?.fabrication ||
                                        outputValidations.ultrathink?.validation?.fabricationScore || 0;
                const proportionalityScore = outputValidations.ultrathink?.validation?.scores?.proportionality ||
                                            outputValidations.ultrathink?.validation?.proportionalityScore || 0;

                // Extract detailed metadata for UI display
                const groundingCoverage = extractionValidation.validation?.groundingAnalysis?.groundedFields || 0;
                const quotesFound = extractionValidation.validation?.fieldValidations?.length || 0;
                const highConfidenceFabrications = outputValidations.ultrathink?.validation?.fabrications?.filter(f => f.confidence >= 0.7).length || 0;
                const extractionCoverage = extractionValidation.validation?.scores?.coverage || 0;
                const consistencyIssues = extractionValidation.validation?.errors?.filter(e => e.category === 'consistency').length || 0;
                const proportionalityRatio = outputValidations.ultrathink?.validation?.detailedResults?.proportionality?.validation?.expansionRatio || 0;

                return {
                    // V10.1 FIX #2: Add overallScore property (expected by display logic)
                    overallScore: systemQualityScore,
                    systemQualityScore: systemQualityScore,  // Keep for backward compatibility
                    status: status,
                    extractionScore: extractionScore,
                    outputScores: outputScores,
                    totalIssues: totalIssues,

                    // V10.1 FIX #3: Add flattened layer scores for UI display
                    grounding: {
                        score: groundingScore,
                        coverage: groundingCoverage,
                        quotesFound: quotesFound,
                        // V10.2.3 FIX #4: Include grounding errors for interactive resolution
                        errors: extractionValidation?.validation?.errors || []
                    },
                    fabrication: (function() {
                        const fabrications = outputValidations?.ultrathink?.validation?.detailedResults?.fabrication?.validation?.fabrications ||
                                           outputValidations?.doap?.validation?.detailedResults?.fabrication?.validation?.fabrications ||
                                           [];
                        // V10.2.3 FIX #5: Log fabrications array to verify data flow
                        console.log(`üîç [V10.2.3 DATA FLOW] Fabrications array in aggregation: ${fabrications.length} issues`);
                        if (fabrications.length > 0) {
                            console.log(`   ‚Üí Sample fabrication:`, {
                                statement: fabrications[0].statement?.substring(0, 50) + '...',
                                statementIndex: fabrications[0].statementIndex,
                                fixOptions: fabrications[0].fixOptions?.length || 0,
                                confidence: fabrications[0].confidence
                            });
                        }
                        return {
                            score: fabricationScore,
                            highConfidenceFabrications: highConfidenceFabrications,
                            // V10.2.3 FIX #1: Include fabrications array for interactive resolution with sentence-level tracking and multiple fix options
                            fabrications: fabrications
                        };
                    })(),
                    completeness: {
                        score: completenessScore,
                        extractionCoverage: extractionCoverage,
                        // V10.2.3 FIX #4: Include completeness warnings for interactive resolution
                        warnings: extractionValidation?.validation?.warnings || []
                    },
                    consistency: {
                        score: consistencyScore,
                        issuesFound: consistencyIssues,
                        // V10.2.3 FIX #4: Include consistency errors for interactive resolution
                        errors: extractionValidation?.validation?.errors || []
                    },
                    proportionality: {
                        score: proportionalityScore,
                        ratio: proportionalityRatio,
                        // V10.2.3 FIX #4: Include proportionality warnings for interactive resolution (already working via separate path)
                        warnings: outputValidations?.ultrathink?.validation?.warnings ||
                                 outputValidations?.doap?.validation?.warnings || []
                    },

                    // Keep nested structure for detailed analysis
                    extractionValidation: extractionValidation,
                    outputValidations: outputValidations,
                    timestamp: new Date().toISOString()
                };
            }

            /**
             * Get actionable feedback for regeneration
             */
            getRegenerationFeedback(validation) {
                const feedback = {
                    shouldRegenerate: false,
                    criticalIssues: [],
                    suggestions: []
                };

                if (!validation || validation.valid) {
                    return feedback;
                }

                // Determine if regeneration is needed
                if (validation.errors && validation.errors.length > 0) {
                    feedback.shouldRegenerate = true;

                    // Collect critical issues
                    validation.errors.forEach(error => {
                        feedback.criticalIssues.push({
                            type: error.type,
                            message: error.message,
                            severity: error.severity
                        });

                        // Generate suggestions
                        if (error.type === 'fabricated_content') {
                            feedback.suggestions.push('Remove unsupported statements and stay strictly within documented facts');
                        } else if (error.type === 'laterality_inconsistency') {
                            feedback.suggestions.push('Verify neuroanatomical laterality (cerebral lesions cause contralateral symptoms)');
                        } else if (error.type === 'output_padding') {
                            feedback.suggestions.push('Reduce output length to match sparse data - avoid padding or elaboration');
                        } else if (error.type === 'missing_critical_extraction') {
                            feedback.suggestions.push('Extract all critical clinical information mentioned in the notes');
                        } else if (error.type === 'score_inconsistency') {
                            feedback.suggestions.push('Verify clinical score calculations and ranges');
                        }
                    });

                    // Remove duplicate suggestions
                    feedback.suggestions = [...new Set(feedback.suggestions)];
                }

                return feedback;
            }

            /**
             * Get last validation result
             */
            getLastValidation() {
                return this.lastValidation;
            }

            /**
             * Get individual validator instances (for direct access)
             */
            getValidators() {
                return {
                    grounding: this.groundingValidator,
                    fabrication: this.fabricationDetector,
                    completeness: this.completenessChecker,
                    consistency: this.consistencyValidator,
                    proportionality: this.proportionalityValidator,
                    calibration: this.confidenceCalibrator
                };
            }
        }

        console.log('‚úÖ ValidationPipeline loaded');

        // ==================================================================================
        // üéâüéâüéâ VALIDATION ENGINE 100% COMPLETE! üéâüéâüéâ
        // ==================================================================================
        //
        // ‚úÖ ALL 6 VALIDATION LAYERS:
        //    1. GroundingValidator (375 lines) - Source quote verification
        //    2. FabricationDetector (474 lines) - AI hallucination detection
        //    3. CompletenessChecker (531 lines) - Bidirectional validation
        //    4. ConsistencyValidator (645 lines) - Medical logic validation
        //    5. ProportionalityValidator (489 lines) - Output sizing validation
        //    6. ConfidenceCalibrator (549 lines) - Score adjustment
        //
        // ‚úÖ ORCHESTRATOR:
        //    7. ValidationPipeline (592 lines) - Master coordinator
        //
        // üìä TOTAL VALIDATION CODE: ~3,655 lines
        // üèóÔ∏è  ARCHITECTURE: Browser-compatible, zero dependencies
        // ‚ö° FEATURES:
        //    - Extraction validation (4 layers)
        //    - Generation validation (2 layers)
        //    - Complete pipeline validation
        //    - Weighted scoring algorithms
        //    - Actionable regeneration feedback
        //
        // üéØ NEXT PHASE: Integrate with V7 generate() workflow
        // ==================================================================================

        console.log('üéâ VALIDATION ENGINE 100% COMPLETE!');

        // ============================================================
        // LAZY LOADING INFRASTRUCTURE FOR VALIDATION ENGINE
        // ============================================================
        /**
         * Lazy loading for validation pipeline - Performance optimization
         * Only instantiates the validation pipeline when first needed
         */
        let cachedValidationPipeline = null;
        let validationEngineInitialized = false;
        let validationInitStartTime = null;

        /**
         * Get or create validation pipeline instance (singleton pattern)
         * @param {Object} apiClient - API client for validation calls
         * @returns {ValidationPipeline} Cached or new validation pipeline instance
         */
        async function getValidationPipeline(apiClient) {
            // Return cached instance if available
            if (cachedValidationPipeline && validationEngineInitialized) {
                console.log('‚úÖ Using cached validation pipeline (instant)');
                return cachedValidationPipeline;
            }

            // First-time initialization
            console.log('üîÑ Initializing validation engine (first time)...');
            validationInitStartTime = performance.now();

            try {
                // Show loading feedback
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    const originalText = statusEl.textContent;
                    statusEl.className = 'status info';
                    statusEl.textContent = '‚öôÔ∏è Initializing validation engine...';

                    // Brief delay to show the message
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Create validation pipeline instance
                cachedValidationPipeline = new ValidationPipeline(apiClient);
                validationEngineInitialized = true;

                const initTime = (performance.now() - validationInitStartTime).toFixed(2);
                console.log(`‚úÖ Validation engine initialized in ${initTime}ms`);

                // Restore status
                if (statusEl) {
                    statusEl.className = 'status connected';
                    statusEl.textContent = '‚úÖ API Key Loaded - Ready to Generate';
                }

                return cachedValidationPipeline;

            } catch (error) {
                console.error('‚ùå Failed to initialize validation engine:', error);
                validationEngineInitialized = false;
                cachedValidationPipeline = null;

                // Show error
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.className = 'status error';
                    statusEl.textContent = '‚ùå Validation engine initialization failed';
                }

                throw error;
            }
        }

        /**
         * Reset validation pipeline cache (useful for testing)
         */
        function resetValidationPipeline() {
            cachedValidationPipeline = null;
            validationEngineInitialized = false;
            console.log('üîÑ Validation pipeline cache reset');
        }

        /**
         * Get validation engine stats
         */
        function getValidationEngineStats() {
            return {
                initialized: validationEngineInitialized,
                cached: cachedValidationPipeline !== null,
                initTime: validationInitStartTime ?
                    (performance.now() - validationInitStartTime).toFixed(2) + 'ms' : 'N/A'
            };
        }

        // ============================================================
        // STARTUP VALIDATION
        // ============================================================
        function validateStartup() {
            console.log('üîç Running startup validation...');
            const criticalElements = [
                'settingsModal',
                'apiKeyInput',
                'apiKeyStatus',
                'status',
                'transcript',
                'generateBtn'
            ];

            let missingElements = [];
            for (const id of criticalElements) {
                const el = document.getElementById(id);
                if (!el) {
                    missingElements.push(id);
                    console.error(`‚ùå Missing critical element: #${id}`);
                } else {
                    console.log(`‚úÖ Element found: #${id}`);
                }
            }

            // Check if database loaded
            if (typeof ClinicalScalesDatabase === 'undefined') {
                console.error('‚ùå ClinicalScalesDatabase not loaded!');
                alert('Error: Clinical scales database failed to load. Please refresh the page.');
                return false;
            } else {
                console.log(`‚úÖ ClinicalScalesDatabase loaded (${Object.keys(ClinicalScalesDatabase).length} scales)`);
            }

            if (missingElements.length > 0) {
                console.warn(`‚ö†Ô∏è  ${missingElements.length} elements missing, but continuing...`);
            } else {
                console.log('‚úÖ All critical elements found');
            }

            return true;
        }

        // Pathology-Specific Knowledge Base
        const PathologyDatabase = {
            'spine-degenerative': {
                name: 'Degenerative Spine Disease',
                vocabulary: ['disc herniation', 'stenosis', 'spondylolisthesis', 'facet arthropathy',
                    'ligamentum flavum', 'foramen', 'lateral recess', 'myelopathy', 'radiculopathy',
                    'ACDF', 'TLIF', 'laminectomy', 'foraminotomy', 'corpectomy'],
                redFlags: ['cauda equina syndrome', 'progressive myelopathy', 'bowel/bladder dysfunction',
                    'saddle anesthesia', 'bilateral weakness', 'hyperreflexia', 'clonus',
                    'Hoffman sign positive', 'inverted radial reflex', 'gait instability'],
                examFindings: ['Spurling test', 'straight leg raise', 'crossed straight leg raise',
                    'femoral stretch test', 'Hoffman sign', 'Babinski', 'clonus testing',
                    'tandem gait', 'Romberg test', 'motor strength testing by myotome'],
                differentials: ['Central disc herniation', 'Foraminal stenosis', 'Central canal stenosis',
                    'Spondylolisthesis', 'Facet syndrome', 'SI joint dysfunction',
                    'Piriformis syndrome', 'Peripheral neuropathy', 'Vascular claudication'],
                workup: ['MRI spine without contrast', 'CT myelogram if MRI contraindicated',
                    'Flexion-extension X-rays for instability', 'EMG/NCS for radiculopathy',
                    'DEXA scan if considering fusion'],
                guidelines: ['NASS guidelines for lumbar disc herniation', 'AOSpine classification system',
                    'Meyerding classification for spondylolisthesis', 'Modic changes classification'],
                recommendedScales: ['mjoa', 'nurick', 'ndi', 'odi', 'vas_pain']
            },
            'spine-trauma': {
                name: 'Traumatic Spine Injury',
                vocabulary: ['burst fracture', 'compression fracture', 'chance fracture', 'odontoid fracture',
                    'Jefferson fracture', 'hangman fracture', 'TLICS score', 'SLIC score',
                    'ASIA grade', 'neurogenic shock', 'spinal shock', 'central cord syndrome'],
                redFlags: ['incomplete spinal cord injury', 'neurological deterioration', 'unstable fracture',
                    'epidural hematoma', 'expanding syrinx', 'vascular injury', 'CSF leak', 'autonomic dysreflexia'],
                examFindings: ['ASIA examination', 'rectal tone', 'bulbocavernosus reflex', 'priapism',
                    'diaphragmatic breathing', 'sensory level', 'zone of partial preservation'],
                differentials: ['Complete vs incomplete SCI', 'Central cord syndrome', 'Brown-Sequard syndrome',
                    'Anterior cord syndrome', 'Conus medullaris syndrome', 'Cauda equina syndrome'],
                workup: ['CT spine - urgent', 'MRI for ligamentous injury', 'CT angiogram for vertebral artery',
                    'Upright X-rays when stable', 'Urodynamics if neurogenic bladder'],
                guidelines: ['TLICS scoring system', 'SLIC scoring system', 'AOSpine classification',
                    'NASCIS protocols for steroids', 'ASIA impairment scale'],
                recommendedScales: ['gcs', 'odi', 'vas_pain']
            },
            'brain-tumor': {
                name: 'Brain Tumor',
                vocabulary: ['glioblastoma', 'astrocytoma', 'oligodendroglioma', 'ependymoma', 'meningioma',
                    'schwannoma', 'pituitary adenoma', 'craniopharyngioma', 'medulloblastoma',
                    'IDH mutation', 'MGMT methylation', '1p19q codeletion', 'BRAF mutation',
                    'gross total resection', 'subtotal resection', 'awake craniotomy'],
                redFlags: ['papilledema', 'Cushing triad', 'uncal herniation', 'midline shift',
                    'hydrocephalus', 'seizures', 'rapid neurological decline', 'hemorrhage into tumor'],
                examFindings: ['papilledema', 'visual field defects', 'cranial nerve palsies',
                    'pronator drift', 'aphasia', 'neglect', 'ataxia', 'nystagmus'],
                differentials: ['Primary brain tumor', 'Metastatic disease', 'Abscess', 'Demyelinating disease',
                    'Vascular malformation', 'Radiation necrosis', 'Tumefactive MS'],
                workup: ['MRI brain with and without contrast', 'MR spectroscopy', 'MR perfusion',
                    'PET scan for metastatic workup', 'Lumbar puncture if carcinomatous meningitis',
                    'Neuropsychological testing pre-op', 'fMRI for eloquent area mapping'],
                guidelines: ['WHO 2021 CNS tumor classification', 'RANO criteria', 'Stupp protocol for GBM',
                    'RTOG recursive partitioning analysis', 'Karnofsky performance scale'],
                recommendedScales: ['gcs', 'vas_pain']
            },
            'vascular': {
                name: 'Cerebrovascular Disease',
                vocabulary: ['subarachnoid hemorrhage', 'aneurysm', 'AVM', 'dural AVF', 'cavernoma',
                    'moyamoya', 'vasospasm', 'Hunt-Hess', 'Fisher grade', 'WFNS grade',
                    'coiling', 'clipping', 'flow diverter', 'pipeline', 'WEB device'],
                redFlags: ['thunderclap headache', 'decreased GCS', 'new focal deficit', 'seizure',
                    'vasospasm window day 3-14', 'rebleeding', 'hydrocephalus', 'herniation'],
                examFindings: ['neck stiffness', 'Kernig sign', 'Brudzinski sign', 'cranial nerve palsies',
                    'pupillary changes', 'motor deficits', 'altered mental status'],
                differentials: ['Aneurysmal SAH', 'Perimesencephalic SAH', 'Traumatic SAH', 'AVM rupture',
                    'Reversible cerebral vasoconstriction syndrome', 'Pituitary apoplexy'],
                workup: ['CT head non-contrast - urgent', 'CTA head and neck', 'Lumbar puncture if CT negative',
                    'DSA gold standard', 'Transcranial dopplers for vasospasm', 'EEG if seizure concern'],
                guidelines: ['AHA/ASA guidelines for aneurysmal SAH', 'Hunt-Hess grading', 'Fisher scale',
                    'WFNS grading', 'Spetzler-Martin AVM grading'],
                recommendedScales: ['gcs', 'vas_pain']
            },
            'hydrocephalus': {
                name: 'Hydrocephalus',
                vocabulary: ['communicating', 'non-communicating', 'normal pressure hydrocephalus', 'NPH triad',
                    'ventriculomegaly', 'transependymal flow', 'aqueductal stenosis', 'fourth ventricle outlet obstruction',
                    'VP shunt', 'VA shunt', 'ETV', 'third ventriculostomy', 'programmable valve'],
                redFlags: ['acute mental status change', 'Cushing triad', 'upward gaze palsy', 'papilledema',
                    'bradycardia', 'hypertension', 'irregular respirations', 'seizures'],
                examFindings: ['gait apraxia', 'urinary incontinence', 'cognitive decline', 'papilledema',
                    'sixth nerve palsy', 'Parinaud syndrome', 'setting sun sign'],
                differentials: ['NPH', 'Obstructive hydrocephalus', 'Ex-vacuo changes', 'Cerebral atrophy',
                    'Chronic subdural hematoma', 'Previous SAH', 'Meningitis sequelae'],
                workup: ['MRI brain with CSF flow study', 'High volume lumbar puncture test',
                    'Lumbar drain trial', 'ICP monitoring', 'Neuropsychological testing', 'Gait assessment pre/post LP'],
                guidelines: ['International NPH guidelines', 'ETV success score', 'Evans index',
                    'Callosal angle measurement', 'DESH findings'],
                recommendedScales: ['gcs']
            },
            'functional': {
                name: 'Functional Neurosurgery',
                vocabulary: ['essential tremor', 'Parkinson disease', 'dystonia', 'DBS', 'GPi', 'STN',
                    'VIM nucleus', 'frame-based', 'frameless', 'microelectrode recording',
                    'beta oscillations', 'levodopa response', 'UPDRS score'],
                redFlags: ['atypical parkinsonism', 'cognitive decline', 'impulse control disorder (DBS-related)',
                    'medication refractory symptoms', 'severe dyskinesias', 'DBS hardware infection'],
                examFindings: ['resting tremor', 'bradykinesia', 'rigidity', 'postural instability',
                    'dystonic posturing', 'action tremor', 'intention tremor', 'pull test'],
                differentials: ['Parkinson disease', 'Essential tremor', 'Multiple system atrophy',
                    'Progressive supranuclear palsy', 'Corticobasal degeneration', 'Dystonia'],
                workup: ['MRI brain for DBS planning', 'DaTscan', 'Neuropsychological evaluation',
                    'Levodopa challenge test', 'UPDRS scoring', 'Video assessment'],
                guidelines: ['MDS clinical diagnostic criteria for PD', 'UPDRS scoring',
                    'Hoehn and Yahr staging', 'CAPSIT-PD protocol'],
                recommendedScales: ['vas_pain']
            },
            'pediatric': {
                name: 'Pediatric Neurosurgery',
                vocabulary: ['myelomeningocele', 'Chiari malformation', 'craniosynostosis', 'tethered cord',
                    'syrinx', 'encephalocele', 'Dandy-Walker', 'arachnoid cyst', 'hypothalamic hamartoma',
                    'cranial vault remodeling', 'duraplasty', 'detethering'],
                redFlags: ['increasing head circumference', 'bulging fontanelle', 'sunset eyes',
                    'developmental delay', 'regression of milestones', 'new onset seizures',
                    'stridor', 'apnea', 'failure to thrive'],
                examFindings: ['head circumference', 'fontanelle assessment', 'cranial sutures', 'primitive reflexes',
                    'developmental milestones', 'cutaneous stigmata', 'scoliosis check'],
                differentials: ['Chiari I vs II', 'Hydrocephalus', 'Benign enlargement of subarachnoid spaces',
                    'Craniosynostosis types', 'Tethered cord syndrome', 'Spinal dysraphism'],
                workup: ['MRI brain and spine', 'Cranial ultrasound if open fontanelle',
                    'CT head for craniosynostosis', 'Urodynamics for tethered cord',
                    'Sleep study for Chiari', 'Genetic testing if syndromic'],
                guidelines: ['Chiari malformation guidelines', 'Craniosynostosis classifications',
                    'Spina bifida management guidelines', 'Pediatric hydrocephalus consensus'],
                recommendedScales: ['gcs']
            },
            'peripheral': {
                name: 'Peripheral Nerve',
                vocabulary: ['carpal tunnel', 'cubital tunnel', 'thoracic outlet syndrome', 'peroneal palsy',
                    'meralgia paresthetica', 'nerve tumor', 'schwannoma', 'neurofibroma',
                    'nerve transfer', 'neurolysis', 'transposition', 'decompression'],
                redFlags: ['rapid progression', 'muscle wasting', 'complete nerve palsy',
                    'multiple nerve involvement', 'associated mass', 'malignant transformation'],
                examFindings: ['Tinel sign', 'Phalen test', 'Froment sign', 'Wartenberg sign',
                    'sensory distribution testing', 'two-point discrimination', 'muscle bulk', 'specific muscle testing'],
                differentials: ['Compression neuropathy', 'Peripheral neuropathy', 'Radiculopathy',
                    'Brachial plexopathy', 'Motor neuron disease', 'Nerve tumor'],
                workup: ['EMG/NCS', 'MRI for nerve visualization', 'Ultrasound for dynamic assessment',
                    'MR neurography', 'Laboratory studies for neuropathy'],
                guidelines: ['AAOS carpal tunnel guidelines', 'Peripheral nerve injury classification',
                    'Seddon and Sunderland classifications'],
                recommendedScales: ['vas_pain']
            }
        };

        // ============================================================
        // API KEY SETTINGS FUNCTIONS
        // ============================================================

        function openSettings() {
            try {
                console.log('üîß Opening settings modal...');
                const modal = document.getElementById('settingsModal');
                const input = document.getElementById('apiKeyInput');
                const statusDiv = document.getElementById('apiKeyStatusModal');

                if (!modal) {
                    console.error('‚ùå Settings modal element not found');
                    alert('Error: Settings modal not found. Please refresh the page.');
                    return;
                }

                if (!input) {
                    console.error('‚ùå API key input element not found');
                    return;
                }

                // Load existing key if available (show masked)
                if (API_KEY) {
                    input.value = API_KEY;
                    input.type = 'password';
                } else {
                    input.value = '';
                }

                if (statusDiv) {
                    statusDiv.style.display = 'none';
                }

                modal.style.display = 'flex';
                console.log('‚úÖ Settings modal opened');
            } catch (error) {
                console.error('‚ùå Error opening settings:', error);
                alert('Error opening settings. Please refresh the page and try again.');
            }
        }

        function closeSettings() {
            try {
                const modal = document.getElementById('settingsModal');
                if (modal) {
                    modal.style.display = 'none';
                    console.log('‚úÖ Settings modal closed');
                } else {
                    console.error('‚ùå Settings modal not found');
                }
            } catch (error) {
                console.error('‚ùå Error closing settings:', error);
            }
        }

        // Web Crypto API encryption utilities for secure API key storage
        async function encryptAPIKey(key) {
            try {
                // Generate a key from browser fingerprint + domain (deterministic)
                const baseString = `neuroscribe-${window.location.hostname}-encryption-key`;
                const encoder = new TextEncoder();
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(baseString),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveKey']
                );

                // Derive AES key using PBKDF2
                const cryptoKey = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: encoder.encode(CONSTANTS.ENCRYPTION.SALT),
                        iterations: CONSTANTS.ENCRYPTION.PBKDF2_ITERATIONS,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: CONSTANTS.ENCRYPTION.AES_KEY_LENGTH },
                    false,
                    ['encrypt', 'decrypt']
                );

                // Generate random IV
                const iv = crypto.getRandomValues(new Uint8Array(CONSTANTS.ENCRYPTION.IV_LENGTH));

                // Encrypt the API key
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv },
                    cryptoKey,
                    encoder.encode(key)
                );

                // Combine IV and encrypted data
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv, 0);
                combined.set(new Uint8Array(encrypted), iv.length);

                // Convert to base64 for storage
                return btoa(String.fromCharCode(...combined));
            } catch (error) {
                console.error('‚ùå Encryption error:', error);
                throw new Error('Failed to encrypt API key');
            }
        }

        async function decryptAPIKey(encryptedData) {
            try {
                // Generate the same key from browser fingerprint
                const baseString = `neuroscribe-${window.location.hostname}-encryption-key`;
                const encoder = new TextEncoder();
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(baseString),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveKey']
                );

                // Derive AES key using PBKDF2
                const cryptoKey = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: encoder.encode(CONSTANTS.ENCRYPTION.SALT),
                        iterations: CONSTANTS.ENCRYPTION.PBKDF2_ITERATIONS,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: CONSTANTS.ENCRYPTION.AES_KEY_LENGTH },
                    false,
                    ['encrypt', 'decrypt']
                );

                // Decode base64
                const combined = new Uint8Array(
                    atob(encryptedData).split('').map(char => char.charCodeAt(0))
                );

                // Extract IV and encrypted data
                const iv = combined.slice(0, CONSTANTS.ENCRYPTION.IV_LENGTH);
                const encrypted = combined.slice(CONSTANTS.ENCRYPTION.IV_LENGTH);

                // Decrypt
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv },
                    cryptoKey,
                    encrypted
                );

                // Convert back to string
                return new TextDecoder().decode(decrypted);
            } catch (error) {
                console.error('‚ùå Decryption error:', error);
                throw new Error('Failed to decrypt API key');
            }
        }

        async function saveAPIKey() {
            try {
                console.log('üíæ Attempting to save API key...');
                const input = document.getElementById('apiKeyInput');

                if (!input) {
                    console.error('‚ùå API key input element not found');
                    alert('Error: Could not find API key input field');
                    return;
                }

                const statusDiv = document.getElementById('apiKeyStatusModal');
                const key = input.value.trim();

                // Validate input
                if (!key) {
                    showAPIKeyStatus('error', '‚ùå Please enter an API key');
                    return;
                }

                console.log('üîç Validating API key format...');

                if (!key.startsWith('AIza')) {
                    showAPIKeyStatus('error', '‚ùå Invalid API key format. Key should start with "AIza"');
                    return;
                }

                // Show testing status
                showAPIKeyStatus('info', '‚è≥ Testing API key...');
                console.log('üß™ Testing API key with Gemini API...');

                // Test the API key with a simple request
                const testResponse = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${key}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: 'Test' }]
                            }],
                            generationConfig: {
                                temperature: 0.3,
                                maxOutputTokens: 10
                            }
                        })
                    }
                );

                if (testResponse.ok) {
                    // API key is valid - encrypt and save it
                    console.log('‚úÖ API key validated successfully');
                    showAPIKeyStatus('info', 'üîê Encrypting API key...');

                    const encrypted = await encryptAPIKey(key);
                    localStorage.setItem('neuroscribe_gemini_key', encrypted);
                    localStorage.setItem('neuroscribe_provider', 'gemini');
                    localStorage.setItem('neuroscribe_encryption_version', CONSTANTS.ENCRYPTION.VERSION);
                    API_KEY = key;

                    showAPIKeyStatus('success', '‚úÖ API key saved and verified! Reloading...');
                    updateAPIKeyStatus(true);

                    // Close modal and reload after 1 second
                    setTimeout(() => {
                        closeSettings();
                        location.reload();
                    }, 1500);

                } else {
                    const errorData = await testResponse.json().catch(() => ({}));
                    const errorMsg = errorData.error?.message || 'Invalid API key';
                    console.error('‚ùå API key test failed:', errorMsg);
                    showAPIKeyStatus('error', `‚ùå API key test failed: ${errorMsg}`);
                }

            } catch (error) {
                console.error('‚ùå Critical error in saveAPIKey:', error);
                showAPIKeyStatus('error', `‚ùå Error testing API key: ${error.message}`);
            }
        }

        function showAPIKeyStatus(type, message) {
            try {
                const statusDiv = document.getElementById('apiKeyStatusModal');

                if (!statusDiv) {
                    console.warn('‚ö†Ô∏è  API key status div not found, using console instead');
                    console.log(`${type.toUpperCase()}: ${message}`);
                    return;
                }

                statusDiv.style.display = 'block';

                const colors = {
                    success: { bg: '#d1fae5', border: '#10b981', color: '#065f46' },
                    error: { bg: '#fee2e2', border: '#dc2626', color: '#991b1b' },
                    info: { bg: '#dbeafe', border: '#4A90E2', color: '#1e40af' }
                };

                const color = colors[type] || colors.info;
                statusDiv.style.background = color.bg;
                statusDiv.style.borderLeft = `3px solid ${color.border}`;
                statusDiv.style.color = color.color;
                statusDiv.textContent = message;
            } catch (error) {
                console.error('‚ùå Error showing API key status:', error);
            }
        }

        async function loadAPIKey() {
            try {
                console.log('üîç Checking for API key in localStorage...');
                const encrypted = localStorage.getItem('neuroscribe_gemini_key');
                const encryptionVersion = localStorage.getItem('neuroscribe_encryption_version');
                console.log('Encrypted key:', encrypted ? `Found (${encrypted.length} chars)` : 'NULL');
                console.log('Encryption version:', encryptionVersion || 'legacy');

                const statusEl = document.getElementById('status');

                if (encrypted) {
                    try {
                        // Check if this is a new encrypted key or legacy key
                        if (encryptionVersion === 'v1') {
                            // New Web Crypto API encryption
                            console.log('üîê Decrypting with Web Crypto API...');
                            API_KEY = await decryptAPIKey(encrypted);
                        } else {
                            // Legacy btoa encryption - migrate to new encryption
                            console.log('‚ö†Ô∏è  Legacy encryption detected - migrating to secure encryption...');
                            API_KEY = atob(encrypted).split('').reverse().join('');

                            // Re-encrypt with new method
                            const newEncrypted = await encryptAPIKey(API_KEY);
                            localStorage.setItem('neuroscribe_gemini_key', newEncrypted);
                            localStorage.setItem('neuroscribe_encryption_version', 'v1');
                            console.log('‚úÖ API key migrated to secure encryption');
                        }

                        if (statusEl) {
                            statusEl.className = 'status connected';
                            statusEl.textContent = '‚úÖ API Key Loaded - Ready to Generate';
                        }
                        console.log('‚úÖ API key loaded:', API_KEY.substring(0, 15) + '...');
                        updateAPIKeyStatus(true);
                        return true;
                    } catch (e) {
                        console.error('‚ùå Failed to decrypt key:', e);
                        if (statusEl) {
                            statusEl.className = 'status disconnected';
                            statusEl.textContent = '‚ùå API Key Error - Click Settings';
                        }
                        updateAPIKeyStatus(false);

                        // Clear corrupted key
                        localStorage.removeItem('neuroscribe_gemini_key');
                        localStorage.removeItem('neuroscribe_encryption_version');
                    }
                }

                console.warn('‚ö†Ô∏è  No API key found in localStorage');
                if (statusEl) {
                    statusEl.className = 'status disconnected';
                    statusEl.innerHTML = '‚ùå No API Key - Click <strong>‚öôÔ∏è Settings</strong> to configure';
                }
                updateAPIKeyStatus(false);

                // Auto-open settings modal if no key found
                setTimeout(() => {
                    try {
                        openSettings();
                    } catch (e) {
                        console.error('‚ùå Error opening settings:', e);
                    }
                }, 1500);

                return false;
            } catch (error) {
                console.error('‚ùå Critical error in loadAPIKey:', error);
                return false;
            }
        }

        // Test API Key without saving
        async function testAPIKey() {
            const input = document.getElementById('apiKeyInput');
            const key = input.value.trim();

            if (!key) {
                showAPIKeyStatus('error', '‚ùå Please enter an API key to test');
                return;
            }

            if (!key.startsWith('AIza')) {
                showAPIKeyStatus('error', '‚ùå Invalid API key format');
                return;
            }

            showAPIKeyStatus('info', '‚è≥ Testing API key...');

            try {
                const testResponse = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${key}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: 'Test' }]
                            }],
                            generationConfig: {
                                temperature: 0.3,
                                maxOutputTokens: 10
                            }
                        })
                    }
                );

                if (testResponse.ok) {
                    showAPIKeyStatus('success', '‚úÖ API key is valid!');
                } else {
                    const errorData = await testResponse.json();
                    const errorMsg = errorData.error?.message || 'Invalid API key';
                    showAPIKeyStatus('error', `‚ùå Test failed: ${errorMsg}`);
                }
            } catch (error) {
                showAPIKeyStatus('error', `‚ùå Error: ${error.message}`);
            }
        }

        // Clear API Key from storage
        function clearAPIKey() {
            if (confirm('Are you sure you want to clear the saved API key?')) {
                localStorage.removeItem('neuroscribe_gemini_key');
                localStorage.removeItem('neuroscribe_provider');
                API_KEY = null;
                document.getElementById('apiKeyInput').value = '';
                showAPIKeyStatus('success', 'üóëÔ∏è API key cleared! Please enter a new key.');
                updateAPIKeyStatus(false);
            }
        }

        // Update API Key Status Indicator in Header
        function updateAPIKeyStatus(isValid) {
            const statusDiv = document.getElementById('apiKeyStatus');
            if (!statusDiv) return;

            if (isValid) {
                statusDiv.innerHTML = '‚úÖ <span style="color: #10b981;">API Key Active</span>';
            } else {
                statusDiv.innerHTML = '‚ùå <span style="color: #ef4444;">No API Key</span>';
            }
        }

        // Toggle Panel Collapse
        function togglePanel(panelId) {
            try {
                console.log(`üîÑ Toggling panel: ${panelId}`);
                const content = document.getElementById(`${panelId}-content`);
                const icon = document.getElementById(`${panelId}-icon`);

                if (!content) {
                    console.error(`‚ùå Panel content not found: ${panelId}-content`);
                    return;
                }

                if (!icon) {
                    console.error(`‚ùå Panel icon not found: ${panelId}-icon`);
                    return;
                }

                content.classList.toggle('collapsed');
                icon.classList.toggle('collapsed');

                // Save state to localStorage
                const isCollapsed = content.classList.contains('collapsed');
                localStorage.setItem(`panel_${panelId}_collapsed`, isCollapsed);

                console.log(`‚úÖ Panel ${panelId} is now ${isCollapsed ? 'collapsed' : 'expanded'}`);
            } catch (error) {
                console.error(`‚ùå Error toggling panel ${panelId}:`, error);
            }
        }

        // V10.2.3: Toggle score calculation breakdown visibility
        function toggleScoreBreakdown() {
            const breakdown = document.getElementById('scoreBreakdown');
            const button = document.querySelector('#scoreBreakdownToggle button');

            if (!breakdown) return;

            if (breakdown.style.display === 'none') {
                breakdown.style.display = 'block';
                if (button) button.textContent = 'üìä Hide Calculation Breakdown';
            } else {
                breakdown.style.display = 'none';
                if (button) button.textContent = 'üìä Show Calculation Breakdown';
            }
        }

        // Restore panel states on load
        function restorePanelStates() {
            try {
                console.log('üîÑ Restoring panel states from localStorage...');
                ['briefing', 'transcript'].forEach(panelId => {
                    try {
                        const isCollapsed = localStorage.getItem(`panel_${panelId}_collapsed`) === 'true';
                        if (isCollapsed) {
                            const content = document.getElementById(`${panelId}-content`);
                            const icon = document.getElementById(`${panelId}-icon`);
                            if (content && icon) {
                                content.classList.add('collapsed');
                                icon.classList.add('collapsed');
                                console.log(`‚úÖ Panel ${panelId} restored as collapsed`);
                            }
                        } else {
                            console.log(`‚ÑπÔ∏è  Panel ${panelId} not collapsed`);
                        }
                    } catch (error) {
                        console.error(`‚ùå Error restoring panel ${panelId}:`, error);
                    }
                });
                console.log('‚úÖ Panel states restored');
            } catch (error) {
                console.error('‚ùå Error in restorePanelStates:', error);
            }
        }

        // Initialize Speech Recognition
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('‚ö†Ô∏è Speech recognition not supported in this browser. Please use Chrome, Edge, or Safari.');
                document.getElementById('startBtn').disabled = true;
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();

            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 3;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                console.log('üé§ Speech recognition started');
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    const confidence = event.results[i][0].confidence;

                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                        if (confidence) {
                            confidenceScores.push(confidence);
                            updateConfidence();
                        }
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (finalTranscript) {
                    const transcriptArea = document.getElementById('transcript');
                    transcriptArea.value += finalTranscript;
                    updateWordCount();

                    // Real-time monitoring
                    checkForRedFlags(finalTranscript);
                    checkForScaleComponents(finalTranscript);
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    alert('‚ùå Microphone access denied. Please allow microphone access in browser settings.');
                } else if (event.error === 'no-speech') {
                    console.log('No speech detected');
                } else {
                    alert(`Speech recognition error: ${event.error}`);
                }
            };

            recognition.onend = () => {
                if (isRecording && !isPaused) {
                    // Restart if still recording
                    recognition.start();
                } else {
                    console.log('üé§ Speech recognition ended');
                }
            };

            console.log('‚úÖ Speech recognition initialized');
        }

        function startRecording() {
            if (!recognition) {
                alert('Speech recognition not initialized');
                return;
            }

            isRecording = true;
            isPaused = false;
            startTime = Date.now();
            confidenceScores = [];

            try {
                recognition.start();
            } catch (e) {
                console.error('Failed to start recognition:', e);
            }

            // Update UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('status').className = 'status recording';
            document.getElementById('status').textContent = 'üî¥ Recording in progress...';

            // Start timer
            timerInterval = setInterval(updateDuration, 1000);
        }

        function stopRecording() {
            isRecording = false;
            isPaused = false;

            if (recognition) {
                recognition.stop();
            }

            // Update UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('status').className = 'status connected';
            document.getElementById('status').textContent = '‚úÖ Recording stopped - Ready to generate';

            // Stop timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function pauseRecording() {
            if (isPaused) {
                // Resume
                isPaused = false;
                recognition.start();
                document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
                document.getElementById('status').textContent = 'üî¥ Recording in progress...';
            } else {
                // Pause
                isPaused = true;
                recognition.stop();
                document.getElementById('pauseBtn').textContent = '‚ñ∂Ô∏è Resume';
                document.getElementById('status').textContent = '‚è∏Ô∏è Recording paused';
            }
        }

        function updateWordCount() {
            const text = document.getElementById('transcript').value;
            const words = text.trim().split(/\s+/).filter(w => w.length > 0);
            document.getElementById('wordCount').textContent = words.length;
        }

        function updateDuration() {
            if (!startTime) return;
            const elapsed = Date.now() - startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('duration').textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateConfidence() {
            if (confidenceScores.length === 0) {
                document.getElementById('confidence').textContent = '--';
                return;
            }
            const avg = confidenceScores.reduce((a, b) => a + b, 0) / confidenceScores.length;
            document.getElementById('confidence').textContent = Math.round(avg * 100) + '%';
        }

        function clearText() {
            if (confirm('Clear transcript?')) {
                document.getElementById('transcript').value = '';
                updateWordCount();
                confidenceScores = [];
                updateConfidence();
                resetAutoActivationFlag(); // Allow auto-activation to trigger again for new consultation
            }
        }

        // Pathology Selection
        function selectPathology(pathologyId) {
            selectedPathology = pathologyId;
            customPathology = ''; // Clear custom input when selecting preset
            document.getElementById('customPathology').value = '';

            // Update button states
            document.querySelectorAll('.pathology-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-pathology="${pathologyId}"]`).classList.add('active');

            // Enable briefing button
            document.getElementById('briefingBtn').disabled = false;

            // Update active red flags for monitoring
            if (PathologyDatabase[pathologyId]) {
                activeRedFlags = PathologyDatabase[pathologyId].redFlags;
                console.log(`‚úÖ Selected: ${PathologyDatabase[pathologyId].name}`);
                console.log(`üö® Monitoring ${activeRedFlags.length} red flags`);
            }
        }

        // Custom Pathology Input Handler
        function onCustomPathologyInput() {
            const input = document.getElementById('customPathology');
            customPathology = input.value.trim();

            if (customPathology.length > 3) {
                // Clear preset pathology selection
                selectedPathology = null;
                document.querySelectorAll('.pathology-btn').forEach(btn => {
                    btn.classList.remove('active');
                });

                // Enable briefing button
                document.getElementById('briefingBtn').disabled = false;

                // Clear red flags when using custom (will be generated)
                activeRedFlags = [];

                console.log(`‚úÖ Custom pathology entered: ${customPathology}`);
            } else if (customPathology.length === 0) {
                // Disable button if no input and no selection
                if (!selectedPathology) {
                    document.getElementById('briefingBtn').disabled = true;
                }
            }
        }

        // ============================================================
        // AI REASON EXTRACTION FOR AUTO-ACTIVATION
        // ============================================================

        /**
         * Intelligently extracts the primary reason for consultation from clinical transcript
         * Used when user leaves the reason field blank - provides automatic fallback
         * @param {string} transcript - Clinical transcript text
         * @returns {Promise<string|null>} - Extracted reason or null if unclear
         */
        async function extractReasonFromTranscript(transcript) {
            // Guard: Already attempted extraction
            if (reasonExtractionAttempted) {
                console.log('‚äò Reason extraction already attempted this session');
                return null;
            }
            reasonExtractionAttempted = true;

            // Guard: Transcript too short for meaningful analysis
            if (!transcript || transcript.trim().length < 50) {
                console.log('‚ö†Ô∏è Transcript too short for reason extraction (< 50 chars)');
                return null;
            }

            // Guard: API key not available
            if (!API_KEY) {
                console.log('‚ö†Ô∏è API key not available for reason extraction');
                return null;
            }

            console.log('üîç Extracting reason for consultation from transcript...');

            // Use first 300 words for analysis to keep prompt focused
            const words = transcript.trim().split(/\s+/);
            const truncated = words.slice(0, 300).join(' ');
            console.log(`üìä Analyzing ${words.length} words (using first ${Math.min(words.length, 300)})`);

            const extractionPrompt = `You are a clinical documentation expert. Extract ONLY the primary reason for consultation or chief complaint from this clinical transcript.

RULES:
- Return a concise pathology/diagnosis phrase (2-10 words maximum)
- Focus on the PRIMARY medical condition being addressed
- Use standard medical terminology
- Examples of good extractions:
  * "L4-5 disc herniation"
  * "Cervical myelopathy C5-6"
  * "Brain tumor resection"
  * "Thoracic spine fracture"
  * "Chiari malformation type I"

- If the reason is unclear or ambiguous, return exactly: "UNCLEAR"
- Do NOT include explanations, context, or additional text
- Return ONLY the extracted reason phrase or "UNCLEAR"

Clinical transcript excerpt:
"""
${truncated}
"""

Extracted reason:`;

            try {
                // Call Gemini API with short token limit for concise response
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: extractionPrompt }]
                            }],
                            generationConfig: {
                                temperature: 0.2,  // Low temperature for precise extraction
                                maxOutputTokens: 50  // Short response
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                const extracted = (data.candidates?.[0]?.content?.parts?.[0]?.text || '').trim();

                // Validation checks
                if (extracted === 'UNCLEAR') {
                    console.log('‚ö†Ô∏è AI could not identify clear reason from transcript');
                    return null;
                }

                if (extracted.length > 100) {
                    console.log('‚ö†Ô∏è Extracted reason too long (> 100 chars), likely invalid:', extracted.substring(0, 50) + '...');
                    return null;
                }

                if (extracted.length < 5) {
                    console.log('‚ö†Ô∏è Extracted reason too short (< 5 chars), likely invalid:', extracted);
                    return null;
                }

                // Check if response looks like it's trying to explain rather than extract
                const invalidPatterns = ['The reason', 'appears to be', 'seems to', 'based on', 'likely', 'possibly'];
                if (invalidPatterns.some(pattern => extracted.toLowerCase().includes(pattern.toLowerCase()))) {
                    console.log('‚ö†Ô∏è Extracted text appears to be explanation rather than diagnosis:', extracted);
                    return null;
                }

                console.log('‚úÖ Successfully extracted reason:', extracted);
                return extracted;

            } catch (error) {
                console.error('‚ùå Reason extraction failed:', error);
                console.error('Error details:', error.message);
                return null;
            }
        }

        // Generate Deep Briefing with Clinical Checklist
        async function generateDeepBriefing() {
            // Validate inputs
            if (!selectedPathology && !customPathology) {
                alert('Please enter a specific pathology or select a common category');
                return;
            }

            if (!API_KEY) {
                alert('API key not configured.');
                return;
            }

            const depth = document.getElementById('briefingDepth').value;
            const btn = document.getElementById('briefingBtn');
            const output = document.getElementById('briefingOutput');

            btn.disabled = true;
            btn.textContent = '‚è≥ Generating Deep Research...';
            output.innerHTML = '<p style="color: #999; text-align: center; padding: 30px;">Performing deep search and generating clinical checklist...</p>';

            try {
                // Determine pathology context
                let pathologyName, pathologyContext;

                if (customPathology) {
                    // Custom pathology - deep search mode
                    pathologyName = customPathology;
                    pathologyContext = `custom search for: ${customPathology}`;
                } else {
                    // Preset pathology - use database
                    const pathology = PathologyDatabase[selectedPathology];
                    pathologyName = pathology.name;
                    pathologyContext = `database-supported: ${pathology.name}`;
                }

                // Build depth-specific parameters
                const depthConfig = {
                    quick: { tokens: 2048, focus: 'essential checklist items', detail: 'concise' },
                    standard: { tokens: 4096, focus: 'comprehensive checklist with evidence', detail: 'detailed' },
                    comprehensive: { tokens: 8192, focus: 'exhaustive analysis with decision algorithms', detail: 'exhaustive' }
                };

                const config = depthConfig[depth];

                // Build additional context from uploaded documents
                let expertDocContext = '';
                if (uploadedDocText && uploadedDocText.trim().length > 0) {
                    expertDocContext = `\n\n=== UPLOADED EXPERT DOCUMENTS ===\nYou have been provided with ${uploadedDocuments.length} expert document(s) containing additional research, guidelines, or clinical information. Integrate this knowledge into your briefing:\n\n${uploadedDocText}\n\n=== END UPLOADED DOCUMENTS ===\n\nIMPORTANT: Synthesize information from the uploaded documents with your medical knowledge. Cite specific findings from the uploaded documents when relevant.\n\n`;
                }

                // Enhanced prompt for deep research + checklist
                const prompt = `You are a world-class neurosurgical consultant conducting deep research for a patient consultation on: ${pathologyName}
${expertDocContext}
Generate a ${config.detail} clinical briefing with an actionable checklist. Provide ${config.focus}.

‚õî‚õî‚õî CRITICAL CONSTRAINTS FOR RED FLAG GENERATION ‚õî‚õî‚õî

When generating "Critical Red Flags to Screen", you MUST follow these MANDATORY rules:

‚úÖ ONLY INCLUDE:
1. **Neurological/Surgical Emergencies** directly related to the pathology:
   - Cauda equina syndrome (bowel/bladder dysfunction, saddle anesthesia)
   - Progressive neurological deficit or acute myelopathy
   - Signs of herniation, mass effect, or increased ICP
   - CSF leak, meningitis, abscess, or infection
   - Acute hemorrhage or vascular compromise
   - Spinal cord compression or acute radiculopathy
   - Seizures, stroke, or TIA symptoms

2. **Pathology-Specific Complications**:
   - Hardware failure (shunt malfunction, DBS malfunction)
   - Post-operative complications (wound infection, CSF leak)
   - Disease-specific red flags (e.g., vision loss in pituitary tumor)

üö´ ABSOLUTELY PROHIBITED (DO NOT INCLUDE):
1. **Psychiatric symptoms**: depression | suicidal ideation | suicide | suicidal thoughts | anxiety | psychosis | mental health concerns | psychological distress | mood disorders | psychiatric diagnoses
2. **Social history items**: substance abuse | opioid dependency | drug-seeking behavior | alcohol use | smoking | employment status | living situation
3. **Psychosocial concerns**: coping difficulties | family stress | social determinants of health
4. **Vague screening items**: "screen for depression" | "assess mental health" | "evaluate for suicidal ideation"

üéØ RATIONALE:
This briefing will be used during clinical documentation where the AI must ONLY document findings explicitly stated by the patient/clinician. Including psychiatric red flags in the checklist creates expectations that lead to FABRICATION in patient notes (the AI adds psychiatric symptoms not mentioned in the encounter). We can only include items that can be objectively assessed through neurological examination or direct patient reporting.

üí° CORRECT RED FLAG EXAMPLES:
‚úÖ "New onset bowel/bladder dysfunction (cauda equina)"
‚úÖ "Progressive weakness or sensory loss"
‚úÖ "Fever + nuchal rigidity (meningitis)"
‚úÖ "Sudden severe headache (hemorrhage)"

‚ùå PROHIBITED RED FLAG EXAMPLES:
‚ùå "Depression or suicidal ideation (common in chronic pain)" ‚Üí NEVER include psychiatric terms
‚ùå "Screen for substance abuse" ‚Üí Social history, not neurological emergency
‚ùå "Assess coping and mental health" ‚Üí Psychosocial, not surgical red flag

${uploadedDocuments.length > 0 ? `üìö INTEGRATION NOTE: ${uploadedDocuments.length} expert document(s) uploaded. Please synthesize this additional information throughout your briefing.\n\n` : ''}Structure your response with these sections:

## üéØ Clinical Overview
- Pathophysiology and clinical significance
- Key anatomical considerations
- Common presentations and variants

## üìã CLINICAL CHECKLIST

### History Questions to Ask:
- [ ] [List 5-10 specific questions organized by system]

### Physical Examination Maneuvers:
- [ ] [List 5-10 specific exam techniques with interpretation]

### Critical Red Flags to Screen:
- [ ] [List 5-10 emergency warning signs requiring urgent intervention]

### Differential Diagnoses to Consider:
- [ ] [List 5-8 alternative diagnoses ranked by likelihood]

## üî¨ Diagnostic Workup

### First-Line Investigations:
- [ ] [List essential studies with rationale]

### Advanced/Specialized Testing:
- [ ] [List additional studies if first-line inconclusive]

### Laboratory Studies:
- [ ] [List relevant lab tests]

## üíé Evidence-Based Management

### Conservative Management Options:
- [Level I-V evidence citations]

### Surgical Indications:
- Absolute indications:
- Relative indications:

### Decision Algorithm:
- If [finding], then [action]
- [Provide step-by-step clinical decision tree]

## üìö Clinical Guidelines & Evidence
- [List relevant Level I-III evidence]
- [Citation to major guidelines]

## ‚ö†Ô∏è Complications & Risk Stratification
- Common complications to discuss
- Risk factors for poor outcomes

Make this actionable and ready to use during the patient consultation. Use checkboxes for items to verify.`;

                // Call Gemini API
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.4,  // Slightly higher for comprehensive research
                                maxOutputTokens: config.tokens
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                const briefingText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No briefing generated';

                // Store briefing data globally for integration
                generatedBriefing = briefingText;
                briefingUsed = false;  // Will be set to true when used in documentation

                // Extract checklist items for later use
                briefingChecklist = extractChecklistItems(briefingText);

                console.log(`‚úÖ Deep briefing generated for: ${pathologyName}`);
                console.log(`üìã Extracted ${briefingChecklist.length} checklist items`);

                // V8 MITIGATION: Initialize checklist tracking
                initializeChecklistTracking();

                // Convert markdown to HTML for display
                let html = briefingText
                    .replace(/^## (.+)$/gm, '<h3 style="color: #0066CC; margin-top: 15px; margin-bottom: 8px; font-size: 1rem;">$1</h3>')
                    .replace(/^### (.+)$/gm, '<h4 style="color: #333; margin-top: 12px; margin-bottom: 6px; font-size: 0.95rem; font-weight: 600;">$1</h4>')
                    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                    .replace(/^- \[ \] (.+)$/gm, '<div style="margin-left: 15px; margin-bottom: 5px;"><input type="checkbox" style="margin-right: 8px;">$1</div>')
                    .replace(/^- (.+)$/gm, '<div style="margin-left: 15px; margin-bottom: 5px;">‚Ä¢ $1</div>')
                    .replace(/\n\n/g, '<br>');

                output.innerHTML = html;

                // Update status to show briefing is ready
                const status = document.getElementById('status');
                status.className = 'status';
                status.style.background = '#d4edda';
                status.style.color = '#155724';
                status.textContent = '‚úÖ Deep briefing ready - Will be integrated with documentation';

                // Enable enhancement toggles now that briefing is available
                updateEnhancementToggles();

            } catch (error) {
                console.error('Deep briefing generation error:', error);
                output.innerHTML = `<p style="color: #DC143C; padding: 20px;">‚ùå Error: ${error.message}</p>`;
                alert(`Deep briefing generation failed: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üéØ Generate Deep Research + Checklist';
            }
        }

        // Extract checklist items from briefing text
        function extractChecklistItems(text) {
            const checklistItems = [];
            const lines = text.split('\n');

            for (const line of lines) {
                // Match checkbox items: - [ ] Item text
                const match = line.match(/^- \[ \] (.+)$/);
                if (match) {
                    checklistItems.push(match[1].trim());
                }
            }

            return checklistItems;
        }

        // ========================================
        // V8 MITIGATION: Checklist Tracking System
        // ========================================

        /**
         * Initialize checklist state tracking with event listeners
         * Called after briefing generation
         */
        function initializeChecklistTracking() {
            if (!briefingChecklist || briefingChecklist.length === 0) {
                console.log('‚ö†Ô∏è No checklist items to track');
                return;
            }

            // Initialize state for each checklist item
            briefingChecklist.forEach((item, index) => {
                checklistState[index] = {
                    text: item,
                    checked: false,
                    timestamp: null
                };
            });

            // Bind event listeners to checkboxes (using CSS class)
            setTimeout(() => {
                const checkboxes = document.querySelectorAll('#briefing-output input[type="checkbox"]');
                checkboxes.forEach((checkbox, index) => {
                    checkbox.addEventListener('change', (e) => {
                        if (checklistState[index]) {
                            checklistState[index].checked = e.target.checked;
                            checklistState[index].timestamp = new Date().toISOString();

                            console.log(`‚úÖ Checklist item ${index + 1} ${e.target.checked ? 'checked' : 'unchecked'}:`,
                                checklistState[index].text.substring(0, 50));

                            // Update coverage summary
                            const summary = getChecklistGapSummary();
                            console.log(`üìä Checklist Coverage: ${summary.completed}/${summary.total} (${summary.percentComplete}%)`);
                        }
                    });
                });
                console.log(`‚úÖ Initialized tracking for ${checkboxes.length} checklist items`);
            }, 500); // Delay to ensure DOM is fully rendered
        }

        /**
         * Get summary of checklist gaps (unchecked items)
         * Returns coverage statistics
         */
        function getChecklistGapSummary() {
            if (!briefingChecklist || Object.keys(checklistState).length === 0) {
                return {
                    total: 0,
                    completed: 0,
                    percentComplete: 0,
                    missing: []
                };
            }

            const missing = [];
            let completed = 0;

            Object.keys(checklistState).forEach(index => {
                if (checklistState[index].checked) {
                    completed++;
                } else {
                    missing.push(checklistState[index].text);
                }
            });

            return {
                total: briefingChecklist.length,
                completed: completed,
                percentComplete: Math.round((completed / briefingChecklist.length) * 100),
                missing: missing
            };
        }

        /**
         * Extract medical keywords from checklist item text
         * Used for algorithmic coverage analysis
         */
        function extractMedicalKeywords(text) {
            // Common stop words to exclude
            const stopWords = new Set([
                'the', 'is', 'are', 'was', 'were', 'for', 'to', 'check', 'assess',
                'evaluate', 'ask', 'about', 'document', 'obtain', 'perform', 'test',
                'examine', 'review', 'ensure', 'confirm', 'verify', 'note', 'record'
            ]);

            // Extract words, filter stop words, keep meaningful terms (>3 chars)
            const words = text.toLowerCase()
                .replace(/[^\w\s]/g, ' ')  // Remove punctuation
                .split(/\s+/)
                .filter(w => w.length > 3 && !stopWords.has(w));

            return [...new Set(words)];  // Remove duplicates
        }

        /**
         * Analyze checklist coverage using algorithmic keyword matching
         * Compares transcript against checklist items
         * Returns coverage analysis for each item
         */
        function analyzeChecklistCoverage(transcript, checklistItems) {
            if (!checklistItems || checklistItems.length === 0 || !transcript) {
                return [];
            }

            const transcriptLower = transcript.toLowerCase();
            const coverage = [];

            checklistItems.forEach((item, index) => {
                // Extract keywords from checklist item
                const keywords = extractMedicalKeywords(item);

                // Count how many keywords appear in transcript
                const matches = keywords.filter(kw =>
                    transcriptLower.includes(kw.toLowerCase())
                );

                const matchRatio = keywords.length > 0 ? matches.length / keywords.length : 0;

                // Determine status based on match ratio
                let status;
                let confidence;
                if (matchRatio > 0.5) {
                    status = 'likely_covered';
                    confidence = 'LOW';  // Even 50%+ match doesn't guarantee coverage
                } else if (matchRatio > 0.3) {
                    status = 'uncertain';
                    confidence = 'VERY_LOW';
                } else {
                    status = 'likely_missing';
                    confidence = 'MEDIUM';  // Strong signal that it's missing
                }

                coverage.push({
                    index: index,
                    item: item,
                    coverage: matchRatio,
                    status: status,
                    confidence: confidence,
                    matchedKeywords: matches,
                    totalKeywords: keywords.length
                });
            });

            return coverage;
        }

        // ========================================
        // V8 PHASE 3: Hybrid Gap Analysis with Cross-Validation
        // ========================================

        /**
         * Extract gap items from LLM-generated gap-analysis AI_SUGGESTION block
         * @param {string} gapAnalysisContent - Content from gap-analysis AI_SUGGESTION
         * @returns {Object} Parsed gap items { history: [], exam: [], other: [] }
         */
        function parseGapAnalysisContent(gapAnalysisContent) {
            const gaps = {
                history: [],
                exam: [],
                other: []
            };

            // Split into lines and parse
            const lines = gapAnalysisContent.split('\n');
            let currentSection = 'other';

            lines.forEach(line => {
                const trimmed = line.trim();

                // Detect section headers
                if (/missing from history/i.test(trimmed)) {
                    currentSection = 'history';
                } else if (/missing from exam/i.test(trimmed)) {
                    currentSection = 'exam';
                } else if (/missing from assessment/i.test(trimmed) || /missing from plan/i.test(trimmed)) {
                    currentSection = 'other';
                }

                // Extract bullet points or checkbox items
                const itemMatch = trimmed.match(/^[-‚Ä¢*]\s*(.+)$/) || trimmed.match(/^-\s*\[\s*\]\s*(.+)$/);
                if (itemMatch) {
                    const item = itemMatch[1].trim();
                    if (item.length > 0 && !item.startsWith('[') && item !== '[list]') {
                        gaps[currentSection].push(item);
                    }
                }
            });

            return gaps;
        }

        /**
         * Cross-validate LLM gaps against algorithmic analysis
         * Returns hybrid gap report with confidence tiers
         * @param {Object} llmGaps - Parsed LLM gaps { history: [], exam: [], other: [] }
         * @param {Array} algorithmicAnalysis - Coverage analysis from analyzeChecklistCoverage()
         * @returns {Object} Hybrid report with confidence tiers
         */
        function crossValidateGaps(llmGaps, algorithmicAnalysis) {
            const hybridReport = {
                highConfidence: [],    // Both LLM + algorithm agree
                mediumConfidence: [],  // LLM only (algorithm didn't flag)
                lowConfidence: [],     // Algorithm only (likely false positive)
                summary: {
                    totalGaps: 0,
                    llmDetected: 0,
                    algorithmDetected: 0,
                    confirmed: 0
                }
            };

            // Extract all LLM-detected gap text
            const allLLMGaps = [
                ...llmGaps.history.map(g => ({ text: g, section: 'history' })),
                ...llmGaps.exam.map(g => ({ text: g, section: 'exam' })),
                ...llmGaps.other.map(g => ({ text: g, section: 'other' }))
            ];

            hybridReport.summary.llmDetected = allLLMGaps.length;

            // Extract algorithm-flagged items (likely_missing)
            const algoMissing = algorithmicAnalysis.filter(item =>
                item.status === 'likely_missing' && item.coverage < 0.3
            );

            hybridReport.summary.algorithmDetected = algoMissing.length;

            // Cross-validate: Check if LLM gaps match algorithm gaps
            allLLMGaps.forEach(llmGap => {
                const llmKeywords = extractMedicalKeywords(llmGap.text);
                let confirmedByAlgorithm = false;

                // Check if any algorithm-flagged item shares significant keywords with this LLM gap
                for (const algoItem of algoMissing) {
                    const algoKeywords = extractMedicalKeywords(algoItem.item);
                    const commonKeywords = llmKeywords.filter(kw =>
                        algoKeywords.some(ak => ak.toLowerCase() === kw.toLowerCase())
                    );

                    // If >30% keyword overlap, consider confirmed
                    const overlapRatio = llmKeywords.length > 0 ? commonKeywords.length / llmKeywords.length : 0;
                    if (overlapRatio > 0.3) {
                        confirmedByAlgorithm = true;
                        break;
                    }
                }

                if (confirmedByAlgorithm) {
                    // HIGH confidence: Both LLM and algorithm agree
                    hybridReport.highConfidence.push({
                        gap: llmGap.text,
                        section: llmGap.section,
                        source: 'LLM + Algorithm',
                        confidence: 'HIGH',
                        note: 'Confirmed by both semantic (LLM) and keyword (algorithm) analysis'
                    });
                    hybridReport.summary.confirmed++;
                } else {
                    // MEDIUM confidence: LLM detected, but algorithm didn't flag
                    hybridReport.mediumConfidence.push({
                        gap: llmGap.text,
                        section: llmGap.section,
                        source: 'LLM only',
                        confidence: 'MEDIUM',
                        note: 'Detected by LLM semantic analysis, but keywords may be present in transcript'
                    });
                }
            });

            // LOW confidence: Algorithm flagged, but LLM didn't mention
            // These are likely false positives (different terminology used)
            algoMissing.forEach(algoItem => {
                const algoKeywords = extractMedicalKeywords(algoItem.item);
                let mentionedByLLM = false;

                // Check if any LLM gap shares keywords with this algo item
                for (const llmGap of allLLMGaps) {
                    const llmKeywords = extractMedicalKeywords(llmGap.text);
                    const commonKeywords = algoKeywords.filter(ak =>
                        llmKeywords.some(kw => kw.toLowerCase() === ak.toLowerCase())
                    );

                    const overlapRatio = algoKeywords.length > 0 ? commonKeywords.length / algoKeywords.length : 0;
                    if (overlapRatio > 0.3) {
                        mentionedByLLM = true;
                        break;
                    }
                }

                if (!mentionedByLLM) {
                    // Algorithm flagged, but LLM didn't - likely false positive
                    hybridReport.lowConfidence.push({
                        gap: algoItem.item,
                        section: 'checklist',
                        source: 'Algorithm only',
                        confidence: 'LOW',
                        note: `Keyword match: ${(algoItem.coverage * 100).toFixed(0)}%. Likely covered using different terminology.`,
                        keywordMatch: algoItem.coverage
                    });
                }
            });

            hybridReport.summary.totalGaps = hybridReport.highConfidence.length +
                                              hybridReport.mediumConfidence.length +
                                              hybridReport.lowConfidence.length;

            return hybridReport;
        }

        /**
         * Display hybrid gap analysis report in interactive UI
         * @param {Object} hybridReport - Cross-validated gap report
         */
        function displayHybridGapReport(hybridReport) {
            // Check if gap report tab exists, create if not
            let gapTab = document.getElementById('tab-gap-report');
            let gapButton = document.getElementById('gap-report-tab-button');

            if (!gapTab) {
                // Create tab button
                const tabButtons = document.querySelector('.tab-buttons');
                gapButton = document.createElement('button');
                gapButton.className = 'tab-button';
                gapButton.id = 'gap-report-tab-button';
                gapButton.onclick = () => switchTab('gap-report');
                gapButton.innerHTML = 'üîç Gap Analysis';
                tabButtons.appendChild(gapButton);

                // Create tab content
                const outputPanel = document.querySelector('#tab-export').parentElement;
                gapTab = document.createElement('div');
                gapTab.className = 'tab-content';
                gapTab.id = 'tab-gap-report';
                gapTab.style.display = 'none';
                gapTab.innerHTML = `
                    <div style="background: #e7f3ff; padding: 14px; border-radius: 6px; margin-bottom: 20px; color: #004085; border-left: 4px solid #007bff;">
                        <strong>üîç Hybrid Gap Analysis:</strong> Cross-validation of LLM semantic analysis + algorithmic keyword matching.
                    </div>

                    <div id="gapReportSummary" style="background: #f6f8fa; padding: 12px; border-radius: 6px; margin-bottom: 15px; font-size: 0.9rem; color: #24292e; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; border: 1px solid #e1e4e8;">
                    </div>

                    <div style="margin-bottom: 15px; display: flex; gap: 10px; align-items: center;">
                        <input type="text" id="gapSearchBox" placeholder="üîç Search gaps..." style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9rem;">
                        <button onclick="filterGapReport()" style="padding: 8px 16px;">Search</button>
                        <button onclick="clearGapSearch()" style="padding: 8px 16px;">Clear</button>
                    </div>

                    <div id="gapReportContent" style="background: white; padding: 15px; border: 1px solid #e1e4e8; border-radius: 6px; min-height: 400px;">
                    </div>
                `;
                outputPanel.appendChild(gapTab);
                console.log('üîç Gap Report tab created');

                // Attach debounced search listener to input field
                const gapSearchBox = document.getElementById('gapSearchBox');
                if (gapSearchBox) {
                    gapSearchBox.addEventListener('input', debouncedFilterGapReport);
                    console.log('‚úÖ Debounced search attached to gap report');
                }
            }

            // Populate summary
            const summaryDiv = document.getElementById('gapReportSummary');
            summaryDiv.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #d73a49;">${hybridReport.summary.totalGaps}</div>
                    <div style="font-size: 0.85rem; color: #586069;">Total Gaps</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #28a745;">${hybridReport.summary.confirmed}</div>
                    <div style="font-size: 0.85rem; color: #586069;">High Confidence</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #0366d6;">${hybridReport.summary.llmDetected}</div>
                    <div style="font-size: 0.85rem; color: #586069;">LLM Detected</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #6f42c1;">${hybridReport.summary.algorithmDetected}</div>
                    <div style="font-size: 0.85rem; color: #586069;">Algorithm Detected</div>
                </div>
            `;

            // Populate gap report content
            const contentDiv = document.getElementById('gapReportContent');
            let html = '';

            // HIGH confidence section
            if (hybridReport.highConfidence.length > 0) {
                html += `
                    <div class="gap-tier" data-tier="high">
                        <h3 style="color: #d73a49; margin-top: 0; display: flex; align-items: center; gap: 8px;">
                            <span style="background: #d73a49; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem;">HIGH</span>
                            Confirmed Gaps (${hybridReport.highConfidence.length})
                        </h3>
                        <p style="color: #586069; font-size: 0.9rem; margin-bottom: 15px;">
                            ‚ö†Ô∏è These items were flagged by BOTH LLM semantic analysis AND algorithmic keyword matching.
                            High probability of being truly missing from the encounter.
                        </p>
                `;
                hybridReport.highConfidence.forEach((item, idx) => {
                    html += `
                        <div class="gap-item" data-section="${item.section}" style="background: #fff5f5; border-left: 4px solid #d73a49; padding: 12px; margin-bottom: 10px; border-radius: 4px;">
                            <div style="font-weight: bold; color: #24292e; margin-bottom: 4px;">${item.gap}</div>
                            <div style="font-size: 0.85rem; color: #586069;">
                                <span style="background: #f1f8ff; padding: 2px 6px; border-radius: 3px; margin-right: 8px;">Section: ${item.section}</span>
                                <span style="color: #28a745;">‚úì ${item.note}</span>
                            </div>
                        </div>
                    `;
                });
                html += `</div><hr style="margin: 25px 0; border: none; border-top: 2px solid #e1e4e8;">`;
            }

            // MEDIUM confidence section
            if (hybridReport.mediumConfidence.length > 0) {
                html += `
                    <div class="gap-tier" data-tier="medium">
                        <h3 style="color: #e36209; margin-top: 0; display: flex; align-items: center; gap: 8px;">
                            <span style="background: #e36209; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem;">MEDIUM</span>
                            LLM-Detected Gaps (${hybridReport.mediumConfidence.length})
                        </h3>
                        <p style="color: #586069; font-size: 0.9rem; margin-bottom: 15px;">
                            ‚ÑπÔ∏è These items were flagged by LLM semantic analysis but not by keyword matching.
                            May indicate use of different terminology in transcript.
                        </p>
                `;
                hybridReport.mediumConfidence.forEach((item, idx) => {
                    html += `
                        <div class="gap-item" data-section="${item.section}" style="background: #fffbf0; border-left: 4px solid #e36209; padding: 12px; margin-bottom: 10px; border-radius: 4px;">
                            <div style="font-weight: bold; color: #24292e; margin-bottom: 4px;">${item.gap}</div>
                            <div style="font-size: 0.85rem; color: #586069;">
                                <span style="background: #f1f8ff; padding: 2px 6px; border-radius: 3px; margin-right: 8px;">Section: ${item.section}</span>
                                <span>${item.note}</span>
                            </div>
                        </div>
                    `;
                });
                html += `</div><hr style="margin: 25px 0; border: none; border-top: 2px solid #e1e4e8;">`;
            }

            // LOW confidence section (collapsed by default)
            if (hybridReport.lowConfidence.length > 0) {
                html += `
                    <div class="gap-tier" data-tier="low">
                        <h3 style="color: #6a737d; margin-top: 0; display: flex; align-items: center; gap: 8px; cursor: pointer;" onclick="toggleLowConfidenceSection()">
                            <span style="background: #6a737d; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem;">LOW</span>
                            Algorithm-Only Flags (${hybridReport.lowConfidence.length})
                            <span id="lowConfidenceToggle" style="font-size: 0.9rem;">‚ñº</span>
                        </h3>
                        <p style="color: #586069; font-size: 0.9rem; margin-bottom: 15px;">
                            üí° These items were flagged by keyword matching but NOT by LLM semantic analysis.
                            Likely false positives where different terminology was used.
                        </p>
                        <div id="lowConfidenceItems" style="display: none;">
                `;
                hybridReport.lowConfidence.forEach((item, idx) => {
                    html += `
                        <div class="gap-item" data-section="${item.section}" style="background: #f6f8fa; border-left: 4px solid #6a737d; padding: 12px; margin-bottom: 10px; border-radius: 4px;">
                            <div style="font-weight: bold; color: #24292e; margin-bottom: 4px;">${item.gap}</div>
                            <div style="font-size: 0.85rem; color: #586069;">
                                <span style="background: #f1f8ff; padding: 2px 6px; border-radius: 3px; margin-right: 8px;">Section: ${item.section}</span>
                                <span>${item.note}</span>
                            </div>
                        </div>
                    `;
                });
                html += `</div></div>`;
            }

            if (hybridReport.summary.totalGaps === 0) {
                html = `
                    <div style="text-align: center; padding: 40px; color: #28a745;">
                        <div style="font-size: 3rem;">‚úì</div>
                        <h3>No Significant Gaps Detected</h3>
                        <p>All checklist items appear to be adequately addressed in the clinical encounter.</p>
                    </div>
                `;
            }

            contentDiv.innerHTML = html;

            // Store report for filtering
            window.currentHybridReport = hybridReport;

            // Switch to gap report tab
            switchTab('gap-report');
            console.log('‚úÖ Hybrid gap report displayed');
        }

        /**
         * Toggle low confidence section visibility
         */
        function toggleLowConfidenceSection() {
            const section = document.getElementById('lowConfidenceItems');
            const toggle = document.getElementById('lowConfidenceToggle');
            if (section.style.display === 'none') {
                section.style.display = 'block';
                toggle.textContent = '‚ñ≤';
            } else {
                section.style.display = 'none';
                toggle.textContent = '‚ñº';
            }
        }

        /**
         * Filter gap report by search query
         */
        function filterGapReport() {
            const query = document.getElementById('gapSearchBox')?.value.toLowerCase() || '';
            const items = document.querySelectorAll('.gap-item');

            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                if (text.includes(query)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        // Create debounced version for real-time search (300ms delay)
        const debouncedFilterGapReport = debounce(filterGapReport, 300);

        /**
         * Clear gap report search filter
         */
        function clearGapSearch() {
            document.getElementById('gapSearchBox').value = '';
            const items = document.querySelectorAll('.gap-item');
            items.forEach(item => {
                item.style.display = 'block';
            });
        }

        // ========================================
        // V8 PHASE 4: DOAP Compliance Validator + Auto-Regeneration
        // ========================================

        /**
         * Validate DOAP summary against critical safety rules
         * @param {string} doapText - Generated DOAP summary text
         * @returns {Object} Validation result with violations and score
         */
        function validateDOAPCompliance(doapText) {
            const violations = [];
            let score = 100;

            // Split into DOAP sections
            const sections = {
                D: '',
                O: '',
                A: '',
                P: ''
            };

            // Parse DOAP sections (simple heuristic: look for D:, O:, A:, P: or just split by lines)
            const lines = doapText.split('\n');
            let currentSection = null;

            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed.startsWith('D:') || trimmed.startsWith('**D:')) {
                    currentSection = 'D';
                    sections.D += trimmed.replace(/^\*?\*?D:\*?\*?/, '').trim() + ' ';
                } else if (trimmed.startsWith('O:') || trimmed.startsWith('**O:')) {
                    currentSection = 'O';
                    sections.O += trimmed.replace(/^\*?\*?O:\*?\*?/, '').trim() + ' ';
                } else if (trimmed.startsWith('A:') || trimmed.startsWith('**A:')) {
                    currentSection = 'A';
                    sections.A += trimmed.replace(/^\*?\*?A:\*?\*?/, '').trim() + ' ';
                } else if (trimmed.startsWith('P:') || trimmed.startsWith('**P:')) {
                    currentSection = 'P';
                    sections.P += trimmed.replace(/^\*?\*?P:\*?\*?/, '').trim() + ' ';
                } else if (currentSection && trimmed.length > 0) {
                    sections[currentSection] += trimmed + ' ';
                }
            });

            // If no sections found, treat entire text as unsectioned
            const unsectioned = !sections.D && !sections.O && !sections.A && !sections.P;
            if (unsectioned) {
                sections.all = doapText;
            }

            // RULE 1: GCS must have E/V/M components (if GCS mentioned)
            const gcsPattern = /GCS\s*(\d+)/gi;
            const gcsMatches = doapText.match(gcsPattern);
            if (gcsMatches) {
                const hasComponents = /GCS\s*\d+\s*:\s*E\d+V\d+M\d+/i.test(doapText);
                if (!hasComponents) {
                    violations.push({
                        rule: 'GCS Components',
                        severity: 'CRITICAL',
                        message: 'GCS score found without E/V/M components. Must use format "GCS8:E2V2M4"',
                        section: sections.O ? 'O' : 'unknown',
                        fix: 'Add E/V/M components to GCS score'
                    });
                    score -= 15;
                }
            }

            // RULE 2: Laterality required for anatomical findings (if brain/spine mentioned)
            const lateralityKeywords = ['mca', 'aca', 'pca', 'aneurysm', 'lesion', 'tumor', 'hematoma', 'edh', 'sdh', 'hemiparesis', 'hemiplegia', 'weakness'];
            let lateralityMissing = false;
            lateralityKeywords.forEach(keyword => {
                const regex = new RegExp(`\\b${keyword}\\b`, 'i');
                if (regex.test(doapText)) {
                    // Check if L or R appears nearby (within 10 words)
                    const context = doapText.match(new RegExp(`(\\w+\\s+){0,5}${keyword}(\\s+\\w+){0,5}`, 'i'));
                    if (context && !/\b[LR]\b/.test(context[0])) {
                        lateralityMissing = true;
                    }
                }
            });

            if (lateralityMissing) {
                violations.push({
                    rule: 'Laterality',
                    severity: 'CRITICAL',
                    message: 'Anatomical findings lack laterality (L/R) specification',
                    section: sections.O ? 'O' : 'unknown',
                    fix: 'Add L or R before anatomical structures (e.g., "L MCA", "R hemiparesis")'
                });
                score -= 15;
            }

            // RULE 3: Exact measurements required (no "small", "large", "moderate")
            const vagueTerms = ['small', 'large', 'moderate', 'significant', 'considerable'];
            vagueTerms.forEach(term => {
                const regex = new RegExp(`\\b${term}\\b(?!\\s+(\\d+|bowel|vessel|artery))`, 'i');
                if (regex.test(doapText)) {
                    violations.push({
                        rule: 'Exact Measurements',
                        severity: 'CRITICAL',
                        message: `Vague size descriptor "${term}" found. Use exact measurements (mm, cm)`,
                        section: 'multiple',
                        fix: `Replace "${term}" with exact measurement (e.g., "6.8mm" not "small")`
                    });
                    score -= 10;
                }
            });

            // RULE 4: Specific timing required (no "recent", "today", "yesterday")
            const vagueTime = ['recent', 'recently'];
            vagueTime.forEach(term => {
                if (new RegExp(`\\b${term}\\b`, 'i').test(doapText)) {
                    violations.push({
                        rule: 'Specific Timing',
                        severity: 'MAJOR',
                        message: `Vague timing "${term}" found. Use specific time (hours, days, or POD#)`,
                        section: sections.D ? 'D' : 'unknown',
                        fix: `Replace "${term}" with specific timing (e.g., "3h ago", "POD 5")`
                    });
                    score -= 8;
                }
            });

            // RULE 5: Anticoagulation must be in D section
            const anticoagKeywords = ['warfarin', 'plavix', 'aspirin', 'apixaban', 'rivaroxaban', 'dabigatran', 'coagul'];
            let anticoagFound = false;
            anticoagKeywords.forEach(keyword => {
                if (new RegExp(`\\b${keyword}\\b`, 'i').test(doapText)) {
                    anticoagFound = true;
                    // Check if it's in D section
                    if (sections.D && !new RegExp(`\\b${keyword}\\b`, 'i').test(sections.D)) {
                        violations.push({
                            rule: 'Anticoagulation Placement',
                            severity: 'MAJOR',
                            message: `Anticoagulation ("${keyword}") must be in D (Diagnosis) section`,
                            section: 'D',
                            fix: 'Move anticoagulation information to D section'
                        });
                        score -= 10;
                    }
                }
            });

            // RULE 6: Word count limits
            const wordCounts = {
                D: sections.D ? sections.D.split(/\s+/).filter(w => w.length > 0).length : 0,
                O: sections.O ? sections.O.split(/\s+/).filter(w => w.length > 0).length : 0,
                A: sections.A ? sections.A.split(/\s+/).filter(w => w.length > 0).length : 0,
                P: sections.P ? sections.P.split(/\s+/).filter(w => w.length > 0).length : 0
            };

            const limits = { D: 20, O: 35, A: 35, P: 60 };

            Object.keys(limits).forEach(section => {
                if (wordCounts[section] > limits[section]) {
                    violations.push({
                        rule: 'Word Limit',
                        severity: 'MINOR',
                        message: `Section ${section} exceeds word limit: ${wordCounts[section]} words (max ${limits[section]})`,
                        section: section,
                        fix: `Reduce ${section} section to ‚â§${limits[section]} words`
                    });
                    score -= 3;
                }
            });

            // RULE 7: Total word count (120-150 words)
            const totalWords = Object.values(wordCounts).reduce((a, b) => a + b, 0);
            if (totalWords < 120 || totalWords > 150) {
                violations.push({
                    rule: 'Total Word Count',
                    severity: 'MINOR',
                    message: `Total word count ${totalWords} (target: 120-150 words)`,
                    section: 'all',
                    fix: totalWords < 120 ? 'Add more detail to meet 120-word minimum' : 'Condense to stay under 150 words'
                });
                score -= 5;
            }

            // RULE 8: Primary risk must be identified in P section
            if (sections.P && !/PRIMARY\s+RISK|primary\s+risk|highest\s+risk/i.test(sections.P)) {
                violations.push({
                    rule: 'Risk Stratification',
                    severity: 'MAJOR',
                    message: 'P section missing explicit "PRIMARY RISK" identification',
                    section: 'P',
                    fix: 'State "PRIMARY RISK: [specific risk] ‚Üí [mitigation]"'
                });
                score -= 10;
            }

            // Calculate compliance
            const compliance = {
                score: Math.max(0, score),
                isCompliant: score >= 80 && violations.filter(v => v.severity === 'CRITICAL').length === 0,
                violations: violations,
                criticalCount: violations.filter(v => v.severity === 'CRITICAL').length,
                majorCount: violations.filter(v => v.severity === 'MAJOR').length,
                minorCount: violations.filter(v => v.severity === 'MINOR').length,
                sections: sections,
                wordCounts: wordCounts,
                totalWords: totalWords
            };

            return compliance;
        }

        /**
         * Display DOAP compliance validation report
         * @param {Object} compliance - Compliance validation result
         * @param {string} doapText - Original DOAP text
         */
        function displayDOAPComplianceReport(compliance, doapText) {
            const compressOutput = document.getElementById('compressOutput');
            if (!compressOutput) return;

            let reportHTML = `\n\n<!-- DOAP COMPLIANCE REPORT -->\n`;
            reportHTML += `<div style="background: ${compliance.isCompliant ? '#d4edda' : '#f8d7da'}; padding: 15px; border-radius: 6px; margin: 20px 0; border-left: 4px solid ${compliance.isCompliant ? '#28a745' : '#d73a49'};">\n`;
            reportHTML += `<strong>${compliance.isCompliant ? '‚úÖ' : '‚ö†Ô∏è'} DOAP COMPLIANCE SCORE: ${compliance.score}/100</strong>\n`;
            reportHTML += `<div style="margin-top: 10px; font-size: 0.9rem;">\n`;
            reportHTML += `Critical Violations: ${compliance.criticalCount} | `;
            reportHTML += `Major Issues: ${compliance.majorCount} | `;
            reportHTML += `Minor Issues: ${compliance.minorCount}\n`;
            reportHTML += `</div>\n`;

            if (compliance.totalWords > 0) {
                reportHTML += `<div style="margin-top: 8px; font-size: 0.85rem; color: #666;">\n`;
                reportHTML += `Word Count: D(${compliance.wordCounts.D}/20) O(${compliance.wordCounts.O}/35) A(${compliance.wordCounts.A}/35) P(${compliance.wordCounts.P}/60) | Total: ${compliance.totalWords}/120-150\n`;
                reportHTML += `</div>\n`;
            }

            if (compliance.violations.length > 0) {
                reportHTML += `\n<details style="margin-top: 15px;">\n<summary style="cursor: pointer; font-weight: bold;">üìã View ${compliance.violations.length} Violations</summary>\n<div style="margin-top: 10px;">\n`;

                compliance.violations.forEach((v, idx) => {
                    const color = v.severity === 'CRITICAL' ? '#d73a49' : v.severity === 'MAJOR' ? '#e36209' : '#6a737d';
                    reportHTML += `<div style="background: white; border-left: 3px solid ${color}; padding: 10px; margin: 8px 0; border-radius: 3px;">\n`;
                    reportHTML += `<div style="font-weight: bold; color: ${color};">[${v.severity}] ${v.rule}</div>\n`;
                    reportHTML += `<div style="font-size: 0.9rem; margin-top: 4px;">${v.message}</div>\n`;
                    reportHTML += `<div style="font-size: 0.85rem; color: #666; margin-top: 4px;">üí° Fix: ${v.fix}</div>\n`;
                    reportHTML += `</div>\n`;
                });

                reportHTML += `</div>\n</details>\n`;
            } else {
                reportHTML += `\n<div style="margin-top: 10px; color: #28a745;">‚úì No violations detected. Excellent DOAP formatting!</div>\n`;
            }

            reportHTML += `</div>\n<!-- /DOAP COMPLIANCE REPORT -->\n`;

            compressOutput.value += reportHTML;
        }

        /**
         * Auto-regenerate DOAP summary with feedback
         * @param {Object} compliance - Previous compliance result
         * @param {string} clinicalNote - Original clinical note
         * @param {number} attempt - Current attempt number (1-indexed)
         * @returns {Promise<string>} Regenerated DOAP summary
         */
        async function regenerateDOAPWithFeedback(compliance, clinicalNote, attempt = 1) {
            const MAX_ATTEMPTS = 3;

            if (attempt > MAX_ATTEMPTS) {
                console.log(`‚ö†Ô∏è Max regeneration attempts (${MAX_ATTEMPTS}) reached`);
                return null;
            }

            console.log(`üîÑ Attempt ${attempt}/${MAX_ATTEMPTS}: Regenerating DOAP with violation feedback...`);

            // Build feedback prompt
            let feedbackPrompt = `Your previous DOAP summary had ${compliance.violations.length} violations (Score: ${compliance.score}/100). Please regenerate following these corrections:\n\n`;

            compliance.violations.forEach((v, idx) => {
                feedbackPrompt += `${idx + 1}. [${v.severity}] ${v.rule}: ${v.message}\n   Fix: ${v.fix}\n\n`;
            });

            feedbackPrompt += `\nPrevious attempt:\n${compressOutput.value}\n\n`;
            feedbackPrompt += `\nClinical Note:\n${clinicalNote}\n\n`;
            feedbackPrompt += `Generate a corrected DOAP summary addressing ALL violations above.`;

            // Call API with feedback (rate-limited)
            const response = await apiRateLimiter.throttle(async () => {
                return await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: feedbackPrompt }]
                            }],
                            generationConfig: {
                                temperature: 0.3,
                                maxOutputTokens: 4096
                            }
                        })
                    }
                );
            });

            if (!response.ok) {
                console.error('‚ùå Regeneration API error:', response.status);
                return null;
            }

            const data = await response.json();
            const regenerated = data.candidates?.[0]?.content?.parts?.[0]?.text || null;

            if (!regenerated) {
                console.error('‚ùå No regenerated text returned');
                return null;
            }

            console.log(`‚úÖ Attempt ${attempt} regeneration complete`);
            return regenerated;
        }

        // Real-time Red Flag Monitoring
        function checkForRedFlags(text) {
            if (activeRedFlags.length === 0) return;

            const lowerText = text.toLowerCase();
            const detectedFlags = [];

            activeRedFlags.forEach(flag => {
                if (lowerText.includes(flag.toLowerCase())) {
                    detectedFlags.push(flag);
                }
            });

            if (detectedFlags.length > 0) {
                const transcriptArea = document.getElementById('transcript');
                const status = document.getElementById('status');

                // Visual alert
                transcriptArea.style.borderColor = '#DC143C';
                transcriptArea.style.borderWidth = '3px';

                // Update status
                status.className = 'status';
                status.style.background = '#f8d7da';
                status.style.color = '#721c24';
                status.textContent = `üö® RED FLAG DETECTED: ${detectedFlags.join(', ')}`;

                console.warn('üö® RED FLAGS DETECTED:', detectedFlags);

                // Reset border after 5 seconds
                setTimeout(() => {
                    transcriptArea.style.borderColor = '#ddd';
                    transcriptArea.style.borderWidth = '2px';
                    if (isRecording) {
                        status.className = 'status recording';
                        status.textContent = 'üî¥ Recording in progress...';
                    } else {
                        status.className = 'status connected';
                        status.textContent = '‚úÖ Ready to generate';
                    }
                }, 5000);
            }
        }

        async function generate() {
            // V8 MITIGATION: Post-generation BLACKLIST filter (safety net)
            function filterBlacklistTerms(generatedText, sourceText) {
                const blacklistTerms = [
                    // Psychiatric terms
                    'suicidal ideation', 'suicide', 'suicidal thoughts', 'suicidal',
                    'depression', 'depressive', 'depressed',
                    'mental health concerns', 'mental health', 'psychiatric symptoms',
                    'psychological distress', 'anxiety disorder', 'psychosis',
                    'mood disorder', 'bipolar', 'schizophrenia',
                    'substance abuse', 'drug-seeking', 'opioid dependency',
                    // Medications (commonly hallucinated)
                    'propranolol', 'beta-blocker', 'beta blocker',
                    'warfarin', 'anticoagulant', 'anticoagulation',
                    'clopidogrel', 'plavix',
                    'apixaban', 'eliquis',
                    'lisinopril', 'ace inhibitor',
                    'metformin', 'insulin',
                    'sertraline', 'zoloft', 'antidepressant'
                ];

                const sourceLower = sourceText.toLowerCase();
                let filtered = generatedText;
                let removedTerms = [];
                let sentencesRemoved = 0;

                // Check each blacklist term
                blacklistTerms.forEach(term => {
                    const termRegex = new RegExp(`\\b${term}\\b`, 'gi');

                    // If term appears in generated text but NOT in source
                    if (termRegex.test(filtered) && !sourceLower.includes(term.toLowerCase())) {
                        // Remove sentences containing this term
                        // Split by sentence boundaries (. ! ? followed by space or newline)
                        const sentences = filtered.split(/([.!?](?:\s+|\n+))/);
                        const filteredSentences = [];

                        for (let i = 0; i < sentences.length; i++) {
                            const sentence = sentences[i];
                            const hasTerm = termRegex.test(sentence);

                            if (hasTerm && !sentence.match(/^[.!?]\s*$/)) {
                                removedTerms.push(term);
                                sentencesRemoved++;
                                console.warn(`‚ö†Ô∏è [BLACKLIST FILTER] Removed sentence containing: "${term}"`);
                                console.warn(`   Sentence excerpt: "${sentence.substring(0, 100)}..."`);
                                // Skip this sentence (don't add to filtered)
                            } else {
                                filteredSentences.push(sentence);
                            }
                        }

                        filtered = filteredSentences.join('');
                    }
                });

                if (removedTerms.length > 0) {
                    const uniqueTerms = [...new Set(removedTerms)];
                    console.warn(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);
                    console.warn(`‚ïë  üö® BLACKLIST FILTER ACTIVATED - FABRICATIONS REMOVED  ‚ïë`);
                    console.warn(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`);
                    console.warn(`   Removed ${sentencesRemoved} sentence(s) containing ${uniqueTerms.length} blacklisted term(s)`);
                    console.warn(`   Terms removed: ${uniqueTerms.join(', ')}`);
                    console.warn(`   ‚ö†Ô∏è This indicates prompt instructions may need strengthening.`);
                }

                return {
                    filtered,
                    hadFabrications: removedTerms.length > 0,
                    termsRemoved: [...new Set(removedTerms)],
                    sentencesRemoved
                };
            }

            // Detect which input mode is active
            const inputMode = detectActiveInputPanel();

            // Route to appropriate generation function
            if (inputMode === 'soap') {
                // Validate SOAP entry (async - supports parsing in simple mode)
                if (!await validateSOAPEntry()) {
                    return;
                }
                // Call SOAP generation
                await generateFromSOAP();
                return;
            }

            // Continue with transcript mode
            const transcript = document.getElementById('transcript').value.trim();

            if (!transcript) {
                alert('Please enter or record a clinical transcript first');
                return;
            }

            if (!API_KEY) {
                alert('API key not configured.');
                return;
            }

            const btn = document.getElementById('generateBtn');
            const status = document.getElementById('status');
            const output = document.getElementById('output');

            // V6: Reset review state for new generation
            currentSuggestions = [];
            const reviewTabButton = document.getElementById('review-tab-button');
            if (reviewTabButton) {
                reviewTabButton.style.display = 'none';
            }

            btn.disabled = true;
            btn.textContent = '‚è≥ Generating Expert Analysis...';
            status.className = 'status';
            status.style.background = '#d1ecf1';
            status.style.color = '#0c5460';

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // AUTO DEEP SEARCH ACTIVATION LOGIC
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            // STEP 1: Determine reason for consultation
            let currentReason = reasonForConsult.trim();

            // Fallback: Extract from transcript if not manually provided
            if (!currentReason && transcript.length > 50) {
                status.textContent = 'üîç Analyzing consultation reason from transcript...';
                console.log('üìã No manual reason provided, attempting AI extraction...');

                try {
                    currentReason = await extractReasonFromTranscript(transcript);

                    if (currentReason) {
                        reasonForConsult = currentReason;
                        reasonSource = 'extracted';

                        // Update UI field to show extracted reason
                        const reasonField = document.getElementById('reasonForConsult');
                        if (reasonField) {
                            reasonField.value = currentReason;
                            reasonField.style.background = '#FFF9E6'; // Subtle highlight
                        }

                        console.log('‚úÖ Reason extracted and populated:', currentReason);
                    } else {
                        console.log('‚äò Could not extract clear reason from transcript');
                    }
                } catch (error) {
                    console.error('‚ùå Extraction error:', error);
                    // Continue without extraction - not a blocking error
                }
            } else if (currentReason) {
                reasonSource = 'manual';
                console.log('üìã Manual reason provided:', currentReason);
            }

            // STEP 2: Check activation conditions
            const hasReason = currentReason && currentReason.length > 3;
            const noBriefingDone = !generatedBriefing || generatedBriefing.trim().length === 0;
            const noDocsUploaded = uploadedDocuments.length === 0;
            const toggleEnabled = autoDeepSearchEnabled;
            const notAlreadyTriggered = !autoDeepSearchTriggered;

            // STEP 3: Decision gate - all conditions must be true
            const shouldAutoActivate = hasReason && noBriefingDone && noDocsUploaded && toggleEnabled && notAlreadyTriggered;

            // STEP 4: Execute auto-activation if conditions met
            if (shouldAutoActivate) {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('ü§ñ AUTO-ACTIVATION CONDITIONS MET');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('  ‚úì Reason identified:', currentReason);
                console.log('  ‚úì Source:', reasonSource);
                console.log('  ‚úì No pre-briefing detected');
                console.log('  ‚úì No documents uploaded');
                console.log('  ‚úì Toggle enabled');
                console.log('  ‚Üí Triggering Comprehensive deep search (2min)...');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // Set flag to prevent re-triggering
                autoDeepSearchTriggered = true;

                // Store reason as custom pathology for briefing generation
                customPathology = currentReason;
                selectedPathology = ''; // Clear any preset selection

                // Force comprehensive depth for auto-activation
                const depthSelector = document.getElementById('briefingDepth');
                if (depthSelector) {
                    depthSelector.value = 'comprehensive';
                }

                try {
                    // Update status to show auto-activation
                    status.textContent = 'ü§ñ Auto-generating comprehensive briefing for: ' + currentReason;

                    // Trigger deep briefing generation
                    await generateDeepBriefing();

                    // V10: Make enhancement toggle available (but don't auto-enable - user must choose)
                    const enhanceToggle = document.getElementById('transcriptEnhanceToggle');
                    if (enhanceToggle) {
                        enhanceToggle.disabled = false;
                    }

                    // Hide the warning about needing briefing
                    const enhanceWarning = document.getElementById('transcriptEnhanceWarning');
                    if (enhanceWarning) {
                        enhanceWarning.style.display = 'none';
                    }

                    console.log('‚úÖ AUTO-ACTIVATION COMPLETE');
                    console.log('  ‚Üí Briefing generated successfully');
                    console.log('  ‚Üí Enhancement toggle now available (user must enable manually)');
                    console.log('  ‚Üí Enhancement mode enabled');
                    console.log('  ‚Üí Proceeding with expert analysis...');

                } catch (error) {
                    console.error('‚ùå AUTO-ACTIVATION FAILED:', error);
                    console.error('  ‚Üí Error details:', error.message);
                    console.log('  ‚Üí Continuing with standard generation (failsafe)');

                    // Show warning but don't block generation
                    status.textContent = '‚ö†Ô∏è Auto deep search failed, continuing with standard generation';
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Brief pause to show message
                }
            } else {
                // Log why auto-activation was skipped (for debugging)
                if (!hasReason) {
                    console.log('‚äò Auto-activation skipped: No reason identified (field empty & extraction failed)');
                }
                if (!noBriefingDone) {
                    console.log('‚äò Auto-activation skipped: Pre-briefing already exists (using existing briefing)');
                }
                if (!noDocsUploaded) {
                    console.log('‚äò Auto-activation skipped: Documents uploaded (' + uploadedDocuments.length + ' files provide context)');
                }
                if (!toggleEnabled) {
                    console.log('‚äò Auto-activation skipped: Toggle disabled by user preference');
                }
                if (!notAlreadyTriggered) {
                    console.log('‚äò Auto-activation skipped: Already triggered this session');
                }
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // END AUTO-ACTIVATION LOGIC - Continue with normal generation flow
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            // Check if briefing is available for integration
            const hasBriefing = generatedBriefing && generatedBriefing.length > 0;

            // Check enhancement mode toggle
            if (transcriptEnhanceMode && hasBriefing) {
                status.textContent = 'üîÑ Enhanced Mode: Briefing + Transcript ‚Üí Expert Analysis';
            } else {
                status.textContent = 'üîÑ Expand Only: Professional documentation from transcript';
            }

            try {
                let prompt;

                if (transcriptEnhanceMode && hasBriefing) {
                    // EXPERT MODE: Integrated briefing + transcript analysis (toggle ON + briefing available)
                    const pathologyData = selectedPathology ? PathologyDatabase[selectedPathology] : null;
                    const pathologyName = customPathology || (pathologyData ? pathologyData.name : 'Unknown');

                    // Build scale assessment section
                    let scaleAssessmentSection = '';
                    if (pathologyData && pathologyData.recommendedScales && pathologyData.recommendedScales.length > 0) {
                        const scaleNames = pathologyData.recommendedScales
                            .map(id => ClinicalScalesDatabase[id]?.shortName || id)
                            .join(', ');

                        scaleAssessmentSection = `\n### üìã Clinical Scales Assessment:\nRecommended scales for this pathology: ${scaleNames}\n\nFor each recommended scale, assess which components were addressed in the transcript and which are missing:\n`;

                        for (const scaleId of pathologyData.recommendedScales) {
                            const scale = ClinicalScalesDatabase[scaleId];
                            if (scale) {
                                scaleAssessmentSection += `\n**${scale.shortName}** (${scale.name}):\n`;
                                for (const q of scale.questions) {
                                    const questionText = q.text.length > 80 ? q.text.substring(0, 80) + '...' : q.text;
                                    scaleAssessmentSection += `- [ ] ${questionText}\n`;
                                }
                            }
                        }

                        scaleAssessmentSection += `\n‚ö†Ô∏è MISSING INFORMATION TO OBTAIN:\n[List specific scale questions that were NOT addressed in transcript and should be asked during follow-up]\n`;
                    }

                    prompt = `You are an expert neurosurgical consultant. Create a comprehensive consultation note from the transcript AND provide expert clinical analysis.

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  ‚õî‚õî‚õî ABSOLUTE FIREWALL RULE - READ THIS FIRST ‚õî‚õî‚õî                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üö® CRITICAL: BRIEFING vs CLINICAL NOTE SEPARATION

You will receive TWO types of information:
1. **PRE-CONSULTATION BRIEFING** = Background reference knowledge ONLY
2. **CLINICAL ENCOUNTER TRANSCRIPT** = Your ONLY source of documented facts

üõ°Ô∏è ABSOLUTE FIREWALL BETWEEN BRIEFING AND CLINICAL NOTE:

**BRIEFING PURPOSE**: Medical reference for understanding the condition
- Contains general red flags to be AWARE of (NOT to fabricate if absent)
- Contains typical exam findings (NOT to assume were performed)
- Contains standard workup options (NOT to recommend unless documented)
- Contains checklists (for gap analysis ONLY, not for fabrication)

**CLINICAL NOTE PURPOSE**: Document ONLY what was explicitly stated in the encounter
- Include ONLY findings mentioned by patient/clinician
- Document ONLY examinations that were performed
- Note ONLY symptoms that were reported
- Record ONLY discussions that actually occurred

‚õî THE BRIEFING MUST NEVER CONTAMINATE THE CLINICAL NOTE ‚õî

**PROHIBITED CONTAMINATION EXAMPLES:**
‚ùå Briefing mentions "screen for suicidal ideation" ‚Üí You add it to red flags
‚ùå Briefing lists "assess cranial nerves" ‚Üí You mark as "not documented"
‚ùå Briefing suggests "MRI brain" ‚Üí You recommend it without clinical indication
‚ùå Briefing has checklist item ‚Üí You populate it even if not mentioned in transcript

**CORRECT USAGE:**
‚úÖ Briefing mentions red flag ‚Üí Use ONLY if transcript mentions it
‚úÖ Briefing suggests exam ‚Üí Use ONLY if transcript shows it was done
‚úÖ Briefing lists checklist item ‚Üí Note in gap-analysis if missing, don't fabricate
‚úÖ Briefing provides context ‚Üí Use to understand, not to add facts

üîí THIS RULE OVERRIDES ALL OTHER INSTRUCTIONS, INCLUDING CHECKLIST COMPLETION.

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  ‚úÖ MANDATORY GROUND TRUTH RULE - TRANSCRIPT IS YOUR ONLY SOURCE    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Your ONLY source of truth is the transcript below. You MUST NOT add ANY information that is not explicitly stated in the transcript.

**WHITELIST - ONLY include information that is:**
1. **Verbatim**: Text appears word-for-word in transcript
2. **Measured**: Numerical values stated by patient or clinician (pain scores, vital signs)
3. **Observed**: Exam findings explicitly documented
4. **Stated**: Patient complaints directly quoted or paraphrased from transcript

‚õî BLACKLIST - NEVER include if NOT documented (automatic exclusion):
1. **Psychiatric symptoms**: depression | suicidal ideation | suicide | anxiety | psychosis | mental health concerns | psychological distress
   - If transcript says "severe pain affecting mood" ‚Üí DO NOT infer "suicidal ideation"
   - If transcript says "chronic severe pain" ‚Üí DO NOT add "depression" or "psychological impact"
   - If transcript mentions "pain is unbearable" ‚Üí DO NOT add psychiatric diagnoses
2. **Social history**: smoking | alcohol use | drug use | employment status | living situation | marital status
3. **Family history**: genetic conditions | family medical problems | hereditary diseases
4. **Medications**: ANY medications not explicitly mentioned in transcript
5. **Exam findings**: ANY exam element not performed and documented in transcript
6. **Lab/Imaging values**: ANY results not provided with exact values
7. **Temporal details**: ANY timeline not explicitly stated

üö´ PROHIBITED CLINICAL INFERENCES:
- "Severe chronic pain" ‚Üí DO NOT infer "suicidal ideation", "depression", "affecting mental health"
- "Patient distressed about condition" ‚Üí DO NOT add psychiatric diagnoses or mood disorders
- "Pain impacts quality of life" ‚Üí DO NOT add "suicidal thoughts" or psychological symptoms
- "Failed multiple treatments" ‚Üí DO NOT infer psychological desperation or mental health crisis

‚ö†Ô∏è RED FLAG DETECTION RULE (PREVENTIVE - 3-STEP PROCESS):

**BEFORE writing ANY red flag in your analysis, follow these steps:**

**STEP 1 - TRANSCRIPT VERIFICATION:**
Ask yourself: "Was this red flag EXPLICITLY MENTIONED in the transcript?"
- Did the patient SAY this symptom/concern?
- Did the clinician DOCUMENT this finding?
- Can I quote the EXACT WORDS from the transcript?

‚ùå If answer is NO ‚Üí STOP. Do not include this red flag. Move to next item.
‚úÖ If answer is YES ‚Üí Proceed to Step 2.

**STEP 2 - SOURCE GROUNDING:**
Quote the evidence with attribution:
- Format: "Patient states: '[exact quote from transcript]'"
- Format: "Examination revealed: '[documented finding]'"
- Format: "Clinician noted: '[direct observation]'"

**STEP 3 - PROHIBITED INFERENCE CHECK:**
Verify you are NOT making these prohibited inferences:
‚ùå "Severe pain" ‚Üí inferring "suicidal ideation" or "depression"
‚ùå "Chronic pain" ‚Üí inferring "mental health screening needed"
‚ùå "Failed treatments" ‚Üí inferring "psychological desperation"
‚ùå "Patient distressed" ‚Üí inferring psychiatric diagnoses

**BRIEFING CHECKLIST OVERRIDE RULE:**
If the briefing checklist mentions ANY red flag (psychiatric or otherwise):
‚Üí These are EXCLUDED from your red flag analysis UNLESS quoted from transcript
‚Üí Do not mark as "Cannot exclude - not assessed"
‚Üí Do not recommend screening
‚Üí Do not add to "MUST-NOT-MISS" section
‚Üí OMIT entirely if not in transcript

**THE ONLY RED FLAGS YOU MAY INCLUDE:**
‚úÖ Neurological red flags with direct transcript evidence
‚úÖ Symptoms explicitly reported by patient
‚úÖ Findings explicitly documented by clinician
‚úÖ Concerns explicitly raised in the encounter

CRITICAL RULE: If information is ABSENT from transcript ‚Üí It MUST be ABSENT from your analysis.

üè∑Ô∏è INFERENCE TRANSPARENCY REQUIREMENTS:
When you synthesize or infer clinical information (even if clinically reasonable), mark it explicitly:
- Use "[INFERRED]" tag for any content NOT explicitly stated in transcript
- Provide rationale: "[INFERRED - reason for inference]"
- Examples of when to use [INFERRED]:
  * Clinical associations: "[INFERRED - commonly associated with this condition]"
  * Pattern recognition: "[INFERRED from symptom pattern]"
  * Timeline synthesis: "[INFERRED from reported sequence]"
  * Anatomical relationships: "[INFERRED - typical nerve distribution]"
  * Mechanism of injury: "[INFERRED - consistent with mechanism described]"
- Format: Include marker WITHIN the content where inference occurs
- Example: "Pain likely follows V1 distribution [INFERRED - not explicitly mapped in exam]"
- Documented facts need NO marker - only inferred/synthesized content
- This maintains clinical reasoning transparency while preserving professional quality

CRITICAL STRUCTURE REQUIREMENTS:

## SECTION 1: DOCUMENTED CONVERSATION
Start with what was actually said in the encounter:
üìù DOCUMENTED: [Professional narrative of the actual conversation - NO additions]

## SECTION 2: AI-GENERATED EXPERT ANALYSIS
After documented content, provide expert analysis wrapped in AI_SUGGESTION markers.

MARKER FORMAT EXAMPLES:

<!-- AI_SUGGESTION type="clinical-analysis" id="analysis-001" category="subjective" depends-on="" -->
ü§ñ CLINICAL ANALYSIS:
[Your expert interpretation of symptoms, patterns, temporal relationships]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="clinical-reasoning" id="reasoning-001" category="assessment" depends-on="analysis-001" -->
üß† DIAGNOSTIC REASONING:

**Hypothesis Generation:**
- Initial differential based on chief complaint: [List 3-5 hypotheses]
- Pre-test probabilities ranked: [Most likely ‚Üí Least likely with rationale]

**Data Interpretation:**
- Key positive findings supporting diagnosis:
  ‚Ä¢ [Finding 1] - Weight: High/Moderate/Low (likelihood ratio +X.X)
  ‚Ä¢ [Finding 2] - Weight: High/Moderate/Low
  ‚Ä¢ [Finding 3] - Weight: High/Moderate/Low
- Key negative findings against alternatives:
  ‚Ä¢ [Negative finding 1] - Rules out: [Alternative diagnosis]
  ‚Ä¢ [Negative finding 2] - Makes unlikely: [Alternative diagnosis]
- Discriminating features present: [Findings that narrow differential]

**Bayesian Reasoning:**
- Findings that significantly INCREASE probability:
  ‚Ä¢ [Finding] ‚Üí Increases likelihood by [X]% (LR+ = X.X)
  ‚Ä¢ [Finding] ‚Üí Strongly supports [diagnosis] (LR+ = X.X)
- Findings that significantly DECREASE probability:
  ‚Ä¢ [Absence of finding] ‚Üí Decreases likelihood by [X]% (LR- = 0.X)
  ‚Ä¢ [Negative finding] ‚Üí Argues against [diagnosis] (LR- = 0.X)

**Diagnostic Threshold Assessment:**
- Test threshold reached: [Yes/No with explanation]
  ‚Üí Additional testing needed: [Yes/No - specify tests]
- Treatment threshold reached: [Yes/No with explanation]
  ‚Üí Sufficient certainty to treat empirically: [Yes/No]
- Certainty level: [High (>90%) / Moderate (70-90%) / Low (<70%)]
  ‚Üí Basis for certainty: [Explain reasoning]

**Clinical Synthesis:**
[Summarize diagnostic reasoning in 2-3 sentences showing logical progression from symptoms ‚Üí findings ‚Üí diagnosis]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="differential" id="diff-001" category="assessment" depends-on="analysis-001,reasoning-001" -->
ü§ñ SYSTEMATIC DIFFERENTIAL DIAGNOSIS:

**PRIMARY DIAGNOSIS:**
1. **[Most Likely Diagnosis]** - Confidence: [High/Moderate/Low] ([X]%)
   - Supporting features (present):
     ‚Ä¢ [Feature 1 with specificity/sensitivity data]
     ‚Ä¢ [Feature 2]
     ‚Ä¢ [Feature 3]
   - Discriminating features: [Findings that distinguish from alternatives]
   - Epidemiological fit: [Age/gender/risk factor concordance - relevant/not relevant]
   - Timeline consistency: [Natural history alignment - consistent/atypical]
   - Against: [Any contradicting findings that don't fit]
   - Evidence base: [Cite relevant guidelines/studies if applicable]

**ALTERNATIVE DIAGNOSES (Ranked by Likelihood):**
2. **[Alternative 1]** - Confidence: [X]%
   - Why considered: [Key overlapping clinical features]
   - Why less likely: [Discriminating negatives or timeline issues]
   - Rule-out criteria: [What specific findings would exclude this diagnosis]

3. **[Alternative 2]** - Confidence: [X]%
   - Why considered: [Overlapping features]
   - Why less likely: [Key differences]
   - Rule-out criteria: [Exclusion criteria]

**MUST-NOT-MISS DIAGNOSES** (ONLY if discussed in transcript):
‚ùó **[Dangerous diagnosis]** - Status: [Ruled out / Unlikely / Cannot exclude]
   - Ruled out by: [Specific findings/tests from transcript]
   - Evidence from transcript: "[Direct quote showing this was addressed]"

‚ö†Ô∏è CRITICAL: ONLY include dangerous diagnoses that were DISCUSSED in the encounter.
If no must-not-miss diagnoses were mentioned ‚Üí write: "No critical differential diagnoses were specifically addressed in this encounter."

DO NOT populate this section with briefing items that were not discussed.

**RED FLAG DIFFERENTIAL** (ONLY include red flags DOCUMENTED in transcript):
‚ö†Ô∏è Life-threatening conditions that WERE addressed in this encounter:
- [ ] [Condition] - Status: [Ruled out / Possible / Confirmed]
      Evidence from transcript: "[Direct quote: patient/clinician statement]"
      Clinical basis: [Exam findings or test results that were documented]

‚ö†Ô∏è CRITICAL: If NO red flag symptoms were mentioned in the transcript ‚Üí write:
"No acute red flag symptoms were documented in this encounter."

DO NOT add red flags from briefing checklist. Only document red flags explicitly mentioned by patient or assessed by clinician.

**NEXT DIAGNOSTIC STEPS TO NARROW DIFFERENTIAL:**
- If [specific clinical finding present], then [specific action to favor diagnosis A over B]
- If [test result X], strongly favors [diagnosis Y] over [diagnosis Z] (sensitivity/specificity data)
- Key discriminating test needed: [Test name] - will differentiate between [diagnosis A vs B]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="red-flag" id="alert-001" category="assessment" depends-on="" -->
‚ö†Ô∏è RED FLAG ALERT (ONLY if critical findings DOCUMENTED in transcript):
[Critical findings requiring immediate attention - MUST have supporting direct quotes from transcript]

‚ö†Ô∏è INCLUDE THIS BLOCK ONLY IF: Patient/clinician mentioned red flag symptoms in transcript
‚ö†Ô∏è OMIT THIS BLOCK IF: No red flags were discussed (even if briefing lists them as concerns to screen)

Evidence required: "[Direct quote from transcript showing red flag was present]"
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="gap-analysis" id="gap-001" category="assessment" depends-on="" -->
ü§ñ CLINICAL GAPS IDENTIFIED:
Missing from history: [list]
Missing from exam: [list from briefing checklist]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="workup" id="workup-001" category="plan" depends-on="diff-001" -->
üî¨ RECOMMENDED DIAGNOSTIC WORKUP:
### Immediate/Urgent:
- [Studies with rationale]
### Standard:
- [Routine investigations from briefing]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="recommendation" id="rec-001" category="plan" depends-on="diff-001,workup-001" -->
üíä EVIDENCE-BASED MANAGEMENT PLAN:
### Conservative:
- [Options with evidence levels from briefing]
### Surgical Considerations:
- [If indications met per briefing]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="scales" id="scales-001" category="objective" depends-on="" -->
üìè CLINICAL SCALES ASSESSMENT:
${scaleAssessmentSection}
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="pearl" id="pearl-001" category="assessment" depends-on="" -->
üí° CLINICAL PEARL:
[Expert insight relevant to this presentation]
üìä Evidence Level: [I/II/III/IV from briefing]
<!-- /AI_SUGGESTION -->

MARKER RULES:
1. **Every AI-generated insight MUST be wrapped** in AI_SUGGESTION markers
2. **Use type attribute**: clinical-analysis, differential, recommendation, pearl, red-flag, gap-analysis, workup, scales
3. **Unique ID**: Use format type-### (e.g., diff-001, rec-002)
4. **Category**: subjective, objective, assessment, plan
5. **depends-on**: Comma-separated parent IDs if suggestion builds on others (empty string if independent)
6. **DO NOT wrap** üìù DOCUMENTED sections - only AI additions

=== PRE-CONSULTATION BRIEFING ===
${generatedBriefing}

${(() => {
    // V8 MITIGATION: Inject checklist gap analysis
    let gapSection = '';

    if (briefingChecklist && briefingChecklist.length > 0) {
        // Get manual checkbox status
        const manualGaps = getChecklistGapSummary();

        // Get algorithmic coverage analysis
        const algorithmicAnalysis = analyzeChecklistCoverage(transcript, briefingChecklist);

        // V8 PHASE 3: Store for hybrid gap analysis
        checklistCoverageAnalysis = algorithmicAnalysis;

        const likelyMissing = algorithmicAnalysis.filter(item =>
            item.status === 'likely_missing' && item.coverage < 0.3
        );

        gapSection += '\n=== V8 CHECKLIST GAP ANALYSIS ===\n\n';

        // Manual tracking summary
        if (Object.keys(checklistState).length > 0) {
            gapSection += `**MANUAL CHECKLIST STATUS:**\n`;
            gapSection += `Coverage: ${manualGaps.completed}/${manualGaps.total} items addressed (${manualGaps.percentComplete}%)\n\n`;

            if (manualGaps.missing.length > 0) {
                gapSection += `**Items NOT checked by clinician (${manualGaps.missing.length}):**\n`;
                manualGaps.missing.slice(0, 10).forEach(item => {
                    gapSection += `- [ ] ${item}\n`;
                });
                if (manualGaps.missing.length > 10) {
                    gapSection += `... and ${manualGaps.missing.length - 10} more\n`;
                }
                gapSection += '\n';
            }
        }

        // Algorithmic analysis
        if (likelyMissing.length > 0) {
            gapSection += `**ALGORITHMIC DETECTION - LIKELY MISSING (coverage <30%):**\n`;
            likelyMissing.slice(0, 10).forEach(item => {
                gapSection += `- [ ] ${item.item} (${(item.coverage * 100).toFixed(0)}% keyword match)\n`;
            });
            if (likelyMissing.length > 10) {
                gapSection += `... and ${likelyMissing.length - 10} more\n`;
            }
            gapSection += `\n‚ö†Ô∏è NOTE: These items had <30% keyword match with transcript. Verify if truly missing vs mentioned with different terminology.\n\n`;
        }

        gapSection += `**YOUR TASK FOR GAP ANALYSIS:**\n`;
        gapSection += `1. Review unchecked items above\n`;
        gapSection += `2. Check if they were addressed in transcript (search for semantic equivalents)\n`;
        gapSection += `3. In your gap-analysis AI_SUGGESTION block, list items that are TRULY missing\n`;
        gapSection += `4. Do NOT flag items that were covered using different wording\n\n`;
    }

    return gapSection;
})()}

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  üõ°Ô∏è HOW TO USE THE BRIEFING (CRITICAL INSTRUCTIONS)                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

The briefing above is REFERENCE MATERIAL for your expert analysis (AI_SUGGESTION blocks).
It must NEVER contaminate the üìù DOCUMENTED clinical note section.

‚úÖ **CORRECT BRIEFING USAGE** (in AI_SUGGESTION blocks only):
1. **Completeness check**: Compare transcript vs briefing checklist ‚Üí note gaps in gap-analysis suggestion
2. **Red flags**: ONLY include red flags that were DOCUMENTED in transcript
   - If briefing mentions "suicidal ideation" but transcript is silent ‚Üí OMIT entirely (do NOT add to analysis)
   - If briefing mentions "cauda equina" and transcript mentions it ‚Üí Document with evidence
3. **Workup recommendations**: ONLY recommend if clinically indicated by DOCUMENTED findings
   - Not: "Briefing says order MRI" ‚Üí You recommend MRI
   - But: "Patient has progressive weakness (documented) ‚Üí MRI indicated per guidelines"
4. **Management guidelines**: Use briefing context to inform recommendations for DOCUMENTED conditions only

‚ùå **PROHIBITED - These actions will be flagged as FABRICATION:**
- Transferring briefing checklist items into clinical note when NOT mentioned in transcript
- Adding red flags from briefing that patient/clinician did NOT discuss
- Marking briefing exam items as "not documented" when they were never discussed
- Recommending workup for conditions mentioned in briefing but NOT present in patient
- Populating "MUST-NOT-MISS" sections with briefing items when transcript is silent

üéØ **GOLDEN RULE FOR RED FLAGS:**
- Briefing red flag + Transcript silent = OMIT from analysis (do not mention at all)
- Briefing red flag + Transcript mentions it = Document with direct quotes from transcript
- Transcript mentions concern NOT in briefing = Document it (transcript trumps briefing)

üéØ **PRIORITY HIERARCHY:**
1. **HIGHEST**: Document what's in transcript (even if not in briefing)
2. **MEDIUM**: Note gaps where briefing suggests something should be assessed but wasn't (gap-analysis block only)
3. **LOWEST**: Do NOT fabricate briefing content into clinical findings

=== CLINICAL ENCOUNTER TRANSCRIPT ===
${transcript}

---
CONTEXT:
- Pathology Context: ${pathologyName}
- Evidence Base: Pre-consultation briefing available

ANTI-HALLUCINATION RULES:
‚úÖ Document actual conversation professionally in üìù DOCUMENTED
‚úÖ Provide expert analysis in marked AI_SUGGESTION blocks
‚úÖ Use briefing to inform analysis
‚úÖ Mark all suggestions properly with correct attributes
‚úÖ Link related suggestions with depends-on

‚ùå DO NOT add facts to üìù DOCUMENTED
‚ùå DO NOT modify what was actually said
‚ùå DO NOT forget markers on AI suggestions
‚ùå DO NOT create suggestions without proper type, id, category

Generate the comprehensive note with proper markers:`;

                } else {
                    // EXPAND ONLY MODE: Simple documentation (toggle OFF or no briefing)

                    // Check consultation type for appropriate prompt
                    if (consultationType === 'followup') {
                        // FOLLOW-UP VISIT EXPAND ONLY PROMPT
                        prompt = `You are a medical documentation assistant. Convert this follow-up visit transcript into professional clinical documentation.

CRITICAL RULES - WHAT YOU MUST DO:
‚úÖ Expand transcript into proper medical narrative format
‚úÖ Organize into standard follow-up visit structure
‚úÖ Use correct medical terminology and grammar
‚úÖ Expand common abbreviations appropriately

CRITICAL RULES - WHAT YOU MUST NOT DO:
‚ùå DO NOT add medical facts, symptoms, or findings not in transcript
‚ùå DO NOT infer or assume clinical information
‚ùå DO NOT add differential diagnoses beyond what clinician stated
‚ùå DO NOT add treatment recommendations not discussed
‚ùå DO NOT add examination findings not documented
‚ùå If information not mentioned, note "[Not documented]"

PROFESSIONAL LANGUAGE REQUIREMENTS:
‚úÖ Use precise medical terminology (avoid colloquialisms like "guy came in with")
‚úÖ Write in complete, grammatically correct sentences with proper medical narrative structure
‚úÖ Use standard medical abbreviations from Joint Commission approved list ONLY
‚úÖ Avoid ambiguous pronouns - use "the patient" consistently (not "he/she/they")
‚úÖ Use objective descriptors with measurements (not "seems somewhat" or "appears pretty")
‚úÖ Quantify whenever possible: pain 7/10 (not "severe pain"), weakness 4/5 (not "weak")
‚úÖ Use present tense for current status, past tense for historical information
‚úÖ Maintain professional clinical tone throughout (not conversational or casual)
‚úÖ Use patient-centered, non-stigmatizing language
‚ùå DO NOT use: casual language, ambiguous descriptors, dangerous abbreviations
‚ùå DO NOT use: judgmental language ("non-compliant" ‚Üí "did not adhere to treatment")
‚ùå DO NOT use: stigmatizing terms ("drug-seeking", "frequent flyer")

FOLLOW-UP VISIT FOCUS:
- Frame as INTERVAL HISTORY (changes since last visit)
- Document treatment response from transcript only
- Compare to baseline only if mentioned in transcript

# NEUROSURGICAL FOLLOW-UP NOTE

## INTERVAL HISTORY
[Document changes since last visit: symptoms better/worse/same, new developments, complications, medication compliance, therapy adherence]

## CURRENT SYMPTOMS
[Current symptom status with comparison to baseline if mentioned]
- Pain level: [Current vs previous]
- Functional status: [Current vs previous]
- New symptoms: [If any]

## MEDICATIONS & TREATMENTS
[Current medications with compliance, any changes, response to therapy]

## PHYSICAL EXAMINATION
**Updated Examination Findings:**
[Focus on relevant changes; state "unchanged from previous" if applicable]
- Neurological Examination:
  - Mental Status: [if assessed]
  - Motor: [any changes in strength, tone]
  - Sensory: [any changes]
  - Reflexes: [if assessed]
  - Gait: [if assessed]
  - Special tests: [if performed]

## DIAGNOSTIC RESULTS
[New imaging, labs, or studies since last visit with interpretation]

## ASSESSMENT
[Current status from transcript - improved/stable/worsened]
[Clinician's stated assessment from transcript only]

## PLAN
[Plan modifications from transcript ONLY - what was discussed]

## ICD-10 CODES
[Only if diagnosis clearly stated]

FINAL CHECK - CRITICAL:
‚úì Used ONLY information explicitly in transcript
‚úì Added NO medical facts or clinical information
‚úì Added NO treatment recommendations not discussed
‚úì Compared to baseline ONLY if mentioned in transcript
‚úì Professional language and organization from transcript content only

Transcript:
${transcript}`;

                    } else {
                        // NEW CONSULTATION EXPAND ONLY PROMPT
                        prompt = `You are a medical documentation assistant. Convert this clinical consultation transcript into professional clinical documentation.

CRITICAL RULES - WHAT YOU MUST DO:
‚úÖ Extract all information from transcript systematically
‚úÖ Organize into proper SOAP/consultation format
‚úÖ Use correct medical terminology and grammar
‚úÖ Expand common abbreviations appropriately
‚úÖ Maintain chronological narrative in HPI

CRITICAL RULES - WHAT YOU MUST NOT DO:
‚ùå DO NOT add medical facts, symptoms, or findings not in transcript
‚ùå DO NOT infer or assume clinical information
‚ùå DO NOT add differential diagnoses beyond what clinician stated
‚ùå DO NOT add workup studies not discussed in transcript
‚ùå DO NOT add treatment recommendations not mentioned
‚ùå DO NOT add examination findings not documented
‚ùå If information not mentioned, note "[Not documented]"

EXTRACTION REQUIREMENTS:
- Extract EVERY clinical detail mentioned in transcript
- Quantify when possible (pain scores, duration, frequency, ranges)
- Note temporal patterns (onset, progression, alleviating/aggravating factors)
- Document all examination findings with precise descriptions
- Identify any red flags or concerning features
- Note information gaps that should be obtained

üìã CHIEF COMPLAINT FORMATTING RULES:
- START with clinical summary using precise anatomical/pathological terminology
- END with direct patient quote if emotionally significant (conveys severity, urgency, or quality of life impact)
- Format when quote present: [Clinical summary]. Patient states, "[Direct verbatim quote]."
- Prioritize quotes expressing:
  * Pain severity or character ("worst pain of my life", "unbearable")
  * Functional impact ("can't work", "can't sleep", "can't take care of my kids")
  * Emotional distress or urgency ("I can't live like this", "something is very wrong")
  * Duration or progression concerns ("getting worse every day")
- ONLY include quotes that are VERBATIM from transcript
- If no emotionally significant quote exists, use clinical summary alone

üîç PHYSICAL EXAMINATION DOCUMENTATION REQUIREMENTS:
- Document ALL examination elements that were performed with findings
- For examination elements NOT performed or NOT mentioned in transcript:
  * Explicitly state "not documented" for that element
  * Example: "Cranial Nerves: not documented"
  * Example: "Cerebellar: not documented"
- This maintains professional documentation standards and medicolegal clarity
- Never leave exam subsections blank or omit them - always document presence or absence of findings
- Complete documentation: Shows thoroughness and identifies information gaps

üìù PLAN SECTION FORMATTING REQUIREMENTS:
- Structure the plan with SPECIFIC, ACTIONABLE steps (avoid vague statements)
- Include TIMELINES when discussed: "2 weeks post-op", "next clinic visit in 1 month"
- Document PATIENT EDUCATION topics covered: warning signs, activity restrictions, expectations
- Address PATIENT QUESTIONS/CONCERNS if discussed in transcript
- For surgical cases: Include post-operative expectations, recovery timeline, restrictions
- Format subsections: Immediate Management, Diagnostic Studies, Surgical Planning, Post-Op Expectations, Follow-Up, Patient Education, Questions Addressed
- If detailed plan not discussed: Use summary format "Management plan as discussed"
- Goal: Create actionable roadmap for patient and care team

# NEUROSURGICAL CONSULTATION NOTE

## CHIEF COMPLAINT
[Clinical summary using anatomical terminology. Add patient quote if emotionally significant: Patient states, "[Direct quote]."]

## HISTORY OF PRESENT ILLNESS
[Comprehensive narrative including: onset, location, duration, character, alleviating/aggravating factors, radiation, temporal pattern, associated symptoms, treatments tried, functional impact]

## PAST MEDICAL HISTORY
[List all conditions mentioned]

## PAST SURGICAL HISTORY
[List all surgeries with approximate dates if provided]

## MEDICATIONS
[List all medications with dosages if mentioned]

## ALLERGIES
[List drug/environmental allergies and reactions]

## PHYSICAL EXAMINATION
- **Vital Signs:** [Extract if mentioned, otherwise state "not documented"]
- **General Appearance:** [Patient's overall presentation if described, otherwise "not documented"]
- **Neurological Examination:**
  - Mental Status: [Orientation, attention, memory if assessed, otherwise "not documented"]
  - Cranial Nerves: [I-XII assessment results if performed, otherwise "not documented"]
  - Motor: [Strength by muscle group, tone, bulk if examined, otherwise "not documented"]
  - Sensory: [Modalities tested and distributions if assessed, otherwise "not documented"]
  - Reflexes: [DTRs, pathological reflexes if tested, otherwise "not documented"]
  - Cerebellar: [Coordination, dysmetria if examined, otherwise "not documented"]
  - Gait: [Pattern, stability, aids needed if observed, otherwise "not documented"]

## DIAGNOSTIC RESULTS
[Imaging, labs, EMG/NCS - extract findings if discussed]

## ASSESSMENT
[Clinician's stated diagnosis/impression from transcript - DO NOT add differential unless clinician discussed it]

## PLAN
[Structure the management plan with specific, actionable steps if discussed:]
- **Immediate Management:** [Specific actions, medications, interventions if stated]
- **Diagnostic Studies:** [Ordered tests with indication and timeline if mentioned]
- **Surgical Planning:** [Procedure details, timing, pre-op requirements if discussed]
- **Post-Operative Expectations:** [Recovery timeline, restrictions, milestones if addressed]
- **Follow-Up:** [Specific appointments with timeframe: "2 weeks post-op", "1 month clinic visit"]
- **Patient Education:** [Specific topics discussed: warning signs, activity restrictions, expectations]
- **Questions/Concerns Addressed:** [Document patient questions and clinician responses if discussed]
[If plan not detailed in transcript, provide summary: "Management plan as discussed"]

## ICD-10 CODES
[Only if diagnosis clearly stated in transcript]

FINAL CHECK - CRITICAL:
‚úì Used ONLY information explicitly in transcript
‚úì Added NO medical facts, symptoms, or findings
‚úì Added NO differential diagnoses unless clinician stated them
‚úì Added NO treatment recommendations not discussed
‚úì Professional language and organization from transcript content only

Transcript:
${transcript}`;
                    }
                }

                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.4,  // Balanced: Maintains accuracy while improving narrative flow
                                maxOutputTokens: hasBriefing ? 16384 : 8192  // Double tokens for integrated analysis
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                let generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';

                // ============================================================
                // V8 MITIGATION: Apply BLACKLIST filter (safety net)
                // ============================================================
                console.log('üõ°Ô∏è Applying post-generation BLACKLIST filter...');
                const filterResult = filterBlacklistTerms(generatedText, transcript);
                if (filterResult.hadFabrications) {
                    console.error(`üö® BLACKLIST FILTER: Removed ${filterResult.sentencesRemoved} fabricated sentences`);
                    console.error(`   Terms: ${filterResult.termsRemoved.join(', ')}`);
                    generatedText = filterResult.filtered;
                    // Add warning to status
                    status.textContent = `‚ö†Ô∏è Warning: ${filterResult.sentencesRemoved} fabricated sentences removed by safety filter`;
                    status.style.background = '#fff3cd';
                    status.style.color = '#856404';
                } else {
                    console.log('‚úÖ BLACKLIST filter: No fabrications detected');
                }

                // ============================================================
                // PHASE 7: VALIDATION PIPELINE INTEGRATION
                // ============================================================
                // Run 6-layer validation on generated content
                try {
                    console.log('üîç PHASE 4: VALIDATION PIPELINE');
                    status.textContent = 'üîç Validating generated content...';
                    status.className = 'status';
                    status.style.background = '#fff3cd';
                    status.style.color = '#856404';

                    // Create API client wrapper for validation
                    const validationAPIClient = {
                        generateText: async (prompt, options = {}) => {
                            const validationResponse = await fetch(
                                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${API_KEY}`,
                                {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        contents: [{
                                            role: 'user',
                                            parts: [{ text: prompt }]
                                        }],
                                        generationConfig: {
                                            temperature: options.temperature || 0.1,
                                            maxOutputTokens: options.maxOutputTokens || 2048
                                        }
                                    })
                                }
                            );

                            if (!validationResponse.ok) {
                                throw new Error(`Validation API Error ${validationResponse.status}`);
                            }

                            const validationData = await validationResponse.json();
                            return validationData.candidates?.[0]?.content?.parts?.[0]?.text || '';
                        }
                    };

                    // Get validation pipeline (lazy-loaded singleton)
                    const validator = await getValidationPipeline(validationAPIClient);

                    // Run complete validation (6 layers)
                    const validationResult = await validator.validateComplete(
                        {}, // extractedData - empty for now since we're validating generated text
                        transcript, // original source text
                        {
                            ultrathink: generatedText  // generated output to validate
                        },
                        {
                            skipSemanticFabrication: false,  // Run all validations
                            detailedGrounding: true
                        }
                    );

                    // Store validation results globally for Validation tab display (Phase 8)
                    lastValidationResult = validationResult;

                    // Log quality score
                    if (validationResult.success && validationResult.validation) {
                        const qualityScore = validationResult.validation.overallScore || 0;
                        console.log(`‚úÖ Validation Complete - Quality Score: ${qualityScore}/100`);
                        console.log('üìä Validation Summary:', {
                            grounding: validationResult.validation.grounding?.score || 'N/A',
                            fabrication: validationResult.validation.fabrication?.score || 'N/A',
                            completeness: validationResult.validation.completeness?.score || 'N/A',
                            consistency: validationResult.validation.consistency?.score || 'N/A',
                            proportionality: validationResult.validation.proportionality?.score || 'N/A',
                            overallScore: qualityScore
                        });

                        // Show quality badge in status (color-coded)
                        let qualityBadge = '';
                        let qualityColor = '';
                        if (qualityScore >= 80) {
                            qualityBadge = 'üü¢ High Quality';
                            qualityColor = '#28a745';
                        } else if (qualityScore >= 60) {
                            qualityBadge = 'üü° Moderate Quality';
                            qualityColor = '#ffc107';
                        } else {
                            qualityBadge = 'üî¥ Review Needed';
                            qualityColor = '#dc3545';
                        }

                        console.log(`${qualityBadge} (${qualityScore}/100)`);

                        // Display validation results in UI
                        displayValidationResults(validationResult);
                    } else {
                        console.warn('‚ö†Ô∏è Validation completed with warnings or partial results');
                    }
                } catch (validationError) {
                    // Validation failure should not break generation - log and continue
                    console.error('‚ö†Ô∏è Validation pipeline error (non-fatal):', validationError.message);
                    console.error('Stack:', validationError.stack);
                    lastValidationResult = {
                        success: false,
                        error: validationError.message,
                        validation: null
                    };
                }

                output.value = generatedText;
                status.className = 'status connected';

                if (hasBriefing) {
                    briefingUsed = true;
                    status.textContent = '‚úÖ Expert Analysis Complete - Briefing + Transcript Integrated!';
                    console.log('‚úÖ Expert integrated analysis generated successfully');
                    console.log(`üìã Briefing checklist items: ${briefingChecklist.length}`);
                } else {
                    status.textContent = '‚úÖ Documentation Generated Successfully!';
                    console.log('‚úÖ Generated successfully (no briefing)');
                }

                // Update formatted output tab
                updateFormattedOutput(generatedText);

                // V6: Parse AI suggestions if in enhanced mode
                if (transcriptEnhanceMode && hasBriefing) {
                    currentSuggestions = parseAISuggestions(generatedText);

                    // V8 MITIGATION: Check AI suggestions for fabrications
                    console.log('üîç Running fabrication detection on expert analysis...');
                    const fabricationCheck = detectSuggestionFabrications(currentSuggestions, transcript);

                    // Display fabrication results in validation panel
                    displayFabricationResults(fabricationCheck);

                    // If critical fabrications found, alert the user
                    if (fabricationCheck.errors.length > 0) {
                        console.error(`üö® CRITICAL: ${fabricationCheck.errors.length} fabrications detected in expert analysis!`);
                        status.textContent = `‚ö†Ô∏è Warning: ${fabricationCheck.errors.length} potential fabrications detected - check Validation tab`;
                        status.style.background = '#fff3cd';
                        status.style.color = '#856404';
                    }

                    // V8 PHASE 3: Hybrid Gap Analysis
                    const gapSuggestions = currentSuggestions.filter(s => s.type === 'gap-analysis');
                    if (gapSuggestions.length > 0 && checklistCoverageAnalysis) {
                        console.log('üîç Gap-analysis suggestion found, running hybrid analysis...');

                        // Parse LLM-detected gaps from gap-analysis content
                        const llmGaps = parseGapAnalysisContent(gapSuggestions[0].content);
                        console.log('üìä LLM detected gaps:', llmGaps);

                        // Cross-validate with algorithmic analysis
                        const hybridReport = crossValidateGaps(llmGaps, checklistCoverageAnalysis);
                        console.log('‚úÖ Hybrid gap report generated:', hybridReport.summary);

                        // Display hybrid gap report (creates new tab)
                        displayHybridGapReport(hybridReport);
                    }

                    if (currentSuggestions.length > 0) {
                        displayReviewInterface(currentSuggestions);

                        // Show review tab button and switch to it
                        const reviewTabButton = document.getElementById('review-tab-button');
                        if (reviewTabButton) {
                            reviewTabButton.style.display = 'inline-block';
                        }

                        switchTab('review');
                        status.textContent = `‚úÖ Expert Analysis Complete! Review ${currentSuggestions.length} AI suggestions.`;
                        console.log(`üîç ${currentSuggestions.length} suggestions ready for review`);
                    } else {
                        // No suggestions found, show validation tab
                        switchTab('validation');
                    }
                } else {
                    // Expand-only mode: show validation tab
                    switchTab('validation');
                }

                // Auto-generate compressed and ultracompressed summaries
                console.log('üìä Auto-generating compressed and ultracompressed summaries...');

                // Store the full note
                currentNoteVersions.full = generatedText;

                // Generate standard compression (independent)
                currentNoteVersions.status.standard = 'generating';
                updateCompressionStatusBadges();
                try {
                    let standardSummary = await generateAttendingSummary(generatedText);

                    // V9 FIREWALL: Apply BLACKLIST filter to Standard DOAP
                    console.log('üõ°Ô∏è Applying BLACKLIST filter to Standard DOAP...');
                    const standardFilterResult = filterBlacklistTerms(standardSummary || '', inputMode === 'soap' ? soapText : transcript);
                    if (standardFilterResult.hadFabrications) {
                        console.error(`üö® DOAP BLACKLIST FILTER: Removed ${standardFilterResult.sentencesRemoved} fabricated sentences from Standard DOAP`);
                        console.error(`   Terms: ${standardFilterResult.termsRemoved.join(', ')}`);
                        standardSummary = standardFilterResult.filtered;
                    } else {
                        console.log('‚úÖ DOAP BLACKLIST filter: No fabrications detected in Standard DOAP');
                    }

                    currentNoteVersions.standard = standardSummary || '';
                    currentNoteVersions.status.standard = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Standard compression generated');
                } catch (standardError) {
                    console.error('‚ùå Standard compression failed:', standardError.message);
                    currentNoteVersions.standard = '‚ö†Ô∏è Standard compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.standard = 'failed';
                    updateCompressionStatusBadges();
                }

                // Generate ULTRA compression (independent)
                currentNoteVersions.status.ultra = 'generating';
                updateCompressionStatusBadges();
                try {
                    let ultraSummary = await generateUltraAttendingSummary(generatedText);

                    // V9 FIREWALL: Apply BLACKLIST filter to ULTRATHINK
                    console.log('üõ°Ô∏è Applying BLACKLIST filter to ULTRATHINK...');
                    const ultraFilterResult = filterBlacklistTerms(ultraSummary || '', inputMode === 'soap' ? soapText : transcript);
                    if (ultraFilterResult.hadFabrications) {
                        console.error(`üö® ULTRATHINK BLACKLIST FILTER: Removed ${ultraFilterResult.sentencesRemoved} fabricated sentences from ULTRATHINK`);
                        console.error(`   Terms: ${ultraFilterResult.termsRemoved.join(', ')}`);
                        ultraSummary = ultraFilterResult.filtered;
                    } else {
                        console.log('‚úÖ ULTRATHINK BLACKLIST filter: No fabrications detected');
                    }

                    currentNoteVersions.ultra = ultraSummary || '';
                    currentNoteVersions.status.ultra = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ ULTRA compression generated');

                    // V8 MITIGATION: Check DOAP/ULTRATHINK for fabrications (Transcript mode)
                    if (ultraSummary) {
                        const doapCheck = checkDOAPFabrications(ultraSummary, transcript);
                        if (!doapCheck.clean) {
                            console.error(`üö® DOAP fabrication detected! ${doapCheck.errors.length} prohibited terms found`);
                            // Update fabrication panel with DOAP-specific warnings
                            const doapFabricationResult = {
                                checked: 1,
                                errors: doapCheck.errors.map(e => ({
                                    ...e,
                                    suggestionId: 'doap-ultrathink',
                                    suggestionType: 'ULTRATHINK Summary',
                                    category: 'doap',
                                    excerpt: ultraSummary.substring(0, 150) + '...'
                                })),
                                warnings: [],
                                clean: false
                            };
                            displayFabricationResults(doapFabricationResult);
                        }
                    }
                } catch (ultraError) {
                    console.error('‚ùå ULTRA compression failed:', ultraError.message);
                    currentNoteVersions.ultra = '‚ö†Ô∏è ULTRA compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.ultra = 'failed';
                    updateCompressionStatusBadges();
                }

                // Telegram compression temporarily disabled (API safety filter issues)
                /*
                currentNoteVersions.status.telegram = 'generating';
                updateCompressionStatusBadges();
                try {
                    const telegramSummary = await generateTelegramSummary(generatedText);
                    currentNoteVersions.telegram = telegramSummary || '';
                    currentNoteVersions.status.telegram = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Telegram compression generated');
                } catch (telegramError) {
                    console.error('‚ùå Telegram compression failed:', telegramError.message);
                    currentNoteVersions.telegram = '‚ö†Ô∏è Telegram compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.telegram = 'failed';
                    updateCompressionStatusBadges();
                }
                */
                currentNoteVersions.telegram = 'Telegram mode temporarily disabled';
                currentNoteVersions.status.telegram = 'disabled';

                // Display based on currently selected compression mode
                const selectedMode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
                const summaryToDisplay = selectedMode === 'ultra' ? currentNoteVersions.ultra
                                       : selectedMode === 'telegram' ? currentNoteVersions.telegram
                                       : currentNoteVersions.standard;

                if (summaryToDisplay && !summaryToDisplay.includes('failed')) {
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else if (summaryToDisplay) {
                    // Show error message in textarea
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else {
                    console.warn('‚ö†Ô∏è No summary generated');
                }

            } catch (error) {
                console.error('Generation error:', error);
                output.value = `‚ùå Error: ${error.message}`;
                status.className = 'status disconnected';
                status.textContent = '‚ùå Generation Failed';
                alert(`Generation failed: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.textContent = hasBriefing ? '‚ö° Generate Expert Analysis' : '‚ö° Generate Clinical Note';
            }
        }

        /**
         * Generate clinical note from SOAP quick-entry
         */
        async function generateFromSOAP() {
            if (!API_KEY) {
                alert('API key not configured.');
                return;
            }

            const btn = document.getElementById('generateBtn');
            const status = document.getElementById('status');
            const output = document.getElementById('output');

            // V6: Reset review state for new generation
            currentSuggestions = [];
            const reviewTabButton = document.getElementById('review-tab-button');
            if (reviewTabButton) {
                reviewTabButton.style.display = 'none';
            }

            btn.disabled = true;
            btn.textContent = '‚è≥ Generating from SOAP entry...';
            status.className = 'status';
            status.style.background = '#d1ecf1';
            status.style.color = '#0c5460';

            const hasBriefing = generatedBriefing && generatedBriefing.length > 0;

            if (soapEnhanceMode && hasBriefing) {
                status.textContent = 'üîÑ Enhanced mode: Expanding + Adding clinical analysis from briefing...';
            } else if (soapEnhanceMode) {
                status.textContent = 'üîÑ Enhanced mode: Expanding + General clinical analysis...';
            } else {
                status.textContent = 'üîÑ Expand mode: Professional writing only (no added facts)...';
            }

            try {
                let prompt;

                if (soapEnhanceMode) {
                    // ========================================
                    // MODE 2: ENHANCED (Expand + Analysis)
                    // ========================================

                    const pathologyData = selectedPathology ? PathologyDatabase[selectedPathology] : null;
                    const pathologyName = customPathology || (pathologyData ? pathologyData.name : 'General');

                    // Build scale recommendation section if pathology selected
                    let scaleRecommendation = '';
                    if (pathologyData && pathologyData.recommendedScales && pathologyData.recommendedScales.length > 0) {
                        const scaleNames = pathologyData.recommendedScales
                            .map(id => ClinicalScalesDatabase[id]?.shortName || id)
                            .join(', ');
                        scaleRecommendation = `\n## ü§ñ RECOMMENDED CLINICAL SCALES\nFor comprehensive assessment of ${pathologyName}, consider:\n${scaleNames}\n\n(These can be completed in the Clinical Scales tab)`;
                    }

                    prompt = `You are an expert neurosurgical consultant analyzing a clinical case. You will receive:
1. CLINICIAN'S SOAP NOTES (user's documented facts)
2. PRE-CONSULTATION BRIEFING (relevant medical context)

Your task: Generate a comprehensive clinical note that expands the brief SOAP notes AND provides expert clinical analysis.

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  ‚õî‚õî‚õî ABSOLUTE FIREWALL RULE - READ THIS FIRST ‚õî‚õî‚õî                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üö® CRITICAL: BRIEFING vs CLINICAL NOTE SEPARATION

You will receive TWO types of information:
1. **PRE-CONSULTATION BRIEFING** = Background reference knowledge ONLY
2. **CLINICIAN'S SOAP NOTES** = Your ONLY source of documented facts

üõ°Ô∏è ABSOLUTE FIREWALL BETWEEN BRIEFING AND CLINICAL NOTE:

**BRIEFING PURPOSE**: Medical reference for understanding the condition
- Contains general red flags to be AWARE of (NOT to fabricate if absent)
- Contains typical exam findings (NOT to assume were performed)
- Contains standard workup options (NOT to recommend unless documented)
- Contains checklists (for gap analysis ONLY, not for fabrication)

**CLINICAL NOTE PURPOSE**: Document ONLY what was explicitly stated by clinician
- Include ONLY findings mentioned in SOAP notes
- Document ONLY examinations that were performed
- Note ONLY symptoms that were reported
- Record ONLY discussions that actually occurred

‚õî THE BRIEFING MUST NEVER CONTAMINATE THE CLINICAL NOTE ‚õî

**PROHIBITED CONTAMINATION EXAMPLES:**
‚ùå Briefing mentions "screen for suicidal ideation" ‚Üí You add it to red flags
‚ùå Briefing lists "assess cranial nerves" ‚Üí You mark as "not documented"
‚ùå Briefing suggests "MRI brain" ‚Üí You recommend it without clinical indication
‚ùå Briefing has checklist item ‚Üí You populate it even if not in SOAP notes

**CORRECT USAGE:**
‚úÖ Briefing mentions red flag ‚Üí Use ONLY if SOAP notes mention it
‚úÖ Briefing suggests exam ‚Üí Use ONLY if SOAP notes show it was done
‚úÖ Briefing lists checklist item ‚Üí Note in gap-analysis if missing, don't fabricate
‚úÖ Briefing provides context ‚Üí Use to understand, not to add facts

üîí THIS RULE OVERRIDES ALL OTHER INSTRUCTIONS, INCLUDING CHECKLIST COMPLETION.

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  ‚úÖ MANDATORY GROUND TRUTH RULE - SOAP NOTES ARE YOUR ONLY SOURCE   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Your ONLY source of truth is the SOAP notes below. You MUST NOT add ANY information that is not explicitly stated in the SOAP notes.

**WHITELIST - ONLY include information that is:**
1. **Verbatim**: Text appears in SOAP notes
2. **Measured**: Numerical values stated by clinician
3. **Observed**: Exam findings explicitly documented
4. **Stated**: Clinical observations in SOAP sections

‚õî BLACKLIST - NEVER include if NOT documented (automatic exclusion):
1. **Psychiatric symptoms**: depression | suicidal ideation | suicide | anxiety | psychosis | mental health concerns
   - If SOAP says "severe pain" ‚Üí DO NOT infer "suicidal ideation"
   - If SOAP says "chronic condition" ‚Üí DO NOT add "depression" or psychological impact
2. **Social history**: smoking | alcohol | drug use | employment | living situation
3. **Family history**: genetic conditions | family medical problems
4. **Medications**: ANY medications not explicitly listed in SOAP
5. **Exam findings**: ANY exam element not performed and documented
6. **Lab/Imaging values**: ANY results not provided with exact values

üö´ PROHIBITED CLINICAL INFERENCES:
- "Severe pain" ‚Üí DO NOT infer "suicidal ideation", "depression"
- "Failed treatments" ‚Üí DO NOT infer psychological desperation
- "Chronic condition" ‚Üí DO NOT add mental health symptoms

CRITICAL RULE: If information is ABSENT from SOAP notes ‚Üí It MUST be ABSENT from your analysis.

üè∑Ô∏è INFERENCE TRANSPARENCY REQUIREMENTS:
When you synthesize or infer clinical information in your expert analysis, mark it explicitly:
- Use "[INFERRED]" tag for any content NOT explicitly stated in SOAP notes
- Provide rationale: "[INFERRED - reason for inference]"
- Examples: "[INFERRED - commonly associated]", "[INFERRED from symptom pattern]", "[INFERRED - typical nerve distribution]"
- Format: Include marker WITHIN the AI_SUGGESTION content where inference occurs
- Documented facts in üìù DOCUMENTED section need NO marker - only inferred content in AI analysis
- This maintains clinical reasoning transparency while preserving professional quality

CRITICAL STRUCTURE REQUIREMENTS:

## SECTION 1: USER'S DOCUMENTED FACTS
Always start with the clinician's documented observations marked as:
üìù DOCUMENTED: [Expand the user's SOAP notes professionally - NO additions, NO inferences]

## SECTION 2: AI-GENERATED EXPERT ANALYSIS
After documented facts, provide expert analysis wrapped in AI_SUGGESTION markers:

<!-- AI_SUGGESTION type="clinical-analysis" id="analysis-001" category="subjective" depends-on="" -->
ü§ñ CLINICAL ANALYSIS:
[Your expert interpretation of symptoms, patterns, temporal relationships]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="differential" id="diff-001" category="assessment" depends-on="analysis-001" -->
ü§ñ DIFFERENTIAL DIAGNOSIS:
1. **Most Likely:** [Diagnosis] - Confidence: High/Moderate/Low
   - Supporting: [specific findings]
   - Against: [contradicting findings]
2. **Alternative:** [Diagnosis] - Confidence: [level]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="red-flag" id="alert-001" category="assessment" depends-on="" -->
‚ö†Ô∏è RED FLAG ALERT (ONLY if critical findings DOCUMENTED in transcript):
[Critical findings requiring immediate attention - MUST have supporting direct quotes from transcript]

‚ö†Ô∏è INCLUDE THIS BLOCK ONLY IF: Patient/clinician mentioned red flag symptoms in transcript
‚ö†Ô∏è OMIT THIS BLOCK IF: No red flags were discussed (even if briefing lists them as concerns to screen)

Evidence required: "[Direct quote from transcript showing red flag was present]"
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="gap-analysis" id="gap-001" category="assessment" depends-on="" -->
ü§ñ CLINICAL GAPS IDENTIFIED:
Missing from history: [list]
Missing from exam: [list]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="workup" id="workup-001" category="plan" depends-on="diff-001" -->
üî¨ RECOMMENDED DIAGNOSTIC WORKUP:
### Imaging:
- [Specific study] - Rationale: [why]
### Laboratory:
- [Specific test] - Rationale: [why]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="recommendation" id="rec-001" category="plan" depends-on="diff-001,workup-001" -->
üíä EVIDENCE-BASED MANAGEMENT PLAN:
### Conservative:
- [Specific intervention] - Evidence: [level]
### Surgical Considerations:
- [If indicated, specific approach]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="scales" id="scales-001" category="objective" depends-on="" -->
üìè CLINICAL SCALES ASSESSMENT:
[Apply relevant scales from briefing - mJOA, Nurick, etc.]
<!-- /AI_SUGGESTION -->

<!-- AI_SUGGESTION type="pearl" id="pearl-001" category="assessment" depends-on="" -->
üí° CLINICAL PEARL:
[Evidence-based insight or teaching point]
üìä Evidence Level: [I/II/III/IV]
<!-- /AI_SUGGESTION -->

MARKER RULES:
1. **Every AI-generated insight MUST be wrapped** in AI_SUGGESTION markers
2. **Use type attribute**: clinical-analysis, differential, recommendation, pearl, red-flag, gap-analysis, workup, scales
3. **Unique ID**: Use format type-### (e.g., diff-001, rec-002)
4. **Category**: subjective, objective, assessment, plan
5. **depends-on**: Comma-separated parent IDs if suggestion builds on others (empty string if independent)
6. **DO NOT wrap** üìù DOCUMENTED sections - only AI additions

CLINICIAN'S SOAP HEADNOTES:

=== SUBJECTIVE ===
${soapQuickEntry.subjective || '[Not documented]'}

=== OBJECTIVE ===
${soapQuickEntry.objective || '[Not documented]'}

=== ASSESSMENT ===
${soapQuickEntry.assessment || '[Not documented]'}

=== PLAN ===
${soapQuickEntry.plan || '[Not documented]'}

---
CONTEXT:
- Consultation Type: ${consultationType === 'followup' ? 'Follow-up Visit' : 'New Consultation'}
- Pathology Context: ${pathologyName}
${hasBriefing ? '- Evidence Base: Pre-consultation briefing available' : ''}

${scaleRecommendation}

ANTI-HALLUCINATION RULES:
‚úÖ Expand user's notes professionally in üìù DOCUMENTED section
‚úÖ Provide expert analysis in marked AI_SUGGESTION blocks
‚úÖ Use briefing/pathology database to inform analysis
‚úÖ Mark all suggestions with proper attributes

‚ùå DO NOT add facts to üìù DOCUMENTED sections
‚ùå DO NOT modify user's observations
‚ùå DO NOT create findings not stated by clinician
‚ùå DO NOT forget to wrap suggestions in markers

Generate the comprehensive clinical note now with proper markers:`;

                } else {
                    // ========================================
                    // MODE 1: EXPAND ONLY (No Analysis)
                    // ========================================

                    prompt = `You are a medical documentation assistant. Your ONLY job is to convert the clinician's brief SOAP headnotes into professionally written clinical documentation.

CRITICAL RULES - WHAT YOU MUST DO:
‚úÖ Convert brief notes into proper medical narrative style
‚úÖ Organize information logically within each SOAP section
‚úÖ Use correct medical terminology and grammar
‚úÖ Expand common abbreviations appropriately (e.g., "x" ‚Üí "for", "F/U" ‚Üí "follow-up")
‚úÖ Maintain professional tone

CRITICAL RULES - WHAT YOU MUST NOT DO:
‚ùå DO NOT add medical facts, symptoms, or findings not stated by clinician
‚ùå DO NOT infer or assume clinical information
‚ùå DO NOT add differential diagnoses unless explicitly stated
‚ùå DO NOT suggest treatments or workup not mentioned
‚ùå DO NOT add physical exam findings not documented
‚ùå DO NOT fabricate history details
‚ùå If a section is empty, note "[Not documented]" - do not add content

CLINICIAN'S HEADNOTES:

=== SUBJECTIVE ===
${soapQuickEntry.subjective || '[Not documented]'}

=== OBJECTIVE ===
${soapQuickEntry.objective || '[Not documented]'}

=== ASSESSMENT ===
${soapQuickEntry.assessment || '[Not documented]'}

=== PLAN ===
${soapQuickEntry.plan || '[Not documented]'}

---
CONSULTATION TYPE: ${consultationType === 'followup' ? 'Follow-up Visit' : 'New Consultation'}

TASK: Expand these notes into professional clinical documentation using standard ${consultationType === 'followup' ? 'follow-up visit' : 'consultation'} format.

${consultationType === 'followup' ?
`For follow-up visits:
- Frame Subjective as "INTERVAL HISTORY" (changes since last visit)
- Focus on treatment response and progression
- Compare to baseline when clinician mentioned it
` :
`For new consultations:
- Use comprehensive SOAP format
- Maintain chronological narrative in HPI
- Organize exam findings systematically
`}

# CLINICAL NOTE

## ${consultationType === 'followup' ? 'INTERVAL HISTORY' : 'SUBJECTIVE / HISTORY'}
[Professional narrative based ONLY on clinician's subjective notes above - expand grammar and organization but add NO new medical facts]

## OBJECTIVE
[Organized examination findings based ONLY on clinician's objective notes above - use proper medical terminology but add NO new findings]

## ASSESSMENT
[Professional impression based ONLY on clinician's assessment notes above - add NO new diagnoses or analysis]

## PLAN
[Organized management plan based ONLY on clinician's plan notes above - add NO new treatments or recommendations]

## ICD-10 CODES
[Only if diagnosis clearly stated in assessment above]

FINAL CHECK:
‚úì Used only information explicitly provided by clinician
‚úì Added no medical facts or clinical reasoning
‚úì Professional language and organization
‚úì Appropriate medical terminology`;
                }

                // Call Gemini API
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: soapEnhanceMode ? 0.4 : 0.2,  // Lower temp for expand-only
                                maxOutputTokens: soapEnhanceMode && hasBriefing ? 12288 : 8192
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                let generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';

                // Construct original text from SOAP fields BEFORE filtering
                const soapOriginalText = `SUBJECTIVE: ${soapQuickEntry.subjective || '[Not documented]'}\n\nOBJECTIVE: ${soapQuickEntry.objective || '[Not documented]'}\n\nASSESSMENT: ${soapQuickEntry.assessment || '[Not documented]'}\n\nPLAN: ${soapQuickEntry.plan || '[Not documented]'}`;

                // ============================================================
                // V8 MITIGATION: Apply BLACKLIST filter (safety net - SOAP mode)
                // ============================================================
                console.log('üõ°Ô∏è Applying post-generation BLACKLIST filter (SOAP)...');
                const filterResult = filterBlacklistTerms(generatedText, soapOriginalText);
                if (filterResult.hadFabrications) {
                    console.error(`üö® BLACKLIST FILTER (SOAP): Removed ${filterResult.sentencesRemoved} fabricated sentences`);
                    console.error(`   Terms: ${filterResult.termsRemoved.join(', ')}`);
                    generatedText = filterResult.filtered;
                    // Add warning to status
                    status.textContent = `‚ö†Ô∏è Warning: ${filterResult.sentencesRemoved} fabricated sentences removed by safety filter`;
                    status.style.background = '#fff3cd';
                    status.style.color = '#856404';
                } else {
                    console.log('‚úÖ BLACKLIST filter (SOAP): No fabrications detected');
                }

                // ============================================================
                // PHASE 7: VALIDATION PIPELINE INTEGRATION (SOAP Mode)
                // ============================================================
                // Run 6-layer validation on generated SOAP content
                try {
                    console.log('üîç PHASE 4: VALIDATION PIPELINE (SOAP)');
                    status.textContent = 'üîç Validating generated SOAP note...';
                    status.className = 'status';
                    status.style.background = '#fff3cd';
                    status.style.color = '#856404';

                    // Create API client wrapper for validation
                    const validationAPIClient = {
                        generateText: async (prompt, options = {}) => {
                            const validationResponse = await fetch(
                                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${API_KEY}`,
                                {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        contents: [{
                                            role: 'user',
                                            parts: [{ text: prompt }]
                                        }],
                                        generationConfig: {
                                            temperature: options.temperature || 0.1,
                                            maxOutputTokens: options.maxOutputTokens || 2048
                                        }
                                    })
                                }
                            );

                            if (!validationResponse.ok) {
                                throw new Error(`Validation API Error ${validationResponse.status}`);
                            }

                            const validationData = await validationResponse.json();
                            return validationData.candidates?.[0]?.content?.parts?.[0]?.text || '';
                        }
                    };

                    // Get validation pipeline (lazy-loaded singleton)
                    const validator = await getValidationPipeline(validationAPIClient);

                    // Run complete validation (6 layers)
                    const validationResult = await validator.validateComplete(
                        {}, // extractedData - empty for now
                        soapOriginalText, // original SOAP text
                        {
                            ultrathink: generatedText  // generated SOAP output to validate
                        },
                        {
                            skipSemanticFabrication: false,  // Run all validations
                            detailedGrounding: true
                        }
                    );

                    // Store validation results globally for Validation tab display (Phase 8)
                    lastValidationResult = validationResult;

                    // Log quality score
                    if (validationResult.success && validationResult.validation) {
                        const qualityScore = validationResult.validation.overallScore || 0;
                        console.log(`‚úÖ Validation Complete - Quality Score: ${qualityScore}/100`);
                        console.log('üìä Validation Summary:', {
                            grounding: validationResult.validation.grounding?.score || 'N/A',
                            fabrication: validationResult.validation.fabrication?.score || 'N/A',
                            completeness: validationResult.validation.completeness?.score || 'N/A',
                            consistency: validationResult.validation.consistency?.score || 'N/A',
                            proportionality: validationResult.validation.proportionality?.score || 'N/A',
                            overallScore: qualityScore
                        });

                        // Show quality badge in status (color-coded)
                        let qualityBadge = '';
                        if (qualityScore >= 80) {
                            qualityBadge = 'üü¢ High Quality';
                        } else if (qualityScore >= 60) {
                            qualityBadge = 'üü° Moderate Quality';
                        } else {
                            qualityBadge = 'üî¥ Review Needed';
                        }

                        console.log(`${qualityBadge} (${qualityScore}/100)`);

                        // Display validation results in UI
                        displayValidationResults(validationResult);
                    } else {
                        console.warn('‚ö†Ô∏è Validation completed with warnings or partial results');
                    }
                } catch (validationError) {
                    // Validation failure should not break generation - log and continue
                    console.error('‚ö†Ô∏è Validation pipeline error (non-fatal):', validationError.message);
                    console.error('Stack:', validationError.stack);
                    lastValidationResult = {
                        success: false,
                        error: validationError.message,
                        validation: null
                    };
                }

                output.value = generatedText;
                status.className = 'status connected';

                if (soapEnhanceMode) {
                    status.textContent = '‚úÖ Enhanced SOAP Note Generated!';
                    console.log('‚úÖ SOAP Enhanced mode generation complete');
                } else {
                    status.textContent = '‚úÖ SOAP Note Expanded!';
                    console.log('‚úÖ SOAP Expand-only mode generation complete');
                }

                // Update formatted output tab
                updateFormattedOutput(generatedText);

                // V6: Parse AI suggestions if in enhanced mode
                if (soapEnhanceMode) {
                    currentSuggestions = parseAISuggestions(generatedText);

                    // V8 MITIGATION: Check AI suggestions for fabrications (SOAP mode)
                    console.log('üîç Running fabrication detection on expert analysis (SOAP)...');
                    const fabricationCheck = detectSuggestionFabrications(currentSuggestions, soapOriginalText);

                    // Display fabrication results in validation panel
                    displayFabricationResults(fabricationCheck);

                    // If critical fabrications found, alert the user
                    if (fabricationCheck.errors.length > 0) {
                        console.error(`üö® CRITICAL: ${fabricationCheck.errors.length} fabrications detected in expert analysis!`);
                        status.textContent = `‚ö†Ô∏è Warning: ${fabricationCheck.errors.length} potential fabrications detected - check Validation tab`;
                        status.style.background = '#fff3cd';
                        status.style.color = '#856404';
                    }

                    // V8 PHASE 3: Hybrid Gap Analysis
                    const gapSuggestions = currentSuggestions.filter(s => s.type === 'gap-analysis');
                    if (gapSuggestions.length > 0 && checklistCoverageAnalysis) {
                        console.log('üîç Gap-analysis suggestion found (SOAP), running hybrid analysis...');

                        // Parse LLM-detected gaps from gap-analysis content
                        const llmGaps = parseGapAnalysisContent(gapSuggestions[0].content);
                        console.log('üìä LLM detected gaps:', llmGaps);

                        // Cross-validate with algorithmic analysis
                        const hybridReport = crossValidateGaps(llmGaps, checklistCoverageAnalysis);
                        console.log('‚úÖ Hybrid gap report generated:', hybridReport.summary);

                        // Display hybrid gap report (creates new tab)
                        displayHybridGapReport(hybridReport);
                    }

                    if (currentSuggestions.length > 0) {
                        displayReviewInterface(currentSuggestions);

                        // Show review tab button and switch to it
                        const reviewTabButton = document.getElementById('review-tab-button');
                        if (reviewTabButton) {
                            reviewTabButton.style.display = 'inline-block';
                        }

                        switchTab('review');
                        status.textContent = `‚úÖ Enhanced Note Generated! Review ${currentSuggestions.length} AI suggestions.`;
                        console.log(`üîç ${currentSuggestions.length} suggestions ready for review`);
                    } else {
                        // No suggestions found, show validation tab
                        switchTab('validation');
                    }
                } else {
                    // Expand-only mode: show validation tab
                    switchTab('validation');
                }

                // Auto-generate compressed and ultracompressed summaries
                console.log('üìä Auto-generating compressed and ultracompressed summaries...');

                // Store the full note
                currentNoteVersions.full = generatedText;

                // Generate standard compression (independent)
                currentNoteVersions.status.standard = 'generating';
                updateCompressionStatusBadges();
                try {
                    let standardSummary = await generateAttendingSummary(generatedText);

                    // V9 FIREWALL: Apply BLACKLIST filter to Standard DOAP
                    console.log('üõ°Ô∏è Applying BLACKLIST filter to Standard DOAP...');
                    const standardFilterResult = filterBlacklistTerms(standardSummary || '', inputMode === 'soap' ? soapText : transcript);
                    if (standardFilterResult.hadFabrications) {
                        console.error(`üö® DOAP BLACKLIST FILTER: Removed ${standardFilterResult.sentencesRemoved} fabricated sentences from Standard DOAP`);
                        console.error(`   Terms: ${standardFilterResult.termsRemoved.join(', ')}`);
                        standardSummary = standardFilterResult.filtered;
                    } else {
                        console.log('‚úÖ DOAP BLACKLIST filter: No fabrications detected in Standard DOAP');
                    }

                    currentNoteVersions.standard = standardSummary || '';
                    currentNoteVersions.status.standard = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Standard compression generated');
                } catch (standardError) {
                    console.error('‚ùå Standard compression failed:', standardError.message);
                    currentNoteVersions.standard = '‚ö†Ô∏è Standard compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.standard = 'failed';
                    updateCompressionStatusBadges();
                }

                // Generate ULTRA compression (independent)
                currentNoteVersions.status.ultra = 'generating';
                updateCompressionStatusBadges();
                try {
                    let ultraSummary = await generateUltraAttendingSummary(generatedText);

                    // V9 FIREWALL: Apply BLACKLIST filter to ULTRATHINK
                    console.log('üõ°Ô∏è Applying BLACKLIST filter to ULTRATHINK...');
                    const ultraFilterResult = filterBlacklistTerms(ultraSummary || '', inputMode === 'soap' ? soapText : transcript);
                    if (ultraFilterResult.hadFabrications) {
                        console.error(`üö® ULTRATHINK BLACKLIST FILTER: Removed ${ultraFilterResult.sentencesRemoved} fabricated sentences from ULTRATHINK`);
                        console.error(`   Terms: ${ultraFilterResult.termsRemoved.join(', ')}`);
                        ultraSummary = ultraFilterResult.filtered;
                    } else {
                        console.log('‚úÖ ULTRATHINK BLACKLIST filter: No fabrications detected');
                    }

                    currentNoteVersions.ultra = ultraSummary || '';
                    currentNoteVersions.status.ultra = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ ULTRA compression generated');

                    // V8 MITIGATION: Check DOAP/ULTRATHINK for fabrications (SOAP mode)
                    if (ultraSummary) {
                        const doapCheck = checkDOAPFabrications(ultraSummary, soapOriginalText);
                        if (!doapCheck.clean) {
                            console.error(`üö® DOAP fabrication detected! ${doapCheck.errors.length} prohibited terms found`);
                            // Update fabrication panel with DOAP-specific warnings
                            const doapFabricationResult = {
                                checked: 1,
                                errors: doapCheck.errors.map(e => ({
                                    ...e,
                                    suggestionId: 'doap-ultrathink',
                                    suggestionType: 'ULTRATHINK Summary',
                                    category: 'doap',
                                    excerpt: ultraSummary.substring(0, 150) + '...'
                                })),
                                warnings: [],
                                clean: false
                            };
                            displayFabricationResults(doapFabricationResult);
                        }
                    }
                } catch (ultraError) {
                    console.error('‚ùå ULTRA compression failed:', ultraError.message);
                    currentNoteVersions.ultra = '‚ö†Ô∏è ULTRA compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.ultra = 'failed';
                    updateCompressionStatusBadges();
                }

                // Telegram compression temporarily disabled (API safety filter issues)
                /*
                currentNoteVersions.status.telegram = 'generating';
                updateCompressionStatusBadges();
                try {
                    const telegramSummary = await generateTelegramSummary(generatedText);
                    currentNoteVersions.telegram = telegramSummary || '';
                    currentNoteVersions.status.telegram = 'ready';
                    updateCompressionStatusBadges();
                    console.log('‚úÖ Telegram compression generated');
                } catch (telegramError) {
                    console.error('‚ùå Telegram compression failed:', telegramError.message);
                    currentNoteVersions.telegram = '‚ö†Ô∏è Telegram compression failed. Click "Regenerate" to retry.';
                    currentNoteVersions.status.telegram = 'failed';
                    updateCompressionStatusBadges();
                }
                */
                currentNoteVersions.telegram = 'Telegram mode temporarily disabled';
                currentNoteVersions.status.telegram = 'disabled';

                // Display based on currently selected compression mode
                const selectedMode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
                const summaryToDisplay = selectedMode === 'ultra' ? currentNoteVersions.ultra
                                       : selectedMode === 'telegram' ? currentNoteVersions.telegram
                                       : currentNoteVersions.standard;

                if (summaryToDisplay && !summaryToDisplay.includes('failed')) {
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else if (summaryToDisplay) {
                    // Show error message in textarea
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                } else {
                    console.warn('‚ö†Ô∏è No summary generated');
                }

            } catch (error) {
                console.error('‚ùå SOAP generation error:', error);
                output.value = `‚ùå Error: ${error.message}`;
                status.className = 'status disconnected';
                status.textContent = '‚ùå Generation Failed';
                alert(`SOAP generation failed: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.textContent = '‚ö° Generate Clinical Note';
            }
        }

        function copyOutput() {
            const output = document.getElementById('output');
            output.select();
            document.execCommand('copy');
            alert('‚úÖ Copied to clipboard!');
        }

        function downloadOutput() {
            const text = document.getElementById('output').value;
            if (!text) {
                alert('No content to download');
                return;
            }

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Tab Navigation Functions
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Find and activate the correct tab button
            const targetButton = document.getElementById(`${tabName}-tab-button`) ||
                                 document.querySelector(`button[onclick*="switchTab('${tabName}')"]`);
            if (targetButton) {
                targetButton.classList.add('active');
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = ''; // Clear inline display style
            });

            const targetTab = document.getElementById(`tab-${tabName}`);
            if (targetTab) {
                targetTab.classList.add('active');
                targetTab.style.display = 'block'; // Force display with inline style
            } else {
                console.error(`‚ùå Tab not found: tab-${tabName}`);
            }
        }

        function copyFormatted() {
            const formattedText = document.getElementById('formattedOutput').innerText;
            if (!formattedText || formattedText.includes('Generate documentation')) {
                alert('No content to copy');
                return;
            }
            navigator.clipboard.writeText(formattedText);
            alert('‚úÖ Copied formatted text to clipboard!');
        }

        function printFormatted() {
            const content = document.getElementById('formattedOutput').innerHTML;
            if (!content || content.includes('Generate documentation')) {
                alert('No content to print');
                return;
            }

            const printWindow = window.open('', '', 'width=800,height=600');
            printWindow.document.write(`
                <html>
                <head>
                    <title>Clinical Note</title>
                    <style>
                        body { font-family: Georgia, serif; line-height: 1.6; padding: 40px; }
                        h1 { color: #333; border-bottom: 2px solid #0066CC; padding-bottom: 10px; }
                        h2 { color: #0066CC; margin-top: 20px; }
                        h3 { color: #333; margin-top: 15px; }
                    </style>
                </head>
                <body>${content}</body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        }

        function doExport() {
            const format = document.getElementById('exportFormat').value;
            const includes = document.getElementById('exportIncludes').value;
            const rawText = document.getElementById('output').value;

            if (!rawText) {
                alert('No content to export. Generate documentation first.');
                return;
            }

            let content = rawText;

            // Filter content based on selection
            if (includes === 'summary') {
                // Extract summary sections only
                const sections = ['CHIEF COMPLAINT', 'HISTORY OF PRESENT ILLNESS', 'ASSESSMENT'];
                content = extractSections(rawText, sections);
            } else if (includes === 'plan') {
                // Extract assessment and plan only
                const sections = ['ASSESSMENT', 'PLAN', 'ICD-10'];
                content = extractSections(rawText, sections);
            }

            // Export based on format
            switch (format) {
                case 'txt':
                    downloadAsText(content);
                    break;
                case 'html':
                    downloadAsHTML(content);
                    break;
                case 'json':
                    downloadAsJSON(content);
                    break;
                case 'docx':
                    alert('DOCX export requires additional library. Use HTML or TXT for now.');
                    break;
                case 'pdf':
                    alert('PDF export requires additional library. Use Print to PDF from browser for now.');
                    break;
            }
        }

        function extractSections(text, sectionNames) {
            let result = '';
            const lines = text.split('\n');
            let capturing = false;

            for (const line of lines) {
                const isHeader = sectionNames.some(section => line.includes(section));
                if (isHeader) {
                    capturing = true;
                }
                if (capturing) {
                    result += line + '\n';
                }
            }

            return result || text;
        }

        function downloadAsText(content) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadAsHTML(content) {
            const html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Clinical Note</title>
    <style>
        body { font-family: Georgia, serif; line-height: 1.6; max-width: 800px; margin: 40px auto; padding: 20px; }
        h1 { color: #333; border-bottom: 2px solid #0066CC; padding-bottom: 10px; }
        h2 { color: #0066CC; margin-top: 20px; }
        h3 { color: #333; margin-top: 15px; }
        pre { white-space: pre-wrap; font-family: inherit; }
    </style>
</head>
<body>
    <pre>${content}</pre>
</body>
</html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadAsJSON(content) {
            // Prepare scale data for export
            const scaleData = {};
            for (const scaleId in calculatedScores) {
                const score = calculatedScores[scaleId];
                const scale = ClinicalScalesDatabase[scaleId];
                if (scale) {
                    scaleData[scaleId] = {
                        scaleName: scale.name,
                        shortName: scale.shortName,
                        score: score,
                        responses: scaleResponses[scaleId] || {},
                        interpretation: scale.interpretation ?
                            (scaleId === 'ndi' || scaleId === 'odi' ? scale.interpretation(score.percentage) :
                             scaleId === 'vas_pain' ? scale.interpretation(score.overallAverage) :
                             scale.interpretation(score.total)) : null,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            const jsonData = {
                timestamp: new Date().toISOString(),
                generatedBy: 'NeuroScribe V7 - Professional Clinical Intelligence',
                pathology: selectedPathology,
                briefingUsed: briefingUsed,
                clinicalNote: content,
                wordCount: content.split(/\s+/).length,
                clinicalScales: scaleData,
                scalesSummary: {
                    totalScalesCompleted: Object.keys(calculatedScores).length,
                    scalesAssessed: Object.keys(calculatedScores)
                }
            };

            const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-note-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function updateFormattedOutput(markdown) {
            // Convert markdown to HTML with enhanced clinical highlighting
            let html = markdown
                .replace(/^# (.+)$/gm, '<h1>$1</h1>')
                .replace(/^## (.+)$/gm, '<h2>$1</h2>')
                .replace(/^### (.+)$/gm, '<h3>$1</h3>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')

                // Highlight expert analysis sections (V5 specific)
                .replace(/## üìã BRIEFING-TRANSCRIPT INTEGRATION ANALYSIS/gi,
                    '<h2 style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üìã BRIEFING-TRANSCRIPT INTEGRATION ANALYSIS</h2>')

                .replace(/## üéØ EXPERT DIFFERENTIAL DIAGNOSIS/gi,
                    '<h2 style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üéØ EXPERT DIFFERENTIAL DIAGNOSIS</h2>')

                .replace(/## üí° ASSESSMENT & SYNTHESIS/gi,
                    '<h2 style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üí° ASSESSMENT & SYNTHESIS</h2>')

                .replace(/## üìä QUALITY METRICS/gi,
                    '<h2 style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white; padding: 12px; border-radius: 8px; margin-top: 20px;">üìä QUALITY METRICS</h2>')

                // Highlight clinical pearls
                .replace(/üíé CLINICAL PEARL:([^<\n]+)/gi,
                    '<div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin: 10px 0; border-radius: 4px;"><strong>üíé CLINICAL PEARL:</strong>$1</div>')

                // Highlight red flags
                .replace(/‚ö†Ô∏è RED FLAG:([^<\n]+)/gi,
                    '<div style="background: #f8d7da; border-left: 4px solid #dc3545; padding: 10px; margin: 10px 0; border-radius: 4px;"><strong>‚ö†Ô∏è RED FLAG:</strong>$1</div>')

                // Highlight evidence levels
                .replace(/üìä Level (I{1,3}|IV|V) Evidence:([^<\n]+)/gi,
                    '<div style="background: #d1ecf1; border-left: 4px solid #0c5460; padding: 8px; margin: 8px 0; border-radius: 4px; font-size: 0.95rem;"><strong>üìä Level $1 Evidence:</strong>$2</div>')

                // Highlight confidence levels
                .replace(/Confidence level: (High|Medium|Low)/gi,
                    '<span style="background: #e3f2fd; padding: 4px 8px; border-radius: 4px; font-weight: 600; color: #0066CC;">Confidence: $1</span>')

                .replace(/\n/g, '<br>');

            document.getElementById('formattedOutput').innerHTML = html;
        }

        // ============================================================
        // EXPERT DOCUMENT UPLOAD FUNCTIONS
        // ============================================================

        async function handleDocumentUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            const uploadedDocsDiv = document.getElementById('uploadedDocs');
            uploadedDocsDiv.innerHTML = '<div style="color: #0066CC;">üì§ Processing documents...</div>';

            try {
                let duplicateCount = 0;
                let skippedCount = 0;

                for (const file of files) {
                    console.log(`üìÑ Processing: ${file.name}`);
                    const text = await readFileContent(file);

                    if (text && text.trim().length > 0) {
                        // Check for duplicates
                        if (isDuplicateDocument(file, text)) {
                            duplicateCount++;
                            console.warn(`‚ö†Ô∏è Duplicate detected: ${file.name}`);
                            continue;
                        }

                        // Check storage limit before adding
                        const currentSize = getDocumentStorageSize();
                        const newContentSize = text.length;
                        const limit = getStorageLimit();

                        if (currentSize + newContentSize > limit) {
                            const percentUsed = Math.round(((currentSize + newContentSize) / limit) * 100);
                            alert(`‚ö†Ô∏è Storage Limit Warning!\n\nAdding "${file.name}" would exceed storage capacity (${percentUsed}%).\n\nPlease delete some existing documents before uploading new ones.`);
                            skippedCount++;
                            console.warn(`‚ö†Ô∏è Skipped due to storage limit: ${file.name}`);
                            continue;
                        }

                        // Warn if approaching limit (>80%)
                        if ((currentSize + newContentSize) / limit > 0.8) {
                            const percentUsed = Math.round(((currentSize + newContentSize) / limit) * 100);
                            if (!confirm(`‚ö†Ô∏è Storage Warning\n\nYou are using ${percentUsed}% of available storage.\n\nContinue uploading "${file.name}"?`)) {
                                skippedCount++;
                                continue;
                            }
                        }

                        uploadedDocuments.push({
                            name: file.name,
                            content: text,
                            size: file.size,
                            type: file.type,
                            timestamp: new Date().toISOString()
                        });

                        console.log(`‚úÖ Loaded: ${file.name} (${text.length} chars)`);
                    } else {
                        console.warn(`‚ö†Ô∏è Empty or unreadable: ${file.name}`);
                        skippedCount++;
                    }
                }

                // Combine all document texts
                uploadedDocText = uploadedDocuments.map(doc =>
                    `\n=== ${doc.name} ===\n${doc.content}\n`
                ).join('\n');

                // Save to localStorage
                saveUploadedDocumentsToStorage();

                // Update UI
                updateUploadedDocsList();
                updateDocumentStorageUI();

                // Show summary
                let summary = `‚úÖ Total documents loaded: ${uploadedDocuments.length}`;
                if (duplicateCount > 0) {
                    summary += `\n‚ö†Ô∏è ${duplicateCount} duplicate(s) skipped`;
                }
                if (skippedCount > 0) {
                    summary += `\n‚ö†Ô∏è ${skippedCount} file(s) skipped`;
                }

                console.log(summary);
                console.log(`üìä Total text content: ${uploadedDocText.length} characters`);

            } catch (error) {
                console.error('‚ùå Error processing documents:', error);
                uploadedDocsDiv.innerHTML = `<div style="color: #dc2626;">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = (e) => {
                    try {
                        const content = e.target.result;

                        // Handle different file types
                        if (file.type === 'application/pdf') {
                            // For PDF, we can only read text if it's text-based PDF
                            // In a full implementation, you'd use pdf.js library
                            resolve('[PDF content - Note: Full PDF parsing requires pdf.js library. Please convert to TXT for best results.]');
                        } else {
                            // Text files, Word docs as text, etc.
                            resolve(content);
                        }
                    } catch (error) {
                        reject(error);
                    }
                };

                reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));

                // Read as text
                if (file.type.includes('text') || file.name.endsWith('.txt') || file.name.endsWith('.md')) {
                    reader.readAsText(file);
                } else if (file.type.includes('pdf')) {
                    resolve('[PDF Upload - Please convert to .TXT format for full text extraction, or paste content manually into Custom Pathology field]');
                } else {
                    // Try reading as text anyway
                    reader.readAsText(file);
                }
            });
        }

        function updateUploadedDocsList() {
            const uploadedDocsDiv = document.getElementById('uploadedDocs');

            if (uploadedDocuments.length === 0) {
                uploadedDocsDiv.innerHTML = '';
                return;
            }

            let html = '<div style="background: #e3f2fd; padding: 10px; border-radius: 6px; margin-top: 10px;">';
            html += `<strong>‚úÖ ${uploadedDocuments.length} document(s) loaded:</strong><br>`;

            uploadedDocuments.forEach((doc, index) => {
                const sizeKB = (doc.size / 1024).toFixed(1);
                html += `<div style="margin-top: 5px; padding: 5px; background: white; border-radius: 4px;">`;
                html += `üìÑ ${doc.name} (${sizeKB} KB)`;
                html += `<button onclick="removeDocument(${index})" style="float: right; padding: 2px 8px; font-size: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 3px; cursor: pointer;">‚úï</button>`;
                html += `</div>`;
            });

            html += `<div style="margin-top: 8px; font-size: 0.75rem; color: #666;">`;
            html += `Total content: ${(uploadedDocText.length / 1024).toFixed(1)} KB`;
            html += `</div>`;
            html += '</div>';

            uploadedDocsDiv.innerHTML = html;
        }

        function removeDocument(index) {
            if (confirm(`Remove ${uploadedDocuments[index].name}?`)) {
                uploadedDocuments.splice(index, 1);

                // Rebuild combined text
                uploadedDocText = uploadedDocuments.map(doc =>
                    `\n=== ${doc.name} ===\n${doc.content}\n`
                ).join('\n');

                // Save to localStorage
                saveUploadedDocumentsToStorage();

                // Update UI
                updateUploadedDocsList();
                updateDocumentStorageUI();

                console.log(`üóëÔ∏è Document removed. Remaining: ${uploadedDocuments.length}`);
            }
        }

        function clearAllDocuments() {
            if (confirm('Clear all uploaded documents? This will remove them from storage permanently.')) {
                uploadedDocuments = [];
                uploadedDocText = '';
                document.getElementById('expertDocUpload').value = '';
                localStorage.removeItem('neuroscribe_uploaded_documents');
                updateUploadedDocsList();
                updateDocumentStorageUI();
                console.log('üóëÔ∏è All documents cleared from memory and storage');
            }
        }

        // ============================================================
        // DOCUMENT PERSISTENCE FUNCTIONS
        // ============================================================

        /**
         * Save uploaded documents to localStorage
         */
        function saveUploadedDocumentsToStorage() {
            try {
                const dataToSave = {
                    documents: uploadedDocuments,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('neuroscribe_uploaded_documents', JSON.stringify(dataToSave));
                console.log(`‚úÖ ${uploadedDocuments.length} document(s) saved to localStorage`);
                return true;
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    alert('‚ö†Ô∏è Storage limit reached! Please delete some documents before uploading new ones.');
                    console.error('‚ùå Storage quota exceeded');
                } else {
                    console.error('‚ùå Error saving documents:', error);
                }
                return false;
            }
        }

        /**
         * Load uploaded documents from localStorage
         */
        function loadUploadedDocumentsFromStorage() {
            try {
                const saved = localStorage.getItem('neuroscribe_uploaded_documents');
                if (saved) {
                    const data = JSON.parse(saved);
                    uploadedDocuments = data.documents || [];

                    // Rebuild combined text
                    uploadedDocText = uploadedDocuments.map(doc =>
                        `\n=== ${doc.name} ===\n${doc.content}\n`
                    ).join('\n');

                    updateUploadedDocsList();
                    updateDocumentStorageUI();

                    console.log(`‚úÖ ${uploadedDocuments.length} document(s) loaded from localStorage (saved: ${data.timestamp})`);
                    return true;
                }
            } catch (error) {
                console.error('‚ùå Error loading documents:', error);
            }
            return false;
        }

        /**
         * Check if a document is a duplicate
         */
        function isDuplicateDocument(file, content) {
            return uploadedDocuments.some(doc =>
                doc.name === file.name &&
                doc.size === file.size &&
                doc.content.substring(0, 100) === content.substring(0, 100)
            );
        }

        /**
         * Calculate total storage used by documents
         */
        function getDocumentStorageSize() {
            const totalBytes = uploadedDocuments.reduce((sum, doc) => sum + doc.content.length, 0);
            return totalBytes;
        }

        /**
         * Get estimated storage limit (5 MB)
         */
        function getStorageLimit() {
            return 5 * 1024 * 1024; // 5 MB in bytes
        }

        /**
         * Update document storage UI showing usage and list
         */
        function updateDocumentStorageUI() {
            const storageUIDiv = document.getElementById('documentStorageUI');
            if (!storageUIDiv) return;

            const totalSize = getDocumentStorageSize();
            const limit = getStorageLimit();
            const percentUsed = Math.round((totalSize / limit) * 100);
            const totalMB = (totalSize / (1024 * 1024)).toFixed(2);
            const limitMB = (limit / (1024 * 1024)).toFixed(0);

            let html = '<div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #0066CC;">';
            html += '<strong>üì¶ Document Storage</strong><br>';
            html += `<div style="margin-top: 8px; font-size: 0.85rem;">`;
            html += `Storage used: ${totalMB} MB / ${limitMB} MB (${percentUsed}%)`;

            // Storage bar
            const barColor = percentUsed > 80 ? '#dc2626' : percentUsed > 60 ? '#f59e0b' : '#10b981';
            html += `<div style="margin-top: 5px; background: #e5e7eb; border-radius: 3px; height: 8px; overflow: hidden;">`;
            html += `<div style="background: ${barColor}; height: 100%; width: ${Math.min(percentUsed, 100)}%;"></div>`;
            html += `</div>`;
            html += `</div>`;

            if (uploadedDocuments.length > 0) {
                html += '<div style="margin-top: 12px; max-height: 200px; overflow-y: auto;">';
                html += '<strong style="font-size: 0.85rem;">Stored Documents:</strong><br>';

                uploadedDocuments.forEach((doc, index) => {
                    const sizeKB = (doc.size / 1024).toFixed(1);
                    const uploadDate = new Date(doc.timestamp).toLocaleDateString();
                    html += `<div style="margin-top: 6px; padding: 6px; background: white; border-radius: 4px; font-size: 0.8rem; display: flex; justify-content: space-between; align-items: center;">`;
                    html += `<div>üìÑ ${doc.name}<br><span style="color: #666; font-size: 0.75rem;">${sizeKB} KB ‚Ä¢ ${uploadDate}</span></div>`;
                    html += `<button onclick="removeDocument(${index})" style="padding: 4px 10px; font-size: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>`;
                    html += `</div>`;
                });

                html += '</div>';

                html += `<div style="margin-top: 10px;">`;
                html += `<button onclick="clearAllDocuments()" style="padding: 6px 12px; font-size: 0.8rem; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer;">üóëÔ∏è Clear All Documents</button>`;
                html += `</div>`;
            } else {
                html += '<div style="margin-top: 8px; font-size: 0.8rem; color: #666;">No documents stored</div>';
            }

            html += '</div>';
            storageUIDiv.innerHTML = html;
        }

        // ============================================================
        // SOAP QUICK-ENTRY FUNCTIONS
        // ============================================================

        /**
         * Toggle SOAP enhancement mode
         * V10: SOAP enhancement is for format/organization only - does NOT use briefing
         */
        function toggleSOAPEnhancement() {
            soapEnhanceMode = document.getElementById('soapEnhanceToggle').checked;

            if (soapEnhanceMode) {
                console.log(`ü§ñ SOAP Enhancement mode: ON (Expand + Format Suggestions)`);
                console.log(`   ‚ÑπÔ∏è V10 PURE MODE: AI suggestions will be in SEPARATE sections`);
                console.log(`   ‚ÑπÔ∏è Briefing is NOT used - only expands what's in your SOAP notes`);
            } else {
                console.log(`ü§ñ SOAP Enhancement mode: OFF (Pure Expand Only)`);
            }

            // Update mode stat display
            document.getElementById('soapMode').textContent = soapEnhanceMode ? 'Enhanced' : 'Expand';

            // V10: No longer show briefing warning since SOAP doesn't use briefing anymore
            document.getElementById('enhanceWarning').style.display = 'none';
        }

        /**
         * Toggle Transcript enhancement mode
         */
        function toggleTranscriptEnhancement() {
            transcriptEnhanceMode = document.getElementById('transcriptEnhanceToggle').checked;
            console.log(`ü§ñ Transcript Enhancement mode: ${transcriptEnhanceMode ? 'ON (Briefing Integration)' : 'OFF (Expand Only)'}`);
        }

        /**
         * Update enhancement toggles based on briefing availability
         */
        function updateEnhancementToggles() {
            const hasBriefing = generatedBriefing && generatedBriefing.length > 0;

            // Update Transcript toggle
            const transcriptToggle = document.getElementById('transcriptEnhanceToggle');
            const transcriptWarning = document.getElementById('transcriptEnhanceWarning');
            const transcriptLabel = document.getElementById('transcriptEnhanceLabel');

            if (transcriptToggle) {
                transcriptToggle.disabled = !hasBriefing;
                transcriptLabel.style.cursor = hasBriefing ? 'pointer' : 'not-allowed';
                transcriptLabel.style.opacity = hasBriefing ? '1' : '0.6';

                if (hasBriefing) {
                    transcriptWarning.style.display = 'none';
                } else {
                    transcriptWarning.style.display = 'block';
                    transcriptToggle.checked = false;
                    transcriptEnhanceMode = false;
                }
            }

            // Update SOAP toggle
            const soapToggle = document.getElementById('soapEnhanceToggle');
            const soapWarning = document.getElementById('enhanceWarning');

            if (soapToggle) {
                soapToggle.disabled = !hasBriefing;

                // Update parent label styling
                const soapLabel = soapToggle.closest('label');
                if (soapLabel) {
                    soapLabel.style.cursor = hasBriefing ? 'pointer' : 'not-allowed';
                    soapLabel.style.opacity = hasBriefing ? '1' : '0.6';
                }

                if (hasBriefing) {
                    soapWarning.style.display = 'none';
                } else {
                    soapWarning.innerHTML = 'üí° <strong>Note:</strong> Generate a briefing first to enable Enhanced Mode';
                    soapWarning.style.display = 'block';
                    soapToggle.checked = false;
                    soapEnhanceMode = false;
                }
            }

            console.log(`üîÑ Enhancement toggles updated: ${hasBriefing ? 'ENABLED' : 'DISABLED'}`);
        }

        /**
         * =====================================================
         * V6 INTERACTIVE REVIEW SYSTEM - Parser & UI Functions
         * =====================================================
         */

        /**
         * Parse AI suggestions from generated note
         * @param {string} noteText - The generated note containing AI_SUGGESTION markers
         * @returns {Array} Array of suggestion objects
         */
        function parseAISuggestions(noteText) {
            const suggestions = [];
            const regex = /<!-- AI_SUGGESTION (.*?) -->([\s\S]*?)<!-- \/AI_SUGGESTION -->/g;
            let match;
            let index = 0;

            while ((match = regex.exec(noteText)) !== null) {
                const attrs = match[1];
                const content = match[2].trim();

                // Parse attributes
                const typeMatch = attrs.match(/type="([^"]+)"/);
                const idMatch = attrs.match(/id="([^"]+)"/);
                const categoryMatch = attrs.match(/category="([^"]+)"/);
                const dependsMatch = attrs.match(/depends-on="([^"]*)"/);

                suggestions.push({
                    id: idMatch ? idMatch[1] : `ai-${index}`,
                    type: typeMatch ? typeMatch[1] : 'unknown',
                    category: categoryMatch ? categoryMatch[1] : 'general',
                    dependsOn: dependsMatch && dependsMatch[1] ? dependsMatch[1].split(',').map(d => d.trim()).filter(d => d) : [],
                    content: content,
                    startPos: match.index,
                    endPos: match.index + match[0].length,
                    fullMatch: match[0],
                    kept: true  // Default to keeping suggestions
                });
                index++;
            }

            console.log(`üìä Parsed ${suggestions.length} AI suggestions`);
            return suggestions;
        }

        /**
         * V8 MITIGATION: Detect fabrications in AI suggestions
         * Checks for prohibited terms and unsupported inferences in expert analysis
         * @param {Array} suggestions - Array of parsed AI suggestions
         * @param {string} sourceText - Original transcript/SOAP notes
         * @returns {object} - Detection results with warnings and errors
         */
        function detectSuggestionFabrications(suggestions, sourceText) {
            console.log('üîç [Fabrication] Checking AI suggestions for prohibited content...');

            const warnings = [];
            const errors = [];

            // Define prohibited terms (especially psychiatric symptoms)
            const prohibitedTerms = {
                psychiatric: [
                    'suicidal ideation', 'suicide', 'suicidal',
                    'depression', 'depressed', 'depressive',
                    'anxiety', 'anxious', 'panic',
                    'psychosis', 'psychotic',
                    'mental health', 'psychological distress',
                    'psychiatric', 'mental illness'
                ],
                social: [
                    'smoking', 'smoker', 'tobacco',
                    'alcohol use', 'drinking', 'alcoholic',
                    'drug use', 'substance abuse',
                    'employment', 'unemployed', 'job',
                    'marital', 'divorced', 'married'
                ],
                family: [
                    'family history of', 'genetic predisposition',
                    'hereditary', 'runs in family'
                ]
            };

            // Check if term is actually documented in source
            function isDocumented(term, source) {
                const termLower = term.toLowerCase();
                const sourceLower = source.toLowerCase();

                // Check for exact phrase
                if (sourceLower.includes(termLower)) {
                    return true;
                }

                // Check for variations (e.g., "suicide" for "suicidal ideation")
                const rootWords = termLower.split(' ')[0];
                if (rootWords.length > 4 && sourceLower.includes(rootWords)) {
                    // Verify it's actually related
                    const context = sourceLower.substring(
                        Math.max(0, sourceLower.indexOf(rootWords) - 50),
                        Math.min(sourceLower.length, sourceLower.indexOf(rootWords) + 50)
                    );
                    if (context.includes(termLower)) {
                        return true;
                    }
                }

                return false;
            }

            // Check each suggestion
            suggestions.forEach(suggestion => {
                const contentLower = suggestion.content.toLowerCase();

                // Check prohibited terms by category
                Object.keys(prohibitedTerms).forEach(category => {
                    prohibitedTerms[category].forEach(term => {
                        if (contentLower.includes(term.toLowerCase())) {
                            // Check if it's documented in source
                            if (!isDocumented(term, sourceText)) {
                                const error = {
                                    suggestionId: suggestion.id,
                                    suggestionType: suggestion.type,
                                    category: category,
                                    term: term,
                                    confidence: 0.95,
                                    message: `üö® FABRICATION DETECTED: "${term}" found in ${suggestion.type} but NOT documented in source`,
                                    excerpt: extractExcerpt(suggestion.content, term),
                                    severity: 'CRITICAL'
                                };

                                errors.push(error);
                                console.error(`‚ùå [Fabrication] ${error.message}`);
                                console.error(`   Excerpt: "${error.excerpt}"`);
                            }
                        }
                    });
                });

                // Check for inference patterns (even if not using prohibited terms)
                const inferencePatterns = [
                    /impacting mental health/i,
                    /psychological impact/i,
                    /affecting mood/i,
                    /mental well-being/i,
                    /emotional distress/i
                ];

                inferencePatterns.forEach(pattern => {
                    if (pattern.test(suggestion.content)) {
                        const match = suggestion.content.match(pattern);
                        if (match && !isDocumented(match[0], sourceText)) {
                            const warning = {
                                suggestionId: suggestion.id,
                                suggestionType: suggestion.type,
                                term: match[0],
                                confidence: 0.75,
                                message: `‚ö†Ô∏è Possible inference: "${match[0]}" in ${suggestion.type} - verify it's grounded`,
                                excerpt: extractExcerpt(suggestion.content, match[0])
                            };

                            warnings.push(warning);
                            console.warn(`‚ö†Ô∏è [Fabrication] ${warning.message}`);
                        }
                    }
                });
            });

            // Helper to extract context around a term
            function extractExcerpt(text, term) {
                const termIndex = text.toLowerCase().indexOf(term.toLowerCase());
                if (termIndex === -1) return text.substring(0, 100) + '...';

                const start = Math.max(0, termIndex - 50);
                const end = Math.min(text.length, termIndex + term.length + 50);

                return '...' + text.substring(start, end) + '...';
            }

            const result = {
                checked: suggestions.length,
                errors: errors,
                warnings: warnings,
                clean: errors.length === 0 && warnings.length === 0
            };

            if (result.clean) {
                console.log(`‚úÖ [Fabrication] All ${suggestions.length} suggestions appear clean`);
            } else {
                console.log(`‚ùå [Fabrication] Found ${errors.length} errors and ${warnings.length} warnings`);
            }

            return result;
        }

        /**
         * V8 MITIGATION: Check DOAP/ULTRATHINK summaries for prohibited terms
         * Simplified check for compressed summaries
         * @param {string} summary - Generated DOAP/ULTRATHINK summary
         * @param {string} sourceText - Original transcript/SOAP notes
         * @returns {object} - Detection results
         */
        function checkDOAPFabrications(summary, sourceText) {
            console.log('üîç [DOAP Fabrication] Checking compressed summary...');

            const warnings = [];
            const errors = [];

            // Define prohibited terms (focus on psychiatric symptoms)
            const prohibitedTerms = [
                'suicidal ideation', 'suicide', 'suicidal',
                'depression', 'depressed', 'depressive',
                'anxiety', 'anxious', 'panic',
                'psychosis', 'psychotic',
                'mental health', 'psychological distress',
                'psychiatric', 'mental illness',
                'affecting mood'
            ];

            const summaryLower = summary.toLowerCase();
            const sourceLower = sourceText.toLowerCase();

            // Check each prohibited term
            prohibitedTerms.forEach(term => {
                if (summaryLower.includes(term.toLowerCase())) {
                    // Check if it's documented in source
                    if (!sourceLower.includes(term.toLowerCase())) {
                        const error = {
                            term: term,
                            confidence: 0.95,
                            message: `üö® FABRICATION in DOAP: "${term}" NOT documented in source`,
                            severity: 'CRITICAL'
                        };

                        errors.push(error);
                        console.error(`‚ùå [DOAP Fabrication] ${error.message}`);
                    }
                }
            });

            const result = {
                clean: errors.length === 0,
                errors: errors,
                warnings: warnings
            };

            if (result.clean) {
                console.log(`‚úÖ [DOAP Fabrication] Summary appears clean`);
            } else {
                console.log(`‚ùå [DOAP Fabrication] Found ${errors.length} errors`);
            }

            return result;
        }

        /**
         * V8 MITIGATION: Display fabrication detection results in validation panel
         * @param {object} fabricationCheck - Detection results from detectSuggestionFabrications
         */
        function displayFabricationResults(fabricationCheck) {
            const fabricationDetails = document.getElementById('fabrication-details');
            const fabricationScore = document.getElementById('fabrication-score');
            const fabricationProgress = document.querySelector('#fabrication-progress > div');

            if (!fabricationDetails || !fabricationScore || !fabricationProgress) {
                console.error('‚ùå Fabrication panel elements not found');
                return;
            }

            // Calculate score (100 = clean, 0 = many errors)
            const errorPenalty = fabricationCheck.errors.length * 20;
            const warningPenalty = fabricationCheck.warnings.length * 5;
            const score = Math.max(0, 100 - errorPenalty - warningPenalty);

            // Update score display
            fabricationScore.textContent = `${score}/100`;

            if (score >= 80) {
                fabricationScore.style.color = '#28a745';
                fabricationProgress.style.background = '#28a745';
            } else if (score >= 60) {
                fabricationScore.style.color = '#ffc107';
                fabricationProgress.style.background = '#ffc107';
            } else {
                fabricationScore.style.color = '#dc3545';
                fabricationProgress.style.background = '#dc3545';
            }

            fabricationProgress.style.width = `${score}%`;

            // Build details HTML
            let html = '';

            if (fabricationCheck.clean) {
                html = `<div style="color: #28a745; padding: 10px; background: #d4edda; border-radius: 4px; margin-top: 10px;">
                    ‚úÖ <strong>All clear!</strong> Checked ${fabricationCheck.checked} AI suggestions - no prohibited terms or fabrications detected.
                </div>`;
            } else {
                // Show errors
                if (fabricationCheck.errors.length > 0) {
                    html += `<div style="margin-top: 10px; padding: 10px; background: #f8d7da; border-left: 4px solid #dc3545; border-radius: 4px;">
                        <div style="font-weight: 600; color: #721c24; margin-bottom: 8px;">
                            üö® ${fabricationCheck.errors.length} Critical Fabrication(s) Detected:
                        </div>`;

                    fabricationCheck.errors.forEach(error => {
                        html += `<div style="margin-bottom: 10px; padding: 8px; background: white; border-radius: 4px;">
                            <div style="font-weight: 600; color: #dc3545; margin-bottom: 4px;">
                                "${error.term}" in ${error.suggestionType} (${error.category})
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">
                                ${error.message}
                            </div>
                            <div style="font-size: 0.8rem; color: #999; font-style: italic;">
                                ${error.excerpt}
                            </div>
                        </div>`;
                    });

                    html += `</div>`;
                }

                // Show warnings
                if (fabricationCheck.warnings.length > 0) {
                    html += `<div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                        <div style="font-weight: 600; color: #856404; margin-bottom: 8px;">
                            ‚ö†Ô∏è ${fabricationCheck.warnings.length} Warning(s):
                        </div>`;

                    fabricationCheck.warnings.forEach(warning => {
                        html += `<div style="margin-bottom: 10px; padding: 8px; background: white; border-radius: 4px;">
                            <div style="font-weight: 600; color: #ffc107; margin-bottom: 4px;">
                                "${warning.term}" in ${warning.suggestionType}
                            </div>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">
                                ${warning.message}
                            </div>
                            <div style="font-size: 0.8rem; color: #999; font-style: italic;">
                                ${warning.excerpt}
                            </div>
                        </div>`;
                    });

                    html += `</div>`;
                }
            }

            fabricationDetails.innerHTML = html;
            fabricationDetails.style.display = 'block';

            console.log(`‚úÖ Fabrication results displayed: ${score}/100 (${fabricationCheck.errors.length} errors, ${fabricationCheck.warnings.length} warnings)`);
        }

        /**
         * Display suggestions in review interface
         * @param {Array} suggestions - Array of parsed suggestions
         */
        function displayReviewInterface(suggestions) {
            const container = document.getElementById('reviewInterface');

            if (!container) {
                console.error('‚ùå Review interface container not found');
                return;
            }

            if (suggestions.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; padding: 20px; font-style: italic;">No AI suggestions found in this note. The note contains only documented facts.</p>';
                return;
            }

            // Group by category
            const grouped = {
                subjective: [],
                objective: [],
                assessment: [],
                plan: [],
                general: []
            };

            suggestions.forEach(s => {
                if (grouped[s.category]) {
                    grouped[s.category].push(s);
                } else {
                    grouped.general.push(s);
                }
            });

            let html = '';

            // Render each category
            Object.keys(grouped).forEach(category => {
                if (grouped[category].length === 0) return;

                const categoryTitle = category.charAt(0).toUpperCase() + category.slice(1);
                html += `<div class="suggestion-category" style="margin-bottom: 25px;">`;
                html += `<h3 style="color: #4A90E2; font-size: 1.1rem; margin-bottom: 12px; font-weight: 600;">${categoryTitle} Section</h3>`;

                grouped[category].forEach(suggestion => {
                    const typeLabel = getSuggestionTypeLabel(suggestion.type);
                    const icon = getSuggestionIcon(suggestion.type);
                    const hasDeps = suggestion.dependsOn.length > 0;

                    html += `
                    <div class="suggestion-item" style="background: #f9fafb; border: 1px solid #E1E4E8; border-radius: 6px; padding: 14px; margin-bottom: 12px; transition: all 0.2s;">
                        <label style="display: flex; align-items: start; cursor: pointer; user-select: none;">
                            <input type="checkbox"
                                   id="suggestion-${suggestion.id}"
                                   data-suggestion-id="${suggestion.id}"
                                   onchange="toggleSuggestion('${suggestion.id}')"
                                   ${suggestion.kept ? 'checked' : ''}
                                   style="margin-right: 12px; margin-top: 4px; width: 18px; height: 18px; cursor: pointer; flex-shrink: 0; accent-color: #4A90E2;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: #24292e; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                                    <span>${icon} ${typeLabel}</span>
                                    ${hasDeps ? '<span style="font-size: 0.75rem; color: #6a737d; font-weight: normal; background: #fff; padding: 2px 6px; border-radius: 3px; border: 1px solid #e1e4e8;">üîó linked</span>' : ''}
                                </div>
                                <div style="background: white; padding: 12px; border-radius: 4px; border: 1px solid #e1e4e8; white-space: pre-wrap; font-size: 0.9rem; line-height: 1.6; color: #24292e; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;">
${escapeHtml(suggestion.content)}</div>
                            </div>
                        </label>
                    </div>`;
                });

                html += `</div>`;
            });

            container.innerHTML = html;
            console.log(`‚úÖ Review interface displayed with ${suggestions.length} suggestions`);
        }

        /**
         * Get human-readable label for suggestion type
         * @param {string} type - Suggestion type code
         * @returns {string} Human-readable label
         */
        function getSuggestionTypeLabel(type) {
            const labels = {
                'clinical-analysis': 'Clinical Analysis',
                'differential': 'Differential Diagnosis',
                'recommendation': 'Management Recommendation',
                'pearl': 'Clinical Pearl',
                'red-flag': 'Red Flag Alert',
                'gap-analysis': 'Clinical Gaps Identified',
                'evidence': 'Evidence-Based Analysis',
                'workup': 'Diagnostic Workup',
                'scales': 'Clinical Scales Assessment'
            };
            return labels[type] || type.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        /**
         * Get icon for suggestion type
         * @param {string} type - Suggestion type code
         * @returns {string} Emoji icon
         */
        function getSuggestionIcon(type) {
            const icons = {
                'clinical-analysis': 'ü§ñ',
                'differential': 'üéØ',
                'recommendation': 'üíä',
                'pearl': 'üíé',
                'red-flag': '‚ö†Ô∏è',
                'gap-analysis': 'üìã',
                'evidence': 'üìä',
                'workup': 'üî¨',
                'scales': 'üìè'
            };
            return icons[type] || 'üìù';
        }

        /**
         * Escape HTML special characters
         * @param {string} text - Text to escape
         * @returns {string} Escaped text
         */
        function escapeHtml(text) {
            if (!text) return '';
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;',
                '/': '&#x2F;'
            };
            return String(text).replace(/[&<>"'\/]/g, char => map[char]);
        }

        /**
         * Sanitize HTML - allows specific safe tags only
         * @param {string} html - HTML to sanitize
         * @param {Array} allowedTags - Tags to allow (default: safe formatting tags)
         * @returns {string} Sanitized HTML
         */
        function sanitizeHtml(html, allowedTags = ['b', 'i', 'strong', 'em', 'p', 'br', 'span', 'div']) {
            if (!html) return '';

            const temp = document.createElement('div');
            temp.innerHTML = html;

            // Remove all script tags and event handlers
            const scripts = temp.querySelectorAll('script');
            scripts.forEach(script => script.remove());

            // Remove all elements except allowed tags
            const allElements = temp.querySelectorAll('*');
            allElements.forEach(el => {
                if (!allowedTags.includes(el.tagName.toLowerCase())) {
                    // Replace disallowed tag with its text content
                    const text = document.createTextNode(el.textContent);
                    el.parentNode.replaceChild(text, el);
                }

                // Remove all event handlers
                Array.from(el.attributes).forEach(attr => {
                    if (attr.name.startsWith('on')) {
                        el.removeAttribute(attr.name);
                    }
                });

                // Remove dangerous attributes
                ['src', 'href', 'data', 'action', 'formaction'].forEach(attr => {
                    if (el.hasAttribute(attr)) {
                        const value = el.getAttribute(attr);
                        if (value && (value.startsWith('javascript:') || value.startsWith('data:'))) {
                            el.removeAttribute(attr);
                        }
                    }
                });
            });

            return temp.innerHTML;
        }

        /**
         * Safe setter for innerHTML - automatically sanitizes
         * @param {HTMLElement} element - Element to set innerHTML on
         * @param {string} html - HTML content
         * @param {boolean} sanitize - Whether to sanitize (default: true)
         */
        function safeSetInnerHTML(element, html, sanitize = true) {
            if (!element) return;
            element.innerHTML = sanitize ? sanitizeHtml(html) : html;
        }

        /**
         * =====================================================
         * API RATE LIMITER
         * =====================================================
         * Prevents API quota exhaustion by limiting requests
         */
        class RateLimiter {
            constructor(maxCalls = 10, perMilliseconds = 60000) {
                this.maxCalls = maxCalls;
                this.perMilliseconds = perMilliseconds;
                this.callTimestamps = [];
                this.queue = [];
                this.isProcessing = false;
            }

            /**
             * Throttle an async function call
             * @param {Function} fn - Async function to throttle
             * @returns {Promise} Result of the function
             */
            async throttle(fn) {
                const now = Date.now();

                // Remove timestamps older than the time window
                this.callTimestamps = this.callTimestamps.filter(
                    timestamp => now - timestamp < this.perMilliseconds
                );

                // Check if we're at the rate limit
                if (this.callTimestamps.length >= this.maxCalls) {
                    const oldestCall = Math.min(...this.callTimestamps);
                    const waitTime = this.perMilliseconds - (now - oldestCall);

                    console.warn(`‚ö†Ô∏è  Rate limit reached. Waiting ${Math.ceil(waitTime / 1000)}s before next API call...`);

                    // Show user feedback
                    const statusEl = document.getElementById('status');
                    if (statusEl) {
                        const originalText = statusEl.textContent;
                        statusEl.className = 'status warning';
                        statusEl.textContent = `‚è≥ Rate limit: waiting ${Math.ceil(waitTime / 1000)}s...`;

                        // Wait for the required time
                        await new Promise(resolve => setTimeout(resolve, waitTime + 100));

                        // Restore original status
                        statusEl.textContent = originalText;
                        statusEl.className = 'status connected';
                    } else {
                        await new Promise(resolve => setTimeout(resolve, waitTime + 100));
                    }

                    // Clean up old timestamps again after waiting
                    const newNow = Date.now();
                    this.callTimestamps = this.callTimestamps.filter(
                        timestamp => newNow - timestamp < this.perMilliseconds
                    );
                }

                // Record this call
                this.callTimestamps.push(Date.now());

                // Execute the function
                return await fn();
            }

            /**
             * Get current rate limit status
             * @returns {Object} Status object with remaining calls and reset time
             */
            getStatus() {
                const now = Date.now();
                this.callTimestamps = this.callTimestamps.filter(
                    timestamp => now - timestamp < this.perMilliseconds
                );

                const remaining = this.maxCalls - this.callTimestamps.length;
                const resetTime = this.callTimestamps.length > 0
                    ? Math.max(...this.callTimestamps) + this.perMilliseconds
                    : now;

                return {
                    remaining,
                    limit: this.maxCalls,
                    resetIn: Math.max(0, resetTime - now),
                    resetTime: new Date(resetTime)
                };
            }

            /**
             * Reset the rate limiter (useful for testing or manual override)
             */
            reset() {
                this.callTimestamps = [];
                this.queue = [];
                console.log('‚úÖ Rate limiter reset');
            }
        }

        // Initialize global rate limiter
        // Conservative limit to prevent quota exhaustion
        const apiRateLimiter = new RateLimiter(
            CONSTANTS.API.RATE_LIMIT_CALLS,
            CONSTANTS.API.RATE_LIMIT_WINDOW
        );

        /**
         * =====================================================
         * ERROR BOUNDARIES & GRACEFUL DEGRADATION
         * =====================================================
         */

        /**
         * Global error handler for graceful degradation
         */
        class ErrorBoundary {
            constructor(componentName, fallbackUI) {
                this.componentName = componentName;
                this.fallbackUI = fallbackUI;
                this.errorCount = 0;
                this.lastError = null;
            }

            /**
             * Wrap a function with error handling
             * @param {Function} fn - Function to wrap
             * @param {Object} options - Options for error handling
             * @returns {Function} Wrapped function
             */
            wrap(fn, options = {}) {
                const {
                    showFallback = true,
                    retryable = false,
                    maxRetries = 3,
                    silent = false
                } = options;

                return async (...args) => {
                    let attempt = 0;
                    while (attempt < (retryable ? maxRetries : 1)) {
                        try {
                            return await fn(...args);
                        } catch (error) {
                            attempt++;
                            this.errorCount++;
                            this.lastError = error;

                            console.error(`‚ùå Error in ${this.componentName}:`, error);

                            // Show user-friendly error message
                            if (!silent) {
                                this.showError(error, attempt, maxRetries, retryable);
                            }

                            // If retryable and not last attempt, wait and retry
                            if (retryable && attempt < maxRetries) {
                                console.log(`üîÑ Retrying ${this.componentName} (attempt ${attempt + 1}/${maxRetries})...`);
                                await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                                continue;
                            }

                            // Show fallback UI if applicable
                            if (showFallback && this.fallbackUI) {
                                this.renderFallback(error);
                            }

                            // Re-throw if not recoverable
                            if (!retryable && !showFallback) {
                                throw error;
                            }

                            return null;
                        }
                    }
                };
            }

            /**
             * Show error toast notification
             */
            showError(error, attempt, maxRetries, retryable) {
                const statusEl = document.getElementById('status');
                if (!statusEl) return;

                const message = this.getUserFriendlyMessage(error);

                statusEl.className = 'status error';
                statusEl.textContent = `‚ùå ${message}`;

                if (retryable && attempt < maxRetries) {
                    statusEl.textContent += ` (Retrying ${attempt}/${maxRetries})`;
                }

                // Auto-hide after 5 seconds
                setTimeout(() => {
                    if (statusEl.className === 'status error') {
                        statusEl.className = 'status connected';
                        statusEl.textContent = '‚úÖ API Key Loaded - Ready to Generate';
                    }
                }, 5000);
            }

            /**
             * Get user-friendly error message
             */
            getUserFriendlyMessage(error) {
                if (error.message.includes('Failed to fetch')) {
                    return 'Network error - check your connection';
                }
                if (error.message.includes('API key')) {
                    return 'API key error - check settings';
                }
                if (error.message.includes('quota')) {
                    return 'API quota exceeded - try again later';
                }
                if (error.message.includes('timeout')) {
                    return 'Request timed out - try again';
                }
                return `Error in ${this.componentName}`;
            }

            /**
             * Render fallback UI
             */
            renderFallback(error) {
                const container = document.getElementById(this.componentName);
                if (!container) return;

                const fallbackHTML = typeof this.fallbackUI === 'function'
                    ? this.fallbackUI(error, this)
                    : this.fallbackUI;

                safeSetInnerHTML(container, fallbackHTML, false);
            }

            /**
             * Reset error state
             */
            reset() {
                this.errorCount = 0;
                this.lastError = null;
            }
        }

        /**
         * Default fallback UI generator
         */
        function createFallbackUI(componentName) {
            return (error, boundary) => `
                <div style="padding: 20px; background: #fee2e2; border: 2px solid #dc2626; border-radius: 8px; margin: 10px 0;">
                    <h3 style="color: #991b1b; margin-bottom: 10px;">‚ö†Ô∏è Error in ${componentName}</h3>
                    <p style="color: #7f1d1d; margin-bottom: 10px;">
                        ${boundary.getUserFriendlyMessage(error)}
                    </p>
                    <p style="color: #7f1d1d; font-size: 0.9em; margin-bottom: 15px;">
                        Don't worry - you can still use other features.
                    </p>
                    <button
                        onclick="location.reload()"
                        style="background: #dc2626; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                        üîÑ Reload Page
                    </button>
                    <button
                        onclick="this.parentElement.style.display='none'"
                        style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 10px;">
                        ‚úï Dismiss
                    </button>
                </div>
            `;
        }

        // Initialize error boundaries for critical components
        const validationBoundary = new ErrorBoundary('validation', createFallbackUI('Validation'));
        const generationBoundary = new ErrorBoundary('generation', createFallbackUI('Generation'));
        const briefingBoundary = new ErrorBoundary('briefing', createFallbackUI('Briefing'));

        /**
         * Global error handler for uncaught errors
         */
        window.addEventListener('error', (event) => {
            console.error('üö® Uncaught error:', event.error);

            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.className = 'status error';
                statusEl.textContent = '‚ùå An error occurred - check console for details';
            }

            // Prevent default browser error handling
            event.preventDefault();
        });

        /**
         * Global handler for unhandled promise rejections
         */
        window.addEventListener('unhandledrejection', (event) => {
            console.error('üö® Unhandled promise rejection:', event.reason);

            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.className = 'status error';
                statusEl.textContent = '‚ùå An error occurred - the app is still functional';
            }

            // Prevent default browser error handling
            event.preventDefault();
        });

        /**
         * =====================================================
         * V6 INTERACTIVE REVIEW SYSTEM - Interaction Logic
         * =====================================================
         */

        /**
         * Toggle a suggestion on/off
         * @param {string} id - Suggestion ID
         */
        function toggleSuggestion(id) {
            const checkbox = document.getElementById(`suggestion-${id}`);
            const suggestion = currentSuggestions.find(s => s.id === id);

            if (!suggestion) {
                console.error(`‚ùå Suggestion ${id} not found`);
                return;
            }

            suggestion.kept = checkbox.checked;
            console.log(`${suggestion.kept ? '‚úÖ KEPT' : '‚ùå DISCARDED'}: ${getSuggestionTypeLabel(suggestion.type)} (${id})`);

            // Smart dependencies - ask about related items when discarding
            if (!suggestion.kept) {
                handleDependencies(id);
            }
        }

        /**
         * Handle smart dependencies when discarding a suggestion
         * @param {string} parentId - ID of the suggestion being discarded
         */
        function handleDependencies(parentId) {
            // Find suggestions that depend on this one
            const dependents = currentSuggestions.filter(s =>
                s.dependsOn.includes(parentId) && s.kept
            );

            if (dependents.length === 0) return;

            // Build list of dependent items
            const dependentNames = dependents.map(d =>
                `‚Ä¢ ${getSuggestionIcon(d.type)} ${getSuggestionTypeLabel(d.type)}`
            ).join('\n');

            const shouldDiscard = confirm(
                `‚ö†Ô∏è LINKED SUGGESTIONS DETECTED\n\n` +
                `The following ${dependents.length} suggestion(s) depend on the item you just discarded:\n\n` +
                `${dependentNames}\n\n` +
                `Would you like to also discard these related items?\n\n` +
                `Click OK to discard related items, or Cancel to keep them.`
            );

            if (shouldDiscard) {
                dependents.forEach(dep => {
                    dep.kept = false;
                    const checkbox = document.getElementById(`suggestion-${dep.id}`);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                    console.log(`üîó Auto-discarded dependent: ${dep.id}`);
                });

                console.log(`‚úÖ Discarded ${dependents.length} dependent suggestion(s)`);
            } else {
                console.log(`‚ÑπÔ∏è Kept ${dependents.length} dependent suggestion(s)`);
            }
        }

        /**
         * Select all suggestions (check all checkboxes)
         */
        function selectAllSuggestions() {
            if (currentSuggestions.length === 0) {
                alert('‚ÑπÔ∏è No suggestions to select. Generate a note with Enhanced Mode first.');
                return;
            }

            currentSuggestions.forEach(s => {
                s.kept = true;
                const checkbox = document.getElementById(`suggestion-${s.id}`);
                if (checkbox) checkbox.checked = true;
            });

            console.log(`‚úÖ All ${currentSuggestions.length} suggestions kept`);
        }

        /**
         * Deselect all suggestions (uncheck all checkboxes)
         */
        function deselectAllSuggestions() {
            if (currentSuggestions.length === 0) {
                alert('‚ÑπÔ∏è No suggestions to deselect.');
                return;
            }

            const confirmed = confirm(
                `‚ö†Ô∏è DISCARD ALL SUGGESTIONS?\n\n` +
                `This will remove all ${currentSuggestions.length} AI-generated suggestions from your final note.\n\n` +
                `Only your documented facts will remain.\n\n` +
                `Click OK to discard all, or Cancel to keep them.`
            );

            if (!confirmed) return;

            currentSuggestions.forEach(s => {
                s.kept = false;
                const checkbox = document.getElementById(`suggestion-${s.id}`);
                if (checkbox) checkbox.checked = false;
            });

            console.log(`‚ùå All ${currentSuggestions.length} suggestions discarded`);
        }

        /**
         * =====================================================
         * V6 INTERACTIVE REVIEW SYSTEM - Final Note Generator
         * =====================================================
         */

        /**
         * Generate final clean note with only kept suggestions
         */
        async function generateFinalNote() {
            if (currentSuggestions.length === 0) {
                alert('‚ÑπÔ∏è No suggestions to process. This note contains only documented facts and is already finalized.');
                return;
            }

            console.log('üìÑ Generating final clean note...');

            // Get the raw generated note
            const rawNote = document.getElementById('output').value;
            if (!rawNote) {
                alert('‚ùå No note content found. Please generate a note first.');
                return;
            }

            let finalNote = rawNote;

            // Count kept vs discarded
            const keptCount = currentSuggestions.filter(s => s.kept).length;
            const discardedCount = currentSuggestions.length - keptCount;

            console.log(`üìä Processing: ${keptCount} kept, ${discardedCount} discarded`);

            // Remove all AI_SUGGESTION markers and their content
            currentSuggestions.forEach(suggestion => {
                if (suggestion.kept) {
                    // Keep the content but remove the markers
                    finalNote = finalNote.replace(
                        suggestion.fullMatch,
                        suggestion.content
                    );
                } else {
                    // Remove entirely (markers + content)
                    finalNote = finalNote.replace(suggestion.fullMatch, '');
                }
            });

            // Clean up formatting
            finalNote = cleanFinalNote(finalNote);

            // Display in new tab
            displayFinalNote(finalNote, keptCount, discardedCount);

            // Generate ALL compression levels automatically from final note
            console.log('üìä Auto-generating compressed and ultracompressed summaries...');

            // Store the full note
            currentNoteVersions.full = finalNote;

            // Generate standard compression (independent)
            currentNoteVersions.status.standard = 'generating';
            updateCompressionStatusBadges();
            try {
                const standardSummary = await generateAttendingSummary(finalNote);
                currentNoteVersions.standard = standardSummary || '';
                currentNoteVersions.status.standard = 'ready';
                updateCompressionStatusBadges();
                console.log('‚úÖ Standard compression generated');
            } catch (standardError) {
                console.error('‚ùå Standard compression failed:', standardError.message);
                currentNoteVersions.standard = '‚ö†Ô∏è Standard compression failed. Click "Regenerate" to retry.';
                currentNoteVersions.status.standard = 'failed';
                updateCompressionStatusBadges();
            }

            // Generate ULTRA compression (independent)
            currentNoteVersions.status.ultra = 'generating';
            updateCompressionStatusBadges();
            try {
                const ultraSummary = await generateUltraAttendingSummary(finalNote);
                currentNoteVersions.ultra = ultraSummary || '';
                currentNoteVersions.status.ultra = 'ready';
                updateCompressionStatusBadges();
                console.log('‚úÖ ULTRA compression generated');
            } catch (ultraError) {
                console.error('‚ùå ULTRA compression failed:', ultraError.message);
                currentNoteVersions.ultra = '‚ö†Ô∏è ULTRA compression failed. Click "Regenerate" to retry.';
                currentNoteVersions.status.ultra = 'failed';
                updateCompressionStatusBadges();
            }

            // Generate Telegram compression (independent)
            currentNoteVersions.status.telegram = 'generating';
            updateCompressionStatusBadges();
            try {
                const telegramSummary = await generateTelegramSummary(finalNote);
                currentNoteVersions.telegram = telegramSummary || '';
                currentNoteVersions.status.telegram = 'ready';
                updateCompressionStatusBadges();
                console.log('‚úÖ Telegram compression generated');
            } catch (telegramError) {
                console.error('‚ùå Telegram compression failed:', telegramError.message);
                currentNoteVersions.telegram = '‚ö†Ô∏è Telegram compression failed. Click "Regenerate" to retry.';
                currentNoteVersions.status.telegram = 'failed';
                updateCompressionStatusBadges();
            }

            // Display based on currently selected compression mode
            const selectedMode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
            const summaryToDisplay = selectedMode === 'ultra' ? currentNoteVersions.ultra
                                   : selectedMode === 'telegram' ? currentNoteVersions.telegram
                                   : currentNoteVersions.standard;

            if (summaryToDisplay && !summaryToDisplay.includes('failed')) {
                displayAttendingSummary(summaryToDisplay, selectedMode);
            } else if (summaryToDisplay) {
                // Show error message in textarea
                displayAttendingSummary(summaryToDisplay, selectedMode);
            } else {
                console.warn('‚ö†Ô∏è No summary generated');
            }
        }

        /**
         * Clean final note formatting for EMR
         * @param {string} note - Note text to clean
         * @returns {string} Cleaned note
         */
        function cleanFinalNote(note) {
            return note
                // Remove emoji markers
                .replace(/üìù DOCUMENTED:/g, '')
                .replace(/üìù /g, '')
                .replace(/ü§ñ CLINICAL ANALYSIS:/g, 'CLINICAL ANALYSIS:')
                .replace(/ü§ñ DIFFERENTIAL DIAGNOSIS:/g, 'DIFFERENTIAL DIAGNOSIS:')
                .replace(/ü§ñ EVIDENCE-BASED RECOMMENDATIONS:/g, 'RECOMMENDATIONS:')
                .replace(/ü§ñ CLINICAL GAPS IDENTIFIED:/g, 'CLINICAL GAPS:')
                .replace(/ü§ñ /g, '')
                .replace(/üí° CLINICAL PEARL:/g, 'CLINICAL PEARL:')
                .replace(/üí° /g, '')
                .replace(/‚ö†Ô∏è RED FLAG ALERT:/g, 'IMPORTANT:')
                .replace(/‚ö†Ô∏è RED FLAGS:/g, 'RED FLAGS:')
                .replace(/‚ö†Ô∏è /g, '')
                .replace(/üìä Evidence Level:/g, 'Evidence Level:')
                .replace(/üìä /g, '')
                .replace(/üî¨ RECOMMENDED DIAGNOSTIC WORKUP/g, 'DIAGNOSTIC WORKUP')
                .replace(/üî¨ /g, '')
                .replace(/üíä EVIDENCE-BASED MANAGEMENT PLAN/g, 'MANAGEMENT PLAN')
                .replace(/üíä /g, '')
                .replace(/üìè CLINICAL SCALES ASSESSMENT/g, 'CLINICAL SCALES ASSESSMENT')
                .replace(/üìè /g, '')
                .replace(/üîó /g, '')
                .replace(/üéØ /g, '')
                .replace(/üíé /g, '')
                .replace(/üìã /g, '')

                // Remove multiple blank lines (max 2 consecutive)
                .replace(/\n{4,}/g, '\n\n\n')
                .replace(/\n{3,}/g, '\n\n')

                // Remove trailing whitespace from lines
                .replace(/[ \t]+$/gm, '')

                // Clean up spacing around headers
                .replace(/\n\n##/g, '\n\n\n##')
                .replace(/##([^\n])/g, '## $1')

                .trim();
        }

        /**
         * Display final note in dedicated tab
         * @param {string} finalNote - The cleaned final note
         * @param {number} keptCount - Number of kept suggestions
         * @param {number} discardedCount - Number of discarded suggestions
         */
        function displayFinalNote(finalNote, keptCount, discardedCount) {
            // Check if Final Note tab already exists
            let finalTab = document.getElementById('tab-final');
            let finalButton = document.getElementById('final-tab-button');

            if (!finalTab) {
                // Create the tab button
                const tabButtons = document.querySelector('.tab-buttons');
                finalButton = document.createElement('button');
                finalButton.className = 'tab-button';
                finalButton.id = 'final-tab-button';
                finalButton.onclick = () => switchTab('final');
                finalButton.innerHTML = 'üìÑ Final Note';
                tabButtons.appendChild(finalButton);

                // Create the tab content
                const outputPanel = document.querySelector('#tab-export').parentElement;
                finalTab = document.createElement('div');
                finalTab.className = 'tab-content';
                finalTab.id = 'tab-final';
                finalTab.style.display = 'none';
                finalTab.innerHTML = `
                    <div style="background: #d4edda; padding: 14px; border-radius: 6px; margin-bottom: 20px; color: #155724; border-left: 4px solid #28a745;">
                        <strong>‚úÖ Final Clean Note:</strong> Professional clinical documentation ready for medical record.
                        All markers and emojis removed. You can edit before exporting.
                    </div>

                    <div id="finalNoteSummary" style="background: #f6f8fa; padding: 12px; border-radius: 6px; margin-bottom: 15px; font-size: 0.9rem; color: #24292e; display: flex; gap: 20px; justify-content: center; border: 1px solid #e1e4e8;">
                        <span id="finalKeptCount"></span>
                        <span id="finalDiscardedCount"></span>
                    </div>

                    <textarea id="finalNoteText"
                              style="width: 100%; min-height: 500px; font-family: 'Courier New', Courier, monospace; font-size: 0.95rem; padding: 15px; border: 2px solid #E1E4E8; border-radius: 6px; line-height: 1.6; resize: both;"
                              placeholder="Final note will appear here..."></textarea>

                    <div style="margin-top: 15px; display: flex; gap: 12px;">
                        <button onclick="copyFinalNote()" class="success" style="flex: 1; padding: 12px;">
                            üìã Copy to Clipboard
                        </button>
                        <button onclick="downloadFinalNote()" class="success" style="flex: 1; padding: 12px;">
                            üíæ Download as TXT
                        </button>
                        <button onclick="printFinalNote()" style="flex: 1; padding: 12px;">
                            üñ®Ô∏è Print Note
                        </button>
                    </div>
                `;
                outputPanel.appendChild(finalTab);

                console.log('üìÑ Final Note tab created');
            }

            // Update summary
            document.getElementById('finalKeptCount').textContent = `‚úÖ ${keptCount} suggestions kept`;
            document.getElementById('finalDiscardedCount').textContent = `‚ùå ${discardedCount} discarded`;

            // Set the final note text
            document.getElementById('finalNoteText').value = finalNote;

            // Switch to the Final Note tab
            switchTab('final');

            console.log('‚úÖ Final note generated and displayed');
        }

        /**
         * Copy final note to clipboard
         */
        function copyFinalNote() {
            const finalNote = document.getElementById('finalNoteText');
            if (!finalNote || !finalNote.value) {
                alert('‚ùå No final note to copy. Generate the final note first.');
                return;
            }

            finalNote.select();
            finalNote.setSelectionRange(0, 99999); // For mobile

            try {
                document.execCommand('copy');
                alert('‚úÖ Final note copied to clipboard!');
                console.log('üìã Final note copied to clipboard');
            } catch (err) {
                alert('‚ùå Failed to copy. Please select and copy manually.');
                console.error('Copy failed:', err);
            }
        }

        /**
         * Download final note as text file
         */
        function downloadFinalNote() {
            const text = document.getElementById('finalNoteText').value;
            if (!text) {
                alert('‚ùå No final note to download. Generate the final note first.');
                return;
            }

            const patientName = document.getElementById('patientName').value || 'Patient';
            const dateStr = new Date().toISOString().slice(0, 10);
            const filename = `Clinical_Note_${patientName.replace(/\s+/g, '_')}_${dateStr}.txt`;

            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log(`üíæ Downloaded: ${filename}`);
        }

        /**
         * Print final note
         */
        function printFinalNote() {
            const text = document.getElementById('finalNoteText').value;
            if (!text) {
                alert('‚ùå No final note to print. Generate the final note first.');
                return;
            }

            const printWindow = window.open('', '', 'height=800,width=800');
            printWindow.document.write('<html><head><title>Clinical Note</title>');
            printWindow.document.write('<style>body { font-family: "Courier New", monospace; font-size: 12pt; line-height: 1.6; padding: 1in; white-space: pre-wrap; }</style>');
            printWindow.document.write('</head><body>');
            printWindow.document.write(text);
            printWindow.document.write('</body></html>');
            printWindow.document.close();
            printWindow.print();

            console.log('üñ®Ô∏è Print dialog opened');
        }

        /**
         * =====================================================
         * ATTENDING SUMMARY (Ultra Summarizer) - DOAP Framework
         * =====================================================
         */

        /**
         * Generate attending presentation summary using DOAP framework
         * @param {string} clinicalNote - The full clinical note to summarize
         */
        async function generateAttendingSummary(clinicalNote) {
            if (!API_KEY) {
                console.error('‚ùå API key not configured for attending summary');
                return;
            }

            if (!clinicalNote || clinicalNote.trim().length === 0) {
                console.error('‚ùå No clinical note to summarize');
                return;
            }

            // Show immediate visual feedback
            const textarea = document.getElementById('attendingSummaryText');
            const tabButton = document.getElementById('attending-tab-button');

            if (textarea) {
                textarea.value = '‚è≥ Generating DOAP attending summary...\n\nPlease wait while the AI creates your 45-second presentation.';
            }

            // Show tab immediately
            if (tabButton) {
                tabButton.style.display = 'inline-block';
            }

            // Store for regeneration
            lastGeneratedNote = clinicalNote;

            try {
                // DOAP Framework Prompt - V8 ENHANCED with Decision Trees
                const prompt = `You are an expert at creating concise attending presentations for neurosurgical cases. Your task is to create a 45-second presentation summary using the DOAP framework with STRICT data placement rules.

üö´ ABSOLUTE PROHIBITION - NEVER FABRICATE OR ASSUME:
1. **Psychiatric symptoms** - NEVER add: depression, suicidal ideation, anxiety, psychosis unless EXPLICITLY documented in the clinical note
2. **Social history** - NEVER assume: smoking, alcohol, drug use, occupation, living situation unless stated
3. **Family history** - NEVER infer genetic conditions, family medical problems unless documented
4. **Medications** - NEVER add medications not listed in the note (anticoagulants, antidepressants, etc.)
5. **Exam findings** - NEVER fabricate exam elements not performed (mental status, cranial nerves, reflexes)
6. **Lab values** - NEVER assume or approximate labs, imaging results not explicitly provided
7. **Temporal details** - NEVER invent timelines, onset times, duration if not documented

‚úÖ ONLY INCLUDE INFORMATION THAT IS:
- **EXPLICITLY stated** in the clinical note verbatim
- **DIRECTLY measured** and documented (GCS, vitals, exam findings)
- **ACTUALLY mentioned** by patient or clinician
- If information is ABSENT from note ‚Üí OMIT it from DOAP summary entirely

**DOAP FRAMEWORK WITH DECISION TREES:**

**D (Diagnosis Line) - 5 seconds, max 20 words:**
FORMAT: [Age][Sex], [surgical-risk comorbidities], [primary diagnosis + severity + timing]

WHAT GOES IN D:
‚úÖ ALWAYS: Age, sex (e.g., "67M", "45F")
‚úÖ Comorbidities (max 2): ONLY if affects surgical risk
   - INCLUDE: Anticoagulation (warfarin, Plavix, apixaban), coagulopathy, DM, recent MI, liver disease, immunosuppression
   - EXCLUDE: Well-controlled HTN alone, remote surgeries, benign conditions
‚úÖ Primary diagnosis with severity: Include WHO grade, H&H, Fisher scale if available
‚úÖ Timing (if acute): "onset 3h ago", "POD 5", "ruptured today"

EXAMPLES:
‚úÖ 67M, warfarin INR 2.8, ruptured ACoA aneurysm H&H 3, 4h from ictus
‚úÖ 45F, DM2, L frontal GBM WHO IV, symptomatic 2 weeks
‚úÖ 58M, no significant PMHx, C6-7 HNP with myelopathy
‚ùå 67M, HTN, HLD, OSA, prior cholecystectomy, ruptured aneurysm (TOO MUCH)

---
**O (One-Liner) - 10 seconds, max 35 words:**
FORMAT: [Abnormal vitals] | [GCS:E_V_M_ + focal findings] | [Critical labs] | [Imaging: modality + findings + measurements]

WHAT GOES IN O:
‚úÖ Vital signs: ONLY if abnormal (BP >160 or <90, HR >120, O2 <92%)
‚úÖ Neurological exam:
   - MANDATORY: GCS with components (GCS8:E2V2M4 NOT just "GCS 8")
   - MANDATORY: Focal deficits with laterality ("L hemiparesis 2/5" NOT "weak")
   - MANDATORY: Critical signs (pupil changes, meningismus, Cushing's triad)
   - EXCLUDE: Normal findings unless specifically relevant
‚úÖ Labs: ONLY if affects immediate management
   - INCLUDE: INR (if anticoagulated), platelets (if <50K), Na (if <125 or >155)
   - EXCLUDE: Routine labs if normal
‚úÖ Imaging:
   - MANDATORY: Modality (CT, MRI, CTA, angio)
   - MANDATORY: Exact measurements ("7.2mm aneurysm" NOT "small")
   - MANDATORY: Laterality ("L MCA" NOT "MCA")
   - MANDATORY: Complications (mass effect, hydrocephalus, herniation)

EXAMPLES:
‚úÖ BP 190/100 | GCS13:E4V4M6, stiff neck, no focal deficit | INR 2.8‚Üí1.1 post-reversal | CTA: 7mm L MCA aneurysm, Fisher 3 SAH, no hydroceph
‚úÖ GCS8:E2V2M4 intubated, R pupil 6mm fixed, L hemiplegia 0/5 | CT: 4cm R temporal EDH, 8mm midline shift, uncal herniation
‚úÖ GCS15:E4V5M6, L arm weakness 4/5, sensory loss C6 distribution | MRI C-spine: Large C5-6 central HNP, severe canal stenosis, cord abutment
‚ùå Patient lethargic, weak, CT shows bleed (VAGUE - missing GCS components, laterality, measurements)

---
**A (Assessment) - 10 seconds, max 35 words:**
FORMAT: [Severity interpretation] + [Critical factors] + [Surgical candidacy] + [Contraindications status]

WHAT GOES IN A:
‚úÖ Severity interpretation: Translate grades to clinical meaning
   - "Low-grade SAH (H&H 3)", "High-grade lesion (WHO IV GBM)", "Incomplete SCI (ASIA C)"
‚úÖ Critical anatomical/physiological factors:
   - Surgical: "Favorable dome projection", "eloquent cortex", "posterior circulation"
   - Physiological: "Symptomatic ICP", "compressive myelopathy", "acute hydroceph"
   - Timing: "Within decompression window", "missed tPA window"
‚úÖ Surgical candidacy: Explicitly state "Good/High-risk/Non-surgical candidate"
‚úÖ Contraindications: State if present OR say "no contraindications"

EXAMPLES:
‚úÖ Low-grade SAH (H&H 3) but symptomatic from acute hydroceph. Favorable anatomy: anteriorly projecting, accessible via pterional. Good surgical candidate, no medical contraindications
‚úÖ High-grade GBM (WHO IV) in eloquent motor cortex. Young, KPS 90, maximal safe resection possible with awake mapping. Surgical candidate despite location
‚úÖ Severe myelopathy (cord signal change, functional decline). Urgent decompression within window for motor recovery. Good surgical candidate, well-controlled DM
‚ùå Patient needs surgery (VAGUE - no severity, no anatomical assessment, no candidacy statement)

---
**P (Plan) - 20 seconds, max 60 words:**
FORMAT: [Immediate intervention] | [Definitive intervention + approach + timing] | [PRIMARY risk + mitigation] | [SECONDARY risk + mitigation] | [Monitoring]

WHAT GOES IN P:
‚úÖ Immediate intervention (if needed): State intervention + timing
   - "EVD tonight OR1", "Dex 10mg IV now", "Mannitol for ICP"
   - If none needed: Skip to definitive
‚úÖ Definitive intervention:
   - Procedure: "Craniotomy", "ACDF C5-6", "VP shunt", "resection"
   - Approach: "via pterional", "posterior approach", "endoscopic"
   - Timing: "tonight", "tomorrow AM", "this week", "Friday"
‚úÖ Risk stratification (by severity):
   - PRIMARY (highest mortality/morbidity): State risk + mitigation
     - "Rebleed risk 4%/day ‚Üí bedrest, SBP <140, nimodipine 60mg q4h"
   - SECONDARY (if relevant):
     - "Vasospasm (Fisher 3) ‚Üí TCDs daily days 3-14, euvolemia"
   - EXCLUDE: Routine risks unless patient-specific factors
‚úÖ Monitoring:
   - Frequency + parameters + duration
   - "Neuro checks q1h, ICP goal <20, √ó 7 days"

EXAMPLES:
‚úÖ EVD tonight OR1 for ICP control. Clip tomorrow AM via R pterional. PRIMARY RISK: Rebleed (4%/day) ‚Üí bedrest, SBP <140, nimodipine 60mg q4h √ó 21d. SECONDARY RISK: Vasospasm (Fisher 3) ‚Üí TCDs daily days 3-14, euvolemia. Neuro checks q1h, ICP goal <20
‚úÖ ACDF C5-6 Friday. PRIMARY RISK: Cord injury from manipulation ‚Üí SSEP monitoring intraop. SECONDARY RISK: C5 palsy (10% incidence) ‚Üí counsel patient. Post-op hard collar √ó 6wks, repeat MRI 6mo
‚úÖ Craniotomy for GBM resection this week. PRIMARY RISK: Motor deficit (eloquent area) ‚Üí awake craniotomy with mapping. Plan: Maximal safe resection, frozen section, dex taper. Neuro checks q4h post-op
‚ùå Will do surgery and monitor (VAGUE - no timing, no risks, no mitigation)

---
**CRITICAL SAFETY RULES (NEVER VIOLATE):**
1. ‚ö†Ô∏è GCS components MANDATORY: "GCS8:E2V2M4" NOT "GCS 8"
2. ‚ö†Ô∏è Laterality MANDATORY: "L MCA" NOT "MCA", "R hemiparesis" NOT "hemiparesis"
3. ‚ö†Ô∏è Exact measurements: "6.8mm" NOT "7mm", "4.2cm" NOT "large"
4. ‚ö†Ô∏è Timing must be specific: "3h from onset" NOT "recent", "POD 5" NOT "post-op"
5. ‚ö†Ô∏è If data missing: State "exam not documented" NOT fabricate
6. ‚ö†Ô∏è Anticoag in D: "+warfarin INR 2.8", "+Plavix+aspirin"
7. ‚ö†Ô∏è Exam trends if known: "GCS 15‚Üí12 over 2h", "pupil L 3mm‚Üí6mm"
8. ‚ö†Ô∏è Word limits STRICT: D‚â§20, O‚â§35, A‚â§35, P‚â§60, TOTAL 120-150 words

---
**PRE-GENERATION CHECKLIST - Verify before generating:**
‚ñ° Can I state GCS with E/V/M components? (If not, state "GCS not documented")
‚ñ° Are there focal findings? Did I include laterality? (L/R specification)
‚ñ° Do I have exact measurements? (sizes, dimensions - not "small/large")
‚ñ° What is the PRIMARY risk? What is the specific mitigation?
‚ñ° Is timing explicit? (hours/days for acute, POD# for post-op)
‚ñ° Any anticoagulation? (must be in D section)

---
**Clinical Note to Summarize:**
${clinicalNote}

---
Generate the DOAP summary now following ALL decision trees and safety rules:`;

                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.3,  // Factual but concise
                                maxOutputTokens: 4096  // Doubled to handle thinking tokens + actual output
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå API Response NOT OK:', response.status, errorText.substring(0, 500));
                    throw new Error(`API Error ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                console.log('üìä Full API Response:', JSON.stringify(data, null, 2));

                // Check for safety blocking
                if (data.promptFeedback?.blockReason) {
                    const blockReason = data.promptFeedback.blockReason;
                    console.error('‚ùå Content blocked by API:', blockReason);
                    throw new Error(`API blocked content: ${blockReason}`);
                }

                // Check if candidates exist
                if (!data.candidates || data.candidates.length === 0) {
                    console.error('‚ùå No candidates in response');
                    console.error('Response structure:', JSON.stringify(data, null, 2));
                    throw new Error('API returned no candidates. Check console for details.');
                }

                // Check finish reason
                const finishReason = data.candidates[0]?.finishReason;
                if (finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during compression generation');
                    console.error('Note may be too long. Candidate structure:', JSON.stringify(data.candidates[0], null, 2));
                    throw new Error('Token limit exceeded. Try with a shorter clinical note or increase maxOutputTokens.');
                } else if (finishReason && finishReason !== 'STOP') {
                    console.warn('‚ö†Ô∏è Unusual finish reason:', finishReason);
                }

                const summary = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No summary generated';

                if (summary === 'No summary generated') {
                    console.error('‚ùå Failed to extract text from response');
                    console.error('Candidate structure:', JSON.stringify(data.candidates[0], null, 2));
                    throw new Error(`Generation failed with finish reason: ${finishReason || 'UNKNOWN'}`);
                }

                console.log('‚úÖ Attending summary generated successfully');
                console.log('Summary length:', summary.length, 'characters');
                return summary;

            } catch (error) {
                console.error('‚ùå Error generating attending summary:', error);

                // Show error in textarea
                if (textarea) {
                    textarea.value = `‚ùå Error generating attending summary:\n\n${error.message}\n\nPlease check:\n1. API key is configured\n2. Internet connection is active\n3. Gemini API quota is available\n\nTry the Regenerate button or generate a new note.`;
                }

                throw error;
            }
        }

        /**
         * Display attending summary in the UI
         * @param {string} summary - The DOAP summary text
         */
        function displayAttendingSummary(summary, mode = null) {
            const textarea = document.getElementById('attendingSummaryText');
            const tabButton = document.getElementById('attending-tab-button');

            if (!textarea) {
                console.error('‚ùå Attending summary textarea not found');
                return;
            }

            // Display the summary
            textarea.value = summary;

            // V8 PHASE 4: DOAP Compliance Validation
            if (mode === 'standard' || !mode) {  // Only validate standard DOAP mode
                if (!summary.includes('failed') && !summary.includes('‚è≥')) {
                    console.log('üîç Running DOAP compliance validation...');
                    const compliance = validateDOAPCompliance(summary);
                    console.log(`üìä DOAP Compliance: ${compliance.score}/100 (${compliance.criticalCount} critical, ${compliance.majorCount} major, ${compliance.minorCount} minor)`);

                    // Append compliance report to textarea
                    textarea.value += `\n\n${'='.repeat(60)}\n`;
                    textarea.value += `üìä DOAP COMPLIANCE SCORE: ${compliance.score}/100\n`;
                    textarea.value += `${compliance.isCompliant ? '‚úÖ' : '‚ö†Ô∏è'} ${compliance.isCompliant ? 'COMPLIANT' : 'NON-COMPLIANT'}\n`;
                    textarea.value += `${'='.repeat(60)}\n`;
                    textarea.value += `Critical: ${compliance.criticalCount} | Major: ${compliance.majorCount} | Minor: ${compliance.minorCount}\n`;
                    textarea.value += `Word Count: D(${compliance.wordCounts.D}/20) O(${compliance.wordCounts.O}/35) A(${compliance.wordCounts.A}/35) P(${compliance.wordCounts.P}/60) | Total: ${compliance.totalWords}\n`;

                    if (compliance.violations.length > 0) {
                        textarea.value += `\nüìã VIOLATIONS:\n`;
                        compliance.violations.forEach((v, idx) => {
                            textarea.value += `\n${idx + 1}. [${v.severity}] ${v.rule}\n`;
                            textarea.value += `   ${v.message}\n`;
                            textarea.value += `   üí° Fix: ${v.fix}\n`;
                        });
                    } else {
                        textarea.value += `\n‚úÖ Perfect! No violations detected.\n`;
                    }

                    // Store compliance for potential regeneration
                    window.lastDOAPCompliance = compliance;
                }
            }

            // Show the attending summary tab button
            if (tabButton) {
                tabButton.style.display = 'inline-block';
            }

            // Automatically switch to the attending summary tab
            switchTab('attending');

            // Log which compression level is being displayed
            const displayMode = mode || document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
            const modeLabels = {
                'standard': 'Compressed (Standard DOAP)',
                'ultra': 'Ultracompressed (ULTRATHINK)',
                'telegram': 'Super-compressed (Telegram)'
            };
            console.log(`‚úÖ ${modeLabels[displayMode]} summary displayed and tab switched`);

            // Update stats after displaying
            updateSummaryStats(summary);
        }

        /**
         * Update status badges for compression modes
         */
        function updateCompressionStatusBadges() {
            const statusMap = {
                'pending': { emoji: '‚è≥', text: 'Pending', bg: '#e0e0e0', color: '#666' },
                'generating': { emoji: '‚åõ', text: 'Generating...', bg: '#FFF9C4', color: '#F57F17' },
                'ready': { emoji: '‚úÖ', text: 'Ready', bg: '#C8E6C9', color: '#2E7D32' },
                'failed': { emoji: '‚ùå', text: 'Failed', bg: '#FFCDD2', color: '#C62828' }
            };

            ['standard', 'ultra', 'telegram'].forEach(mode => {
                const badge = document.getElementById(`status-${mode}`);
                if (badge) {
                    const status = currentNoteVersions.status[mode] || 'pending';
                    const statusInfo = statusMap[status];
                    badge.textContent = `${statusInfo.emoji} ${statusInfo.text}`;
                    badge.style.background = statusInfo.bg;
                    badge.style.color = statusInfo.color;
                }
            });
        }

        /**
         * Update compression info box based on selected mode
         */
        function updateCompressionInfo() {
            const mode = document.querySelector('input[name="compressionMode"]:checked').value;
            const infoBox = document.getElementById('compressionInfoBox');

            if (!infoBox) return;

            if (mode === 'standard') {
                infoBox.innerHTML = `
                    <strong>üìä DOAP Framework for Attending Presentation:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>D</strong> - Diagnosis (5 sec): Age, Sex, PMHx, Primary diagnosis</li>
                        <li><strong>O</strong> - One-liner (10 sec): Exam findings + Imaging results</li>
                        <li><strong>A</strong> - Assessment (10 sec): Severity + Candidacy</li>
                        <li><strong>P</strong> - Plan (20 sec): Intervention + Timing + Main concern</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 45-second presentation to impress attending staff</p>
                `;
                infoBox.style.background = '#e3f2fd';
                infoBox.style.borderLeft = '4px solid #2196F3';
            } else if (mode === 'ultra') {
                infoBox.innerHTML = `
                    <strong>‚ö° ULTRATHINK Compression Mode:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>Ultra-Brief Format:</strong> Merge D+O into one line, strip all non-essential words</li>
                        <li><strong>Aggressive Abbreviations:</strong> sz (seizure), fx (fracture), EDH (epidural hematoma)</li>
                        <li><strong>Numbers Only:</strong> GCS scores, vital signs, timeframes</li>
                        <li><strong>Key Actions:</strong> Only critical interventions and monitoring</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 15-second rapid-fire summary (~35-50 words)</p>
                `;
                infoBox.style.background = '#FFE5E0';
                infoBox.style.borderLeft = '4px solid #FF5722';
            } else if (mode === 'telegram') {
                infoBox.innerHTML = `
                    <strong>üì± Telegram Style - Extreme Compression:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>One Sentence Only:</strong> Age+Dx+Key finding+Action</li>
                        <li><strong>Maximum Abbreviations:</strong> Every word counts</li>
                        <li><strong>No Elaboration:</strong> Core facts only</li>
                    </ul>
                    <p style="margin: 10px 0 0 0; font-style: italic; color: #666;">Target: 5-second elevator pitch (~15-25 words max)</p>
                `;
                infoBox.style.background = '#F3E5F5';
                infoBox.style.borderLeft = '4px solid #9C27B0';
            }

            console.log('üîÑ Compression mode changed to:', mode);

            // Auto-switch to display the already-generated version if it exists
            const textarea = document.getElementById('attendingSummaryText');
            if (!textarea) return;

            let summaryToDisplay = '';
            const modeLabels = {
                'standard': 'Compressed (Standard DOAP)',
                'ultra': 'Ultracompressed (ULTRATHINK)',
                'telegram': 'Telegram Style'
            };

            if (mode === 'ultra' && currentNoteVersions.ultra) {
                summaryToDisplay = currentNoteVersions.ultra;
                console.log('‚úÖ Switched to ultracompressed version');
            } else if (mode === 'standard' && currentNoteVersions.standard) {
                summaryToDisplay = currentNoteVersions.standard;
                console.log('‚úÖ Switched to compressed version');
            } else if (mode === 'telegram' && currentNoteVersions.telegram) {
                summaryToDisplay = currentNoteVersions.telegram;
                console.log('‚úÖ Switched to telegram version');
            }

            // Display the summary (including error messages)
            if (summaryToDisplay) {
                textarea.value = summaryToDisplay;
                // Only update stats if not an error message
                if (!summaryToDisplay.includes('failed')) {
                    updateSummaryStats(summaryToDisplay);
                }
            } else {
                // Show helpful message if mode not yet generated
                const status = currentNoteVersions.status[mode];
                if (status === 'pending') {
                    textarea.value = `‚ÑπÔ∏è ${modeLabels[mode]} will be generated automatically after you create a clinical note.\n\nGenerate a note using transcript or SOAP entry to see ${modeLabels[mode]} here.`;
                } else if (status === 'generating') {
                    textarea.value = `‚åõ Generating ${modeLabels[mode]}...\n\nPlease wait a moment.`;
                }
            }
        }

        /**
         * Generate ULTRA-compressed attending summary (15 seconds, ~35-50 words)
         */
        async function generateUltraAttendingSummary(clinicalNote) {
            if (!API_KEY) {
                console.error('‚ùå API key not configured');
                return;
            }

            if (!clinicalNote || clinicalNote.trim().length === 0) {
                console.error('‚ùå No clinical note to summarize');
                return;
            }

            const prompt = `You are an expert neurosurgeon creating ULTRA-COMPRESSED handoff presentations. Create a 15-second ULTRATHINK summary for safe neurosurgical handoff.

üö´ ABSOLUTE PROHIBITION - NEVER FABRICATE OR ASSUME:
1. **Psychiatric symptoms** - NEVER add: depression, suicidal ideation, anxiety, psychosis unless EXPLICITLY documented
2. **Social history** - NEVER assume: smoking, alcohol, drug use, occupation, living situation unless stated
3. **Family history** - NEVER infer genetic conditions, family medical problems unless documented
4. **Medications** - NEVER add medications not listed in the note (anticoagulants, antidepressants, etc.)
5. **Exam findings** - NEVER fabricate exam elements not performed (mental status, cranial nerves, reflexes)
6. **Lab values** - NEVER assume or approximate labs, imaging results not explicitly provided
7. **Temporal details** - NEVER invent timelines, onset times, duration if not documented

‚úÖ ONLY INCLUDE INFORMATION THAT IS:
- **EXPLICITLY stated** in the clinical note verbatim
- **DIRECTLY measured** and documented (GCS, vitals, exam findings)
- **ACTUALLY mentioned** by patient or clinician
- If information is ABSENT from note ‚Üí OMIT it from summary entirely

‚ö†Ô∏è CRITICAL SAFETY - NEVER COMPRESS THESE:
1. **GCS components** - ALWAYS include E_V_M_ breakdown (e.g., GCS8:E2V2M4) NOT just total
2. **Laterality** - ALWAYS specify L/R: "L hemiparesis", "R pupil dilated 6mm"
3. **Exact measurements** - NEVER round: "7mm aneurysm" NOT "small aneurysm"
4. **Time-critical windows** - Include exact times: "onset 2h ago", "last normal 14:30"
5. **Anticoagulation** - If on anticoag: "+warfarin INR2.8", "+Plavix"
6. **Neuro exam changes** - Always include direction: "pupil L3‚Üí6mm", "weakness improving 2/5‚Üí4/5"
7. **Critical actions** - Never abbreviate urgent interventions: "Stat craniotomy" not "crani"

**COMPRESSION RULES:**
1. Target 35-50 words total (strict limit)
2. Merge diagnosis + exam into continuous flow
3. Use neurosurgical abbreviations ONLY
4. Strip non-essential words BUT maintain clarity
5. Numbers and critical timeframes mandatory
6. Action items in shortest form that remains unambiguous

‚õî PROHIBITED ABBREVIATIONS (Joint Commission):
- U (units) ‚Üí spell "units"
- Q.D./Q.O.D. ‚Üí "daily"/"every other day"
- Trailing zeros (1.0mg) ‚Üí "1mg"
- MS/MSO4 ‚Üí spell out medication

**NEUROSURGICAL APPROVED ABBREVIATIONS:**
TBI, SAH, EDH, SDH, IPH, ICH, IVH, AVM, GBM, mets, HCP, sz, fx, SCI, ACDF, lami, EVD, ICP, crani, VP shunt, C/T/L/S levels, H&H, Fisher, mRS

**NEUROSURGERY HANDOFF EXAMPLES:**

**TRAUMA (Emergent Surgical):**
29M polytrauma: TBI+3cm R temporal EDH (GCS8:E2V2M4 intubated, L hemiplegia 0/5, R pupil 5mm). 5mm midline shift. EMERGENT craniotomy OR2 in 30min. WATCH: L pupil pre-op, ICP>25.

**VASCULAR (Urgent Observation):**
67F ruptured ACoA: 7mm aneurysm H&H3 Fisher3 (GCS13:E4V4M6 stiff neck). Acute hydroceph, dilated ventricles. EVD tonight, clip AM. WATCH: Vasospasm day 3-14, rebleed, TCDs q12h.

**DEGENERATIVE (Elective - Cauda Equina):**
58M L4-5 massive disc: cauda equina 12h (saddle anesthesia, retention, foot drop L2/5 R3/5). MRI confirms compression. SURGERY <6h from onset‚Äîfunction salvage. WATCH: Return bladder/motor post-op.

**TUMOR (Urgent Resection):**
45F L frontal GBM: 4cm enhancing mass (headache+sz 2wks, now hemiparesis R4/5 declining). 10mm shift+edema. Resection this week, dex 4mg q6h. WATCH: Neuro decline‚Äîexpedite if worsens.

**SPINE TRAUMA (Unstable):**
35M C5-6 fx-dislocation: fall 6m (incomplete SCI, hands weak 3/5, legs 4/5, sensory C6). CT unstable fx, MRI cord contusion. SURGERY 24h‚ÄîACDF+fusion. Halo until OR. WATCH: Neuro decline, resp failure.

---
**Clinical Note to Compress:**
${clinicalNote}

---
Generate ULTRATHINK neurosurgical handoff (35-50 words, preserve ALL safety-critical details):`;

            try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.1,  // Maximum factual accuracy for critical neurosurgical handoffs
                                maxOutputTokens: 4096  // Quadrupled - handles complex notes with long prompts
                            }
                        })
                    }
                );

                if (!response.ok) {
                    throw new Error(`API Error ${response.status}`);
                }

                const data = await response.json();

                // Check for MAX_TOKENS finish reason
                const finishReason = data.candidates?.[0]?.finishReason;
                if (finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during ULTRA compression');
                    throw new Error('Token limit exceeded for ULTRA compression. Note may be too complex.');
                }

                const summary = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No summary generated';

                if (summary === 'No summary generated') {
                    console.error('‚ùå Failed to generate ULTRA summary. Finish reason:', finishReason);
                    throw new Error(`ULTRA generation failed: ${finishReason || 'UNKNOWN'}`);
                }

                console.log('‚úÖ ULTRA summary generated');
                return summary;

            } catch (error) {
                console.error('‚ùå Error generating ULTRA summary:', error);
                throw error;
            }
        }

        /**
         * Generate Telegram-style summary (5 seconds, ~15-25 words)
         */
        async function generateTelegramSummary(clinicalNote) {
            if (!API_KEY) {
                console.error('‚ùå API key not configured');
                return;
            }

            if (!clinicalNote || clinicalNote.trim().length === 0) {
                console.error('‚ùå No clinical note to summarize');
                return;
            }

            const prompt = `You are an expert at creating TELEGRAM-STYLE neurosurgical summaries. Create a 5-second extreme compression.

**Telegram Rules:**
1. Maximum 15-25 words (ABSOLUTE LIMIT)
2. ONE sentence only
3. Format: [Age][Sex] [Dx]+[complication]: [key finding]. [GCS]. [Action]
4. Maximum abbreviations everywhere
5. No elaboration whatsoever

**Example:**
29M TBI+sz: bifrontal contusions, EDH mass effect. GCS8. Observe, CT q8h

---
**Clinical Note:**
${clinicalNote}

---
Generate Telegram summary (15-25 words ONLY):`;

            try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.1,  // Extremely factual
                                maxOutputTokens: 2048  // Adequate buffer for thinking + input + output
                            }
                        })
                    }
                );

                if (!response.ok) {
                    throw new Error(`API Error ${response.status}`);
                }

                const data = await response.json();

                // Check for MAX_TOKENS finish reason
                const finishReason = data.candidates?.[0]?.finishReason;
                if (finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during Telegram compression');
                    throw new Error('Token limit exceeded for Telegram compression.');
                }

                const summary = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No summary generated';

                if (summary === 'No summary generated') {
                    console.error('‚ùå Failed to generate Telegram summary. Finish reason:', finishReason);
                    throw new Error(`Telegram generation failed: ${finishReason || 'UNKNOWN'}`);
                }

                console.log('‚úÖ Telegram summary generated');
                return summary;

            } catch (error) {
                console.error('‚ùå Error generating Telegram summary:', error);
                throw error;
            }
        }

        /**
         * Update summary statistics display
         */
        function updateSummaryStats(summaryText) {
            if (!summaryText || summaryText.trim().length === 0) {
                document.getElementById('summaryWordCount').textContent = '0';
                document.getElementById('summarySeconds').textContent = '0';
                document.getElementById('compressionRatio').textContent = '0%';
                return;
            }

            // Calculate word count
            const words = summaryText.trim().split(/\s+/).length;

            // Calculate speaking time (150 words per minute = 2.5 words per second)
            const seconds = Math.ceil(words / 2.5);

            // Calculate compression ratio if original note exists
            let compressionRatio = 0;
            if (lastGeneratedNote && lastGeneratedNote.trim().length > 0) {
                const originalWords = lastGeneratedNote.trim().split(/\s+/).length;
                compressionRatio = Math.round((1 - words / originalWords) * 100);
            }

            // Update display
            document.getElementById('summaryWordCount').textContent = words;
            document.getElementById('summarySeconds').textContent = seconds;
            document.getElementById('compressionRatio').textContent = compressionRatio + '%';

            console.log(`üìä Stats: ${words} words, ${seconds}s, ${compressionRatio}% compression`);
        }

        /**
         * Copy attending summary to clipboard
         */
        function copyAttendingSummary() {
            const textarea = document.getElementById('attendingSummaryText');
            if (!textarea || !textarea.value) {
                alert('‚ùå No attending summary to copy. Generate a note first.');
                return;
            }

            textarea.select();
            textarea.setSelectionRange(0, 99999);

            try {
                document.execCommand('copy');
                alert('‚úÖ Attending summary copied to clipboard!');
                console.log('üìã Attending summary copied');
            } catch (err) {
                alert('‚ùå Failed to copy. Please select and copy manually.');
                console.error('Copy failed:', err);
            }
        }

        /**
         * Regenerate attending summary from last note
         */
        async function regenerateAttendingSummary() {
            if (!lastGeneratedNote || lastGeneratedNote.trim().length === 0) {
                alert('‚ùå No note available to regenerate summary. Generate a clinical note first.');
                return;
            }

            // Get selected compression mode
            const mode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';

            const textarea = document.getElementById('attendingSummaryText');
            if (textarea) {
                const modeLabel = mode === 'ultra' ? 'ULTRATHINK' : mode === 'telegram' ? 'Telegram' : 'Standard DOAP';
                textarea.value = `‚è≥ Regenerating ${modeLabel} summary...`;
            }

            try {
                let summary;
                if (mode === 'ultra') {
                    console.log('‚ö° Generating ULTRATHINK summary...');
                    summary = await generateUltraAttendingSummary(lastGeneratedNote);
                } else if (mode === 'telegram') {
                    console.log('üì± Generating Telegram summary...');
                    summary = await generateTelegramSummary(lastGeneratedNote);
                } else {
                    console.log('üìä Generating Standard DOAP summary...');
                    summary = await generateAttendingSummary(lastGeneratedNote);
                }

                displayAttendingSummary(summary);
                switchTab('attending');
            } catch (error) {
                if (textarea) {
                    textarea.value = `‚ùå Error: ${error.message}`;
                }
                alert(`Failed to regenerate attending summary: ${error.message}`);
            }
        }

        /**
         * Test attending summary generation with current note
         */
        async function testAttendingSummary() {
            console.log('üß™ TEST: Manual attending summary test triggered');

            // Get current note from output textarea
            const output = document.getElementById('output');
            if (!output || !output.value || output.value.trim().length === 0) {
                alert('‚ùå No clinical note found. Please generate a note first (Transcript, SOAP, or V6 Final Note).');
                return;
            }

            const currentNote = output.value;
            console.log('üß™ TEST: Found note with length:', currentNote.length);

            // Get selected compression mode
            const mode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
            const modeLabel = mode === 'ultra' ? 'ULTRATHINK' : mode === 'telegram' ? 'Telegram' : 'Standard DOAP';
            console.log(`üß™ TEST: Selected mode: ${modeLabel}`);

            // Show the attending tab immediately
            const tabButton = document.getElementById('attending-tab-button');
            if (tabButton) {
                tabButton.style.display = 'inline-block';
                switchTab('attending');
            }

            // Show loading message in textarea
            const textarea = document.getElementById('attendingSummaryText');
            if (textarea) {
                textarea.value = `‚è≥ Generating ${modeLabel} summary...\n\nPlease wait...`;
            }

            try {
                let summary;
                if (mode === 'ultra') {
                    console.log('üß™ TEST: Calling generateUltraAttendingSummary...');
                    summary = await generateUltraAttendingSummary(currentNote);
                } else if (mode === 'telegram') {
                    console.log('üß™ TEST: Calling generateTelegramSummary...');
                    summary = await generateTelegramSummary(currentNote);
                } else {
                    console.log('üß™ TEST: Calling generateAttendingSummary...');
                    summary = await generateAttendingSummary(currentNote);
                }

                if (summary) {
                    console.log('üß™ TEST: Summary received, length:', summary.length);
                    displayAttendingSummary(summary);
                    alert(`‚úÖ Test successful! ${modeLabel} summary generated.`);
                } else {
                    console.error('üß™ TEST: No summary returned');
                    alert('‚ùå Test failed: No summary returned from API');
                }
            } catch (error) {
                console.error('üß™ TEST: Error:', error);
                if (textarea) {
                    textarea.value = `‚ùå Error: ${error.message}`;
                }
                alert(`‚ùå Test failed: ${error.message}`);
            }
        }

        /**
         * Update SOAP statistics in real-time
         */
        function updateSOAPStats() {
            const subjective = document.getElementById('soapSubjective').value.trim();
            const objective = document.getElementById('soapObjective').value.trim();
            const assessment = document.getElementById('soapAssessment').value.trim();
            const plan = document.getElementById('soapPlan').value.trim();

            // Count total words
            const allText = `${subjective} ${objective} ${assessment} ${plan}`;
            const wordCount = allText.trim() ? allText.trim().split(/\s+/).length : 0;
            document.getElementById('soapTotalWords').textContent = wordCount;

            // Count completed sections
            let sectionCount = 0;
            if (subjective) sectionCount++;
            if (objective) sectionCount++;
            if (assessment) sectionCount++;
            if (plan) sectionCount++;
            document.getElementById('soapSectionCount').textContent = `${sectionCount}/4`;
        }

        /**
         * SOAP UNIFIED INPUT PARSERS
         * Three-tier parsing strategy for single-textbox SOAP input
         */

        /**
         * Tier 1: Regex-based SOAP section detector (Fast path - handles 70-80% of cases)
         * Detects labeled sections: "S:", "Subjective:", etc.
         * Returns: { success: boolean, data: {S, O, A, P}, confidence: number }
         */
        function detectSOAPSections(text) {
            if (!text || !text.trim()) {
                return { success: false, data: null, confidence: 0 };
            }

            // Common SOAP section markers (case-insensitive)
            const patterns = {
                subjective: /(?:^|\n)\s*(?:S(?:ubjective)?|SUBJECTIVE|Chief Complaint)\s*[:Ôºö]\s*([^\n]*(?:\n(?!(?:O(?:bjective)?|A(?:ssessment)?|P(?:lan)?)\s*[:Ôºö])[^\n]*)*)/i,
                objective: /(?:^|\n)\s*(?:O(?:bjective)?|OBJECTIVE|Exam(?:ination)?)\s*[:Ôºö]\s*([^\n]*(?:\n(?!(?:A(?:ssessment)?|P(?:lan)?)\s*[:Ôºö])[^\n]*)*)/i,
                assessment: /(?:^|\n)\s*(?:A(?:ssessment)?|ASSESSMENT|Diagnosis|Impression)\s*[:Ôºö]\s*([^\n]*(?:\n(?!(?:P(?:lan)?)\s*[:Ôºö])[^\n]*)*)/i,
                plan: /(?:^|\n)\s*(?:P(?:lan)?|PLAN|Treatment|Recommendations?)\s*[:Ôºö]\s*([\s\S]*)/i
            };

            const result = {
                subjective: '',
                objective: '',
                assessment: '',
                plan: ''
            };

            let sectionsFound = 0;

            // Try to match each section
            for (const [key, pattern] of Object.entries(patterns)) {
                const match = text.match(pattern);
                if (match && match[1]) {
                    result[key] = match[1].trim();
                    if (result[key].length > 0) sectionsFound++;
                }
            }

            // Calculate confidence based on sections found and formatting
            let confidence = 0;
            if (sectionsFound >= 2) {
                confidence = Math.min(95, sectionsFound * 25); // 2 sections = 50%, 3 = 75%, 4 = 100%

                // Bonus for proper formatting (labels present)
                const hasLabels = /(?:S(?:ubjective)?|O(?:bjective)?|A(?:ssessment)?|P(?:lan)?)\s*[:Ôºö]/i.test(text);
                if (hasLabels) confidence = Math.min(95, confidence + 10);
            }

            return {
                success: sectionsFound >= 2, // At least 2 sections needed for regex success
                data: result,
                confidence: confidence,
                sectionsFound: sectionsFound
            };
        }

        /**
         * Tier 2: AI-powered SOAP parser (Accurate path - handles ambiguous/unlabeled cases)
         * Uses Gemini to intelligently parse unstructured clinical text into SOAP format
         */
        async function aiParseSOAP(text) {
            if (!API_KEY) {
                throw new Error('API key not configured');
            }

            const prompt = `You are a clinical documentation expert. Parse the following clinical text into SOAP format.

CRITICAL INSTRUCTIONS:
1. Extract information into 4 categories: Subjective, Objective, Assessment, Plan
2. DO NOT add information not present in the original text
3. DO NOT infer or make assumptions
4. Preserve exact medical terminology and measurements
5. If a section is empty, return empty string
6. Output ONLY valid JSON in this exact format:

{
  "subjective": "patient's symptoms and history",
  "objective": "physical exam findings, vital signs, labs",
  "assessment": "diagnosis, clinical impression",
  "plan": "treatment recommendations, follow-up"
}

CLINICAL TEXT TO PARSE:
${text}

OUTPUT (JSON only, no markdown, no explanation):`;

            try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                role: 'user',
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                temperature: 0.1, // Maximum accuracy for parsing
                                maxOutputTokens: 8192 // Increased to handle thinking tokens + JSON output
                            }
                        })
                    }
                );

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();

                // Check for MAX_TOKENS finish reason
                if (data.candidates?.[0]?.finishReason === 'MAX_TOKENS') {
                    console.error('‚ùå Hit token limit during SOAP parsing');
                    throw new Error('Response too long. Try shortening the input note.');
                }

                // Extract response text
                const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!responseText) {
                    const finishReason = data.candidates?.[0]?.finishReason || 'UNKNOWN';
                    console.error('‚ùå No response text generated. Finish reason:', finishReason);
                    console.error('Response data:', JSON.stringify(data, null, 2));
                    throw new Error(`AI generation failed: ${finishReason}`);
                }

                // Clean up response (remove markdown code blocks if present)
                const cleanedText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                // Parse JSON response
                const parsed = JSON.parse(cleanedText);

                // Validate structure
                if (typeof parsed === 'object' &&
                    'subjective' in parsed &&
                    'objective' in parsed &&
                    'assessment' in parsed &&
                    'plan' in parsed) {
                    return {
                        success: true,
                        data: {
                            subjective: parsed.subjective || '',
                            objective: parsed.objective || '',
                            assessment: parsed.assessment || '',
                            plan: parsed.plan || ''
                        },
                        confidence: 85 // AI parsing gets 85% confidence
                    };
                } else {
                    throw new Error('Invalid JSON structure from AI');
                }
            } catch (error) {
                console.error('‚ùå AI parsing failed:', error);
                return {
                    success: false,
                    data: null,
                    confidence: 0,
                    error: error.message
                };
            }
        }

        /**
         * Tier 3: Orchestrator function - Coordinates regex and AI parsing
         * Strategy: Try regex first (fast), fall back to AI if needed (accurate)
         */
        async function parseSOAPInput(text, forceAI = false) {
            console.log('üîç Parsing SOAP input...', { length: text.length, forceAI });

            // Step 1: Try regex parsing first (unless forced to use AI)
            if (!forceAI) {
                const regexResult = detectSOAPSections(text);
                console.log('üìä Regex parsing result:', regexResult);

                // If regex parsing successful with high confidence, use it
                if (regexResult.success && regexResult.confidence >= 70) {
                    console.log('‚úÖ Using regex parsing (fast path)');
                    return {
                        ...regexResult,
                        method: 'regex'
                    };
                }

                // If regex found some sections but low confidence, show preview and ask
                if (regexResult.sectionsFound >= 1 && regexResult.confidence < 70) {
                    console.log('‚ö†Ô∏è Regex found sections but low confidence, falling back to AI');
                }
            }

            // Step 2: Fall back to AI parsing
            console.log('ü§ñ Using AI parsing (accurate path)');
            const aiResult = await aiParseSOAP(text);

            if (aiResult.success) {
                return {
                    ...aiResult,
                    method: 'ai'
                };
            }

            // Step 3: Both failed - return error
            return {
                success: false,
                data: null,
                confidence: 0,
                method: 'none',
                error: 'Both regex and AI parsing failed'
            };
        }

        /**
         * SOAP MODE TOGGLE & UI FUNCTIONS
         */

        // Current SOAP input mode ('simple' or 'advanced')
        let currentSOAPMode = 'simple';

        /**
         * Switch between Simple (unified) and Advanced (4-box) SOAP input modes
         */
        function switchSOAPMode(mode) {
            currentSOAPMode = mode;

            const unifiedContainer = document.getElementById('soapUnifiedContainer');
            const separateContainer = document.getElementById('soapSeparateContainer');
            const simpleModeBtn = document.getElementById('simpleModeBtn');
            const advancedModeBtn = document.getElementById('advancedModeBtn');
            const modeDescription = document.getElementById('modeDescription');

            if (mode === 'simple') {
                // Show unified textarea, hide 4 boxes
                unifiedContainer.style.display = 'block';
                separateContainer.style.display = 'none';

                // Update button styles
                simpleModeBtn.style.background = '#2196F3';
                simpleModeBtn.style.color = 'white';
                advancedModeBtn.style.background = '#E0E0E0';
                advancedModeBtn.style.color = '#666';

                // Update description
                modeDescription.innerHTML = '<strong>Simple:</strong> Enter all SOAP sections in one textbox (AI will intelligently parse sections)';

                console.log('‚úÖ Switched to Simple mode (unified input)');
            } else {
                // Show 4 boxes, hide unified textarea
                unifiedContainer.style.display = 'none';
                separateContainer.style.display = 'block';

                // Update button styles
                simpleModeBtn.style.background = '#E0E0E0';
                simpleModeBtn.style.color = '#666';
                advancedModeBtn.style.background = '#2196F3';
                advancedModeBtn.style.color = 'white';

                // Update description
                modeDescription.innerHTML = '<strong>Advanced:</strong> Enter each SOAP section separately in dedicated textboxes';

                console.log('‚úÖ Switched to Advanced mode (4-box input)');
            }

            // Update stats for current mode
            if (mode === 'simple') {
                updateUnifiedStats();
            } else {
                updateSOAPStats();
            }
        }

        /**
         * Update statistics for unified SOAP textarea
         */
        function updateUnifiedStats() {
            const unifiedText = document.getElementById('soapUnifiedInput').value.trim();
            const wordCount = unifiedText ? unifiedText.split(/\s+/).length : 0;

            document.getElementById('soapTotalWords').textContent = wordCount;

            // For unified mode, section count is shown as "Unified"
            document.getElementById('soapSectionCount').textContent = 'Unified';

            // Reset parse indicators when text changes (user needs to re-parse)
            const parseMethod = document.getElementById('parseMethod');
            const parseConfidence = document.getElementById('parseConfidence');
            if (parseMethod && parseMethod.textContent !== 'Not parsed') {
                parseMethod.textContent = 'Not parsed';
                parseMethod.style.background = '#F5F5F5';
                parseMethod.style.color = '#999';
                parseConfidence.textContent = '';

                // Clear stored parsed data (will trigger fresh parsing on generate)
                if (soapQuickEntry && (soapQuickEntry.subjective || soapQuickEntry.objective ||
                    soapQuickEntry.assessment || soapQuickEntry.plan)) {
                    soapQuickEntry = { subjective: '', objective: '', assessment: '', plan: '' };
                }
            }
        }

        /**
         * Preview how SOAP will be parsed from unified input
         */
        async function previewSOAPParsing() {
            const unifiedText = document.getElementById('soapUnifiedInput').value.trim();

            if (!unifiedText) {
                alert('‚ö†Ô∏è Please enter some clinical notes first.');
                return;
            }

            // Show loading state
            const parseMethod = document.getElementById('parseMethod');
            const parseConfidence = document.getElementById('parseConfidence');
            parseMethod.textContent = 'Parsing...';
            parseMethod.style.background = '#FFF9C4';
            parseConfidence.textContent = '';

            try {
                // Try to parse using orchestrator
                const result = await parseSOAPInput(unifiedText);

                console.log('üìä Parse result:', result);

                if (result.success) {
                    // Update UI indicators
                    parseMethod.textContent = result.method === 'regex' ? '‚ö° Regex' : 'ü§ñ AI';
                    parseMethod.style.background = result.method === 'regex' ? '#C8E6C9' : '#E1F5FE';
                    parseConfidence.textContent = `Confidence: ${result.confidence}%`;

                    // Show preview modal with parsed sections
                    showParsePreviewModal(result.data, result.method, result.confidence);
                } else {
                    parseMethod.textContent = '‚ùå Failed';
                    parseMethod.style.background = '#FFCDD2';
                    parseConfidence.textContent = result.error || 'Unable to parse';
                    alert('‚ùå Unable to parse SOAP sections. Please check your input format.');
                }
            } catch (error) {
                console.error('‚ùå Parsing error:', error);
                parseMethod.textContent = '‚ùå Error';
                parseMethod.style.background = '#FFCDD2';
                parseConfidence.textContent = error.message;
                alert('‚ùå Error parsing SOAP: ' + error.message);
            }
        }

        // Temporary storage for parsed data during modal preview
        let tempParsedData = null;

        /**
         * Show modal with parsed SOAP sections for user confirmation
         */
        function showParsePreviewModal(parsedData, method, confidence) {
            // Store data in temporary variable (safer than inline JSON)
            tempParsedData = parsedData;

            const modal = document.createElement('div');
            modal.id = 'soapPreviewModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            const methodLabel = method === 'regex' ? '‚ö° Fast Regex Parsing' : 'ü§ñ AI Parsing';
            const methodColor = method === 'regex' ? '#4CAF50' : '#2196F3';

            // Escape HTML in parsed data to prevent XSS
            const escapeHtml = (text) => {
                if (!text) return '<i style="color: #999;">Empty</i>';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };

            modal.innerHTML = `
                <div style="background: white; padding: 24px; border-radius: 8px; max-width: 700px; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h3 style="margin: 0; color: #333;">üîç SOAP Parsing Preview</h3>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <span style="font-size: 0.8rem; padding: 4px 10px; background: ${methodColor}; color: white; border-radius: 4px; font-weight: 600;">
                                ${methodLabel}
                            </span>
                            <span style="font-size: 0.8rem; padding: 4px 10px; background: #E0E0E0; border-radius: 4px;">
                                ${confidence}% confidence
                            </span>
                        </div>
                    </div>

                    <div style="background: #F5F5F5; padding: 12px; border-radius: 6px; margin-bottom: 16px; font-size: 0.85rem; color: #666;">
                        ‚ÑπÔ∏è Review the parsed sections below. Click "Use This Parsing" to proceed with generation.
                    </div>

                    <div style="margin-bottom: 12px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">üìù Subjective:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.subjective)}
                        </div>
                    </div>

                    <div style="margin-bottom: 12px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">üî¨ Objective:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.objective)}
                        </div>
                    </div>

                    <div style="margin-bottom: 12px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">ü©∫ Assessment:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.assessment)}
                        </div>
                    </div>

                    <div style="margin-bottom: 16px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 6px;">üíä Plan:</div>
                        <div style="background: #E3F2FD; padding: 10px; border-radius: 4px; font-size: 0.9rem; min-height: 40px; white-space: pre-wrap;">
                            ${escapeHtml(parsedData.plan)}
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeParsePreviewModal()"
                                style="padding: 10px 20px; background: #E0E0E0; color: #666; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                            ‚ùå Cancel
                        </button>
                        <button onclick="acceptParsedSOAPFromModal()"
                                style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                            ‚úÖ Use This Parsing
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        /**
         * Close the SOAP preview modal
         */
        function closeParsePreviewModal() {
            const modal = document.getElementById('soapPreviewModal');
            if (modal) {
                modal.remove();
            }
            tempParsedData = null;
        }

        /**
         * Accept parsed data from modal and close
         */
        function acceptParsedSOAPFromModal() {
            if (tempParsedData) {
                acceptParsedSOAP(tempParsedData);
            }
            closeParsePreviewModal();
        }

        /**
         * Accept parsed SOAP data and populate the 4-box fields (for verification or editing)
         */
        function acceptParsedSOAP(parsedData) {
            // Store in soapQuickEntry for generation
            soapQuickEntry = {
                subjective: parsedData.subjective || '',
                objective: parsedData.objective || '',
                assessment: parsedData.assessment || '',
                plan: parsedData.plan || ''
            };

            console.log('‚úÖ Accepted parsed SOAP data:', soapQuickEntry);

            // Update parse method indicator
            const parseMethod = document.getElementById('parseMethod');
            parseMethod.textContent = '‚úÖ Parsed';
            parseMethod.style.background = '#C8E6C9';
            parseMethod.style.color = '#2E7D32';

            alert('‚úÖ SOAP sections parsed successfully! You can now generate the clinical note.');
        }

        /**
         * Validate SOAP entry before generation (supports both Simple and Advanced modes)
         */
        async function validateSOAPEntry() {
            let subjective, objective, assessment, plan;

            // MODE 1: SIMPLE (Unified Textarea) - Parse the text
            if (currentSOAPMode === 'simple') {
                const unifiedText = document.getElementById('soapUnifiedInput').value.trim();

                if (!unifiedText) {
                    alert('‚ö†Ô∏è Please enter clinical notes before generating.');
                    return false;
                }

                console.log('üîç Simple mode: Parsing unified SOAP input...');

                // Check if already parsed (user clicked "Preview Parsing" and accepted)
                if (soapQuickEntry &&
                    (soapQuickEntry.subjective || soapQuickEntry.objective ||
                     soapQuickEntry.assessment || soapQuickEntry.plan)) {
                    console.log('‚úÖ Using previously parsed SOAP data');
                    subjective = soapQuickEntry.subjective;
                    objective = soapQuickEntry.objective;
                    assessment = soapQuickEntry.assessment;
                    plan = soapQuickEntry.plan;
                } else {
                    // Parse on-the-fly
                    console.log('‚ö° Auto-parsing SOAP input...');
                    try {
                        const parseResult = await parseSOAPInput(unifiedText);

                        if (!parseResult.success) {
                            alert('‚ùå Unable to parse SOAP sections. Please check your input format or use "Preview Parsing" first.');
                            return false;
                        }

                        // Store parsed data
                        soapQuickEntry = {
                            subjective: parseResult.data.subjective || '',
                            objective: parseResult.data.objective || '',
                            assessment: parseResult.data.assessment || '',
                            plan: parseResult.data.plan || ''
                        };

                        subjective = soapQuickEntry.subjective;
                        objective = soapQuickEntry.objective;
                        assessment = soapQuickEntry.assessment;
                        plan = soapQuickEntry.plan;

                        console.log(`‚úÖ Auto-parsed using ${parseResult.method} (${parseResult.confidence}% confidence)`);
                    } catch (error) {
                        console.error('‚ùå Parsing error:', error);
                        alert('‚ùå Error parsing SOAP: ' + error.message);
                        return false;
                    }
                }
            }
            // MODE 2: ADVANCED (4 Separate Textboxes) - Read directly
            else {
                subjective = document.getElementById('soapSubjective').value.trim();
                objective = document.getElementById('soapObjective').value.trim();
                assessment = document.getElementById('soapAssessment').value.trim();
                plan = document.getElementById('soapPlan').value.trim();

                // At least one section must have content
                if (!subjective && !objective && !assessment && !plan) {
                    alert('‚ö†Ô∏è Please enter information in at least one SOAP section before generating.');
                    return false;
                }

                // Store values
                soapQuickEntry = {
                    subjective: subjective,
                    objective: objective,
                    assessment: assessment,
                    plan: plan
                };
            }

            // Common validation for both modes
            // Warning if assessment empty (but allow to proceed)
            if (!assessment && (subjective || objective || plan)) {
                const proceed = confirm('‚ö†Ô∏è Assessment section is empty. Proceed without diagnosis/impression?');
                if (!proceed) return false;
            }

            console.log('‚úÖ SOAP validation passed');
            console.log(`üìä SOAP Entry: S=${subjective.length} O=${objective.length} A=${assessment.length} P=${plan.length} chars`);
            console.log(`Mode: ${currentSOAPMode}`);
            return true;
        }

        /**
         * Determine which input panel is active (transcript or SOAP)
         */
        function detectActiveInputPanel() {
            // Check if SOAP panel has content (both unified and separate modes)
            let soapHasContent = false;

            if (currentSOAPMode === 'simple') {
                soapHasContent = document.getElementById('soapUnifiedInput').value.trim();
            } else {
                soapHasContent =
                    document.getElementById('soapSubjective').value.trim() ||
                    document.getElementById('soapObjective').value.trim() ||
                    document.getElementById('soapAssessment').value.trim() ||
                    document.getElementById('soapPlan').value.trim();
            }

            // Check if transcript has content
            const transcriptHasContent = document.getElementById('transcript').value.trim();

            // If SOAP has content, use SOAP mode
            if (soapHasContent) {
                activeInputPanel = 'soap';
                return 'soap';
            }

            // Otherwise default to transcript mode
            activeInputPanel = 'transcript';
            return 'transcript';
        }

        // ============================================================
        // CONSULTATION TYPE FUNCTIONS
        // ============================================================

        function selectConsultType(type) {
            consultationType = type;

            // Update button styles
            const newBtn = document.getElementById('consultTypeNew');
            const followupBtn = document.getElementById('consultTypeFollowup');
            const descDiv = document.getElementById('consultTypeDescription');

            if (type === 'new') {
                newBtn.style.background = '#4A90E2';
                newBtn.style.color = 'white';
                newBtn.style.borderColor = '#4A90E2';

                followupBtn.style.background = 'white';
                followupBtn.style.color = '#333';
                followupBtn.style.borderColor = '#E1E4E8';

                descDiv.innerHTML = '<strong>New Consultation:</strong> Comprehensive initial assessment with full history, examination, and workup.';
            } else {
                followupBtn.style.background = '#4A90E2';
                followupBtn.style.color = 'white';
                followupBtn.style.borderColor = '#4A90E2';

                newBtn.style.background = 'white';
                newBtn.style.color = '#333';
                newBtn.style.borderColor = '#E1E4E8';

                descDiv.innerHTML = '<strong>Follow-up Visit:</strong> Interval history, treatment response, updated assessment, and plan modifications.';
            }

            console.log(`‚úÖ Consultation type set to: ${type}`);
            resetAutoActivationFlag(); // Allow auto-activation to trigger again for different consultation type
        }

        // ============================================================
        // AUTO DEEP SEARCH EVENT HANDLERS
        // ============================================================

        /**
         * Update reason for consultation field
         * Called when user types in the reason field
         */
        function updateReasonForConsult(value) {
            reasonForConsult = value.trim();
            reasonSource = value.trim().length > 0 ? 'manual' : null;
            reasonExtractionAttempted = false; // Reset if user manually edits

            // Remove auto-extracted highlighting if user types
            const reasonField = document.getElementById('reasonForConsult');
            if (reasonField && reasonField.style.background === 'rgb(255, 249, 230)') {
                reasonField.style.background = 'white';
            }

            console.log('üìã Reason field updated:', reasonForConsult || '(empty)');
            saveState(); // Persist to localStorage
        }

        /**
         * Toggle auto deep search activation preference
         * Called when user checks/unchecks the auto-activation checkbox
         */
        function toggleAutoDeepSearch(enabled) {
            autoDeepSearchEnabled = enabled;
            console.log('ü§ñ Auto deep search:', enabled ? 'ENABLED ‚úì' : 'DISABLED ‚úó');
            saveState(); // Persist to localStorage
        }

        /**
         * Reset auto-activation flags for new consultation
         * Call this when starting fresh or changing consultation type
         */
        function resetAutoActivationFlag() {
            autoDeepSearchTriggered = false;
            reasonExtractionAttempted = false;

            console.log('üîÑ Auto-activation flags reset for new consultation');
        }

        /**
         * Save auto-activation state to localStorage
         * Persists user preferences and current reason
         */
        function saveState() {
            try {
                const state = {
                    reasonForConsult: reasonForConsult,
                    reasonSource: reasonSource,
                    autoDeepSearchEnabled: autoDeepSearchEnabled,
                    autoDeepSearchTriggered: autoDeepSearchTriggered,
                    reasonExtractionAttempted: reasonExtractionAttempted,
                    timestamp: new Date().toISOString()
                };

                localStorage.setItem('neuroscribe_auto_search_state', JSON.stringify(state));
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to save state to localStorage:', error);
                // Non-critical - continue without saving
            }
        }

        /**
         * Load auto-activation state from localStorage
         * Called on page initialization
         */
        function loadState() {
            try {
                const saved = localStorage.getItem('neuroscribe_auto_search_state');
                if (saved) {
                    const state = JSON.parse(saved);

                    // Restore user preferences (always persist)
                    autoDeepSearchEnabled = state.autoDeepSearchEnabled !== false; // default true

                    // Restore reason field (if recently saved)
                    const savedTime = new Date(state.timestamp).getTime();
                    const now = Date.now();
                    const hoursSinceUpdate = (now - savedTime) / (1000 * 60 * 60);

                    // Only restore reason if saved within last 24 hours
                    if (hoursSinceUpdate < 24) {
                        reasonForConsult = state.reasonForConsult || '';
                        reasonSource = state.reasonSource || null;
                    } else {
                        reasonForConsult = '';
                        reasonSource = null;
                    }

                    // Never restore session flags (always start fresh)
                    autoDeepSearchTriggered = false;
                    reasonExtractionAttempted = false;

                    // Update UI
                    const reasonField = document.getElementById('reasonForConsult');
                    if (reasonField) {
                        reasonField.value = reasonForConsult;
                    }

                    const toggleCheckbox = document.getElementById('autoDeepSearchToggle');
                    if (toggleCheckbox) {
                        toggleCheckbox.checked = autoDeepSearchEnabled;
                    }

                    console.log('‚úÖ Auto-search state restored from localStorage');
                    console.log('  ‚Üí Auto-activation:', autoDeepSearchEnabled ? 'enabled' : 'disabled');
                    if (reasonForConsult) {
                        console.log('  ‚Üí Reason restored:', reasonForConsult);
                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load state from localStorage:', error);
                // Use defaults - non-critical error
            }
        }

        // ============================================================
        // AUTOSAVE SYSTEM WITH DEBOUNCING
        // ============================================================
        /**
         * Debounce utility - delays function execution until after wait time
         * @param {Function} func - Function to debounce
         * @param {number} wait - Delay in milliseconds
         * @returns {Function} Debounced function
         */
        function debounce(func, wait = CONSTANTS.UI.AUTOSAVE_DELAY) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        /**
         * Show autosave notification (subtle toast)
         */
        function showAutosaveNotification(message = 'üíæ Draft saved', duration = 2000) {
            const statusEl = document.getElementById('status');
            if (!statusEl) return;

            const originalText = statusEl.textContent;
            const originalClass = statusEl.className;

            statusEl.className = 'status info';
            statusEl.textContent = message;

            setTimeout(() => {
                if (statusEl.textContent === message) {
                    statusEl.textContent = originalText;
                    statusEl.className = originalClass;
                }
            }, duration);
        }

        /**
         * Comprehensive autosave - saves all user input to localStorage
         */
        function autosaveState() {
            try {
                const autosaveData = {
                    // Transcript panel
                    transcript: document.getElementById('transcript')?.value || '',

                    // SOAP Quick-Entry panel
                    soapSubjective: document.getElementById('soapSubjective')?.value || '',
                    soapObjective: document.getElementById('soapObjective')?.value || '',
                    soapAssessment: document.getElementById('soapAssessment')?.value || '',
                    soapPlan: document.getElementById('soapPlan')?.value || '',
                    soapSimpleInput: document.getElementById('soapSimpleInput')?.value || '',

                    // Pre-consultation panel
                    customPathology: document.getElementById('customPathology')?.value || '',
                    reasonForConsultInput: document.getElementById('reasonForConsultInput')?.value || '',

                    // Settings
                    consultationType: consultationType,
                    autoDeepSearchEnabled: autoDeepSearchEnabled,
                    soapEnhanceMode: soapEnhanceMode,
                    transcriptEnhanceMode: transcriptEnhanceMode,

                    // Metadata
                    timestamp: new Date().toISOString(),
                    version: 'v8-mitigations'
                };

                localStorage.setItem('neuroscribe_autosave', JSON.stringify(autosaveData));
                console.log('üíæ Autosaved at', new Date().toLocaleTimeString());
                showAutosaveNotification();

            } catch (error) {
                console.warn('‚ö†Ô∏è Autosave failed:', error);
                // Non-critical - continue without saving
            }
        }

        /**
         * Load autosaved data
         */
        function loadAutosavedState() {
            try {
                const saved = localStorage.getItem('neuroscribe_autosave');
                if (!saved) return false;

                const data = JSON.parse(saved);

                // Check if autosave is recent (within 7 days)
                const savedTime = new Date(data.timestamp).getTime();
                const now = Date.now();
                const daysSinceUpdate = (now - savedTime) / (1000 * 60 * 60 * 24);

                if (daysSinceUpdate > 7) {
                    console.log('üóëÔ∏è Autosave is old (>7 days), ignoring');
                    localStorage.removeItem('neuroscribe_autosave');
                    return false;
                }

                console.log('üìÇ Loading autosaved data from', new Date(data.timestamp).toLocaleString());

                // Restore transcript
                const transcriptEl = document.getElementById('transcript');
                if (transcriptEl && data.transcript) {
                    transcriptEl.value = data.transcript;
                }

                // Restore SOAP fields
                const soapSubjectiveEl = document.getElementById('soapSubjective');
                const soapObjectiveEl = document.getElementById('soapObjective');
                const soapAssessmentEl = document.getElementById('soapAssessment');
                const soapPlanEl = document.getElementById('soapPlan');
                const soapSimpleEl = document.getElementById('soapSimpleInput');

                if (soapSubjectiveEl && data.soapSubjective) soapSubjectiveEl.value = data.soapSubjective;
                if (soapObjectiveEl && data.soapObjective) soapObjectiveEl.value = data.soapObjective;
                if (soapAssessmentEl && data.soapAssessment) soapAssessmentEl.value = data.soapAssessment;
                if (soapPlanEl && data.soapPlan) soapPlanEl.value = data.soapPlan;
                if (soapSimpleEl && data.soapSimpleInput) soapSimpleEl.value = data.soapSimpleInput;

                // Restore other fields
                const customPathologyEl = document.getElementById('customPathology');
                const reasonEl = document.getElementById('reasonForConsultInput');

                if (customPathologyEl && data.customPathology) customPathologyEl.value = data.customPathology;
                if (reasonEl && data.reasonForConsultInput) reasonEl.value = data.reasonForConsultInput;

                // Restore settings
                if (data.consultationType) consultationType = data.consultationType;
                if (data.autoDeepSearchEnabled !== undefined) autoDeepSearchEnabled = data.autoDeepSearchEnabled;
                if (data.soapEnhanceMode !== undefined) soapEnhanceMode = data.soapEnhanceMode;
                if (data.transcriptEnhanceMode !== undefined) transcriptEnhanceMode = data.transcriptEnhanceMode;

                console.log('‚úÖ Autosaved data restored');
                return true;

            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load autosaved data:', error);
                return false;
            }
        }

        /**
         * Clear autosaved data
         */
        function clearAutosave() {
            localStorage.removeItem('neuroscribe_autosave');
            console.log('üóëÔ∏è Autosave cleared');
        }

        // Create debounced autosave function
        const debouncedAutosave = debounce(autosaveState, CONSTANTS.UI.AUTOSAVE_DELAY);

        /**
         * Setup autosave listeners on all input fields
         */
        function setupAutosaveListeners() {
            const fieldsToWatch = [
                'transcript',
                'soapSubjective',
                'soapObjective',
                'soapAssessment',
                'soapPlan',
                'soapSimpleInput',
                'customPathology',
                'reasonForConsultInput'
            ];

            fieldsToWatch.forEach(fieldId => {
                const element = document.getElementById(fieldId);
                if (element) {
                    element.addEventListener('input', debouncedAutosave);
                    console.log(`‚úÖ Autosave listener attached to #${fieldId}`);
                }
            });

            console.log('üíæ Autosave system initialized');
        }

        // ============================================================
        // LOADING STATES & PROGRESS INDICATORS
        // ============================================================
        /**
         * Loading state manager - provides visual feedback for long operations
         */
        class LoadingStateManager {
            constructor() {
                this.currentOperation = null;
                this.startTime = null;
                this.statusElement = null;
            }

            /**
             * Start a loading operation
             * @param {string} operationName - Name of the operation
             * @param {string} message - User-friendly message
             * @param {number} estimatedDuration - Estimated duration in ms (optional)
             */
            start(operationName, message, estimatedDuration = null) {
                this.currentOperation = operationName;
                this.startTime = performance.now();
                this.statusElement = document.getElementById('status');

                if (this.statusElement) {
                    this.statusElement.className = 'status info';
                    this.statusElement.textContent = `‚è≥ ${message}`;
                }

                console.log(`üîÑ Started: ${operationName}`)

;

                // Show estimated time if provided
                if (estimatedDuration && this.statusElement) {
                    const estimatedSeconds = Math.ceil(estimatedDuration / 1000);
                    setTimeout(() => {
                        if (this.currentOperation === operationName) {
                            this.statusElement.textContent = `‚è≥ ${message} (‚âà${estimatedSeconds}s)`;
                        }
                    }, 500);
                }
            }

            /**
             * Update loading progress
             * @param {string} message - Updated message
             * @param {number} progress - Progress percentage (0-100)
             */
            update(message, progress = null) {
                if (this.statusElement) {
                    let statusText = `‚è≥ ${message}`;
                    if (progress !== null) {
                        statusText += ` (${Math.round(progress)}%)`;
                    }
                    this.statusElement.textContent = statusText;
                }
            }

            /**
             * Complete a loading operation
             * @param {string} successMessage - Success message
             */
            complete(successMessage = 'Complete') {
                if (this.startTime) {
                    const duration = ((performance.now() - this.startTime) / 1000).toFixed(2);
                    console.log(`‚úÖ Completed: ${this.currentOperation} in ${duration}s`);
                }

                if (this.statusElement) {
                    this.statusElement.className = 'status connected';
                    this.statusElement.textContent = `‚úÖ ${successMessage}`;
                }

                this.currentOperation = null;
                this.startTime = null;
            }

            /**
             * Fail a loading operation
             * @param {string} errorMessage - Error message
             */
            fail(errorMessage) {
                if (this.startTime) {
                    const duration = ((performance.now() - this.startTime) / 1000).toFixed(2);
                    console.error(`‚ùå Failed: ${this.currentOperation} after ${duration}s`);
                }

                if (this.statusElement) {
                    this.statusElement.className = 'status error';
                    this.statusElement.textContent = `‚ùå ${errorMessage}`;
                }

                this.currentOperation = null;
                this.startTime = null;
            }

            /**
             * Get current operation info
             */
            getInfo() {
                if (!this.currentOperation) {
                    return { active: false };
                }

                const elapsed = this.startTime ?
                    (performance.now() - this.startTime) / 1000 : 0;

                return {
                    active: true,
                    operation: this.currentOperation,
                    elapsed: elapsed.toFixed(2) + 's'
                };
            }
        }

        // Global loading state manager
        const loadingState = new LoadingStateManager();

        /**
         * Show inline spinner for specific elements
         * @param {string} elementId - Element to show spinner in
         * @param {string} message - Loading message
         */
        function showInlineSpinner(elementId, message = 'Loading...') {
            const element = document.getElementById(elementId);
            if (!element) return;

            element.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; padding: 40px; color: #586069;">
                    <div style="display: inline-block; width: 20px; height: 20px; border: 3px solid #f3f3f3; border-top: 3px solid #4A90E2; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 10px;"></div>
                    <span>${message}</span>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
        }

        /**
         * Show progress bar in element
         * @param {string} elementId - Element to show progress in
         * @param {number} progress - Progress percentage (0-100)
         * @param {string} message - Progress message
         */
        function showProgressBar(elementId, progress, message = '') {
            const element = document.getElementById(elementId);
            if (!element) return;

            const percent = Math.min(100, Math.max(0, progress));

            element.innerHTML = `
                <div style="padding: 20px;">
                    <div style="margin-bottom: 10px; color: #586069; font-size: 0.9rem;">${message}</div>
                    <div style="background: #e1e4e8; border-radius: 10px; height: 20px; overflow: hidden;">
                        <div style="background: linear-gradient(90deg, #4A90E2, #357ABD); width: ${percent}%; height: 100%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px;">
                            <span style="color: white; font-size: 0.8rem; font-weight: bold;">${Math.round(percent)}%</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // ============================================================
        // REAL-TIME MONITORING FUNCTIONS
        // ============================================================

        function checkForRedFlags(text) {
            if (!selectedPathology || !activeRedFlags || activeRedFlags.length === 0) {
                return;
            }

            const lowerText = text.toLowerCase();
            const detectedFlags = [];

            for (const flag of activeRedFlags) {
                if (lowerText.includes(flag.toLowerCase())) {
                    detectedFlags.push(flag);
                }
            }

            if (detectedFlags.length > 0) {
                // Display alert in status area
                const status = document.getElementById('status');
                const originalStatus = status.textContent;
                const originalClass = status.className;

                status.className = 'status disconnected';
                status.innerHTML = `‚ö†Ô∏è RED FLAG DETECTED: ${detectedFlags[0]}`;

                // Revert after 5 seconds
                setTimeout(() => {
                    if (isRecording) {
                        status.className = 'status recording';
                        status.textContent = 'üî¥ Recording in progress...';
                    } else {
                        status.className = originalClass;
                        status.textContent = originalStatus;
                    }
                }, 5000);

                console.log('üö® Red flags detected:', detectedFlags);
            }
        }

        function checkForScaleComponents(text) {
            if (!selectedPathology) {
                return;
            }

            // Get recommended scales for current pathology
            const pathologyData = PathologyDatabase[selectedPathology];
            if (!pathologyData || !pathologyData.recommendedScales) {
                return;
            }

            const lowerText = text.toLowerCase();
            const detectedComponents = [];

            // Check each recommended scale's keywords
            for (const scaleId of pathologyData.recommendedScales) {
                const scale = ClinicalScalesDatabase[scaleId];
                if (!scale) continue;

                for (const question of scale.questions) {
                    if (!question.keywords) continue;

                    for (const keyword of question.keywords) {
                        if (lowerText.includes(keyword.toLowerCase())) {
                            detectedComponents.push({
                                scale: scale.shortName,
                                scaleId: scaleId,
                                question: question.text,
                                questionId: question.id,
                                keyword: keyword
                            });
                            break; // Only detect once per question
                        }
                    }
                }
            }

            if (detectedComponents.length > 0) {
                // Log detected components
                console.log('üìä Scale components detected:', detectedComponents);

                // Could add visual indicator here if desired
                // For now, just log to console for physician review

                // Optional: Show subtle notification (non-intrusive)
                const component = detectedComponents[0];
                console.log(`‚úì ${component.scale} - ${component.question.substring(0, 50)}...`);
            }
        }

        // ============================================================
        // CLINICAL SCALES FUNCTIONS
        // ============================================================

        function initializeScales() {
            try {
                // Check if database is loaded
                if (typeof ClinicalScalesDatabase === 'undefined') {
                    console.error('‚ùå ClinicalScalesDatabase not loaded');
                    alert('Error: Clinical scales database failed to load. Please refresh the page.');
                    return false;
                }

                // Populate scale selector dropdown
                const select = document.getElementById('scaleSelect');
                if (!select) {
                    console.error('‚ùå Scale selector element not found');
                    return false;
                }

                // Clear existing options except first
                while (select.options.length > 1) {
                    select.remove(1);
                }

                // Add all available scales
                let scalesAdded = 0;
                for (const scaleId in ClinicalScalesDatabase) {
                    const scale = ClinicalScalesDatabase[scaleId];
                    if (scale && scale.name && scale.shortName) {
                        const option = document.createElement('option');
                        option.value = scaleId;
                        option.textContent = `${scale.shortName} - ${scale.name}`;
                        select.appendChild(option);
                        scalesAdded++;
                    }
                }

                console.log(`‚úÖ Clinical scales initialized: ${scalesAdded} scales loaded`);
                return true;
            } catch (error) {
                console.error('‚ùå Error initializing scales:', error);
                alert('Error initializing clinical scales. Please refresh the page.');
                return false;
            }
        }

        function loadScaleForm() {
            const scaleId = document.getElementById('scaleSelect').value;

            if (!scaleId) {
                document.getElementById('scaleFormContainer').style.display = 'none';
                document.getElementById('scalesPlaceholder').style.display = 'block';
                document.getElementById('scaleResults').style.display = 'none';
                return;
            }

            currentScale = ClinicalScalesDatabase[scaleId];

            // Initialize responses object for this scale if not exists
            if (!scaleResponses[scaleId]) {
                scaleResponses[scaleId] = {};
            }

            // Show form container, hide placeholder
            document.getElementById('scaleFormContainer').style.display = 'block';
            document.getElementById('scalesPlaceholder').style.display = 'none';
            document.getElementById('scaleResults').style.display = 'none';

            // Display scale description
            const descDiv = document.getElementById('scaleDescription');
            descDiv.innerHTML = `
                <h3 style="margin: 0 0 10px 0; color: #0066CC;">${currentScale.name}</h3>
                <p style="margin: 0 0 8px 0; font-size: 0.95rem;">${currentScale.description}</p>
                <p style="margin: 0; font-size: 0.85rem; color: #666;">
                    <strong>Range:</strong> ${currentScale.minScore}-${currentScale.maxScore} |
                    <strong>Evidence Level:</strong> ${currentScale.evidenceLevel}
                </p>
            `;

            // Generate form questions
            const questionsDiv = document.getElementById('scaleQuestions');
            questionsDiv.innerHTML = '';

            currentScale.questions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.style.cssText = 'background: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; border: 2px solid #ddd;';

                // Question header
                let questionHTML = `
                    <div style="margin-bottom: 12px;">
                        <span style="background: #0066CC; color: white; padding: 4px 10px; border-radius: 4px; font-weight: 600; margin-right: 8px;">
                            Q${index + 1}
                        </span>
                        ${question.section ? `<span style="color: #666; font-size: 0.9rem;">${question.section}</span>` : ''}
                    </div>
                    <div style="font-weight: 600; margin-bottom: 15px; color: #333; font-size: 1.05rem;">
                        ${question.text}
                    </div>
                `;

                // Generate input based on question type
                if (question.type === 'slider') {
                    // Slider for VAS pain scale
                    questionHTML += `
                        <div style="margin: 15px 0;">
                            <input type="range"
                                id="scale_${scaleId}_${question.id}"
                                min="0" max="10"
                                value="${scaleResponses[scaleId][question.id] || 5}"
                                oninput="updateSliderValue('${scaleId}', '${question.id}', this.value)"
                                style="width: 100%; height: 8px; border-radius: 5px; background: #ddd; outline: none; cursor: pointer;">
                            <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.9rem; color: #666;">
                                <span>0 (No Pain)</span>
                                <span id="slider_value_${scaleId}_${question.id}" style="font-weight: 600; color: #0066CC; font-size: 1.2rem;">
                                    ${scaleResponses[scaleId][question.id] || 5}
                                </span>
                                <span>10 (Worst Pain)</span>
                            </div>
                        </div>
                    `;
                } else {
                    // Radio buttons for standard scales
                    questionHTML += '<div style="margin-top: 10px;">';
                    question.options.forEach((option) => {
                        const isChecked = scaleResponses[scaleId][question.id] === option.value ? 'checked' : '';
                        questionHTML += `
                            <label style="display: flex; align-items: flex-start; padding: 12px; margin-bottom: 8px; border: 2px solid ${isChecked ? '#0066CC' : '#e0e0e0'}; border-radius: 6px; cursor: pointer; background: ${isChecked ? '#e3f2fd' : 'white'}; transition: all 0.2s;">
                                <input type="radio"
                                    name="scale_${scaleId}_${question.id}"
                                    value="${option.value}"
                                    onchange="updateScaleResponse('${scaleId}', '${question.id}', ${option.value})"
                                    ${isChecked}
                                    style="margin-right: 12px; margin-top: 4px; transform: scale(1.2);">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: #333; margin-bottom: 4px;">${option.label}</div>
                                    ${option.description ? `<div style="font-size: 0.85rem; color: #666;">${option.description}</div>` : ''}
                                </div>
                            </label>
                        `;
                    });
                    questionHTML += '</div>';
                }

                questionDiv.innerHTML = questionHTML;
                questionsDiv.appendChild(questionDiv);
            });
        }

        function updateSliderValue(scaleId, questionId, value) {
            // Update display
            document.getElementById(`slider_value_${scaleId}_${questionId}`).textContent = value;
            // Store response
            scaleResponses[scaleId][questionId] = parseInt(value);
            // Save to localStorage
            saveScaleResponsesToStorage();
        }

        function updateScaleResponse(scaleId, questionId, value) {
            // Store the response
            scaleResponses[scaleId][questionId] = value;

            // Save to localStorage
            saveScaleResponsesToStorage();

            // Update all radio labels to reflect selection visually
            const radios = document.getElementsByName(`scale_${scaleId}_${questionId}`);
            radios.forEach(radio => {
                const label = radio.parentElement;
                if (radio.checked) {
                    label.style.borderColor = '#0066CC';
                    label.style.background = '#e3f2fd';
                } else {
                    label.style.borderColor = '#e0e0e0';
                    label.style.background = 'white';
                }
            });
        }

        function saveScaleResponsesToStorage() {
            try {
                const dataToSave = {
                    responses: scaleResponses,
                    scores: calculatedScores,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('neuroscribe_scale_data', JSON.stringify(dataToSave));
                console.log('‚úÖ Scale data saved to localStorage');
            } catch (error) {
                console.error('‚ùå Error saving scale data:', error);
            }
        }

        function loadScaleResponsesFromStorage() {
            try {
                const saved = localStorage.getItem('neuroscribe_scale_data');
                if (saved) {
                    const data = JSON.parse(saved);
                    scaleResponses = data.responses || {};
                    calculatedScores = data.scores || {};
                    console.log(`‚úÖ Scale data loaded from localStorage (saved: ${data.timestamp})`);
                    return true;
                }
            } catch (error) {
                console.error('‚ùå Error loading scale data:', error);
            }
            return false;
        }

        function clearScaleData() {
            if (confirm('Are you sure you want to clear all scale responses and scores? This cannot be undone.')) {
                scaleResponses = {};
                calculatedScores = {};
                localStorage.removeItem('neuroscribe_scale_data');
                // Reset current scale if loaded
                if (currentScale) {
                    loadScaleForm(); // Reload the form to show empty state
                }
                alert('‚úÖ All scale data cleared');
                console.log('‚úÖ Scale data cleared');
            }
        }

        function calculateScale() {
            try {
                if (!currentScale) {
                    alert('Please select a clinical scale first.');
                    return;
                }

                const scaleId = currentScale.id;
                const responses = scaleResponses[scaleId] || {};

                // Validate that at least some questions are answered
                const answeredCount = Object.keys(responses).filter(key => responses[key] !== null && responses[key] !== undefined).length;

                if (answeredCount === 0) {
                    alert('Please answer at least one question before calculating the score.');
                    return;
                }

                // Warn if not all questions answered
                if (answeredCount < currentScale.questions.length) {
                    const proceed = confirm(`Only ${answeredCount} out of ${currentScale.questions.length} questions answered. Score may be incomplete. Continue?`);
                    if (!proceed) return;
                }

                // Update scale object with current responses
                currentScale.questions.forEach(q => {
                    q.value = responses[q.id] !== undefined ? responses[q.id] : null;
                });

                // Calculate score using scale's scoring function
                if (typeof currentScale.scoring !== 'function') {
                    throw new Error('Scale scoring function not found');
                }

                const scoreResult = currentScale.scoring(responses);
                if (!scoreResult) {
                    throw new Error('Score calculation failed');
                }

                calculatedScores[scaleId] = scoreResult;

                // Get interpretation
                let interpretation;
                if (typeof currentScale.interpretation !== 'function') {
                    // Provide default interpretation if function missing
                    interpretation = {
                        severity: 'Score Calculated',
                        color: '#0066CC',
                        description: 'Score calculated successfully',
                        recommendation: 'Review clinical context'
                    };
                } else {
                    if (scaleId === 'ndi' || scaleId === 'odi') {
                        interpretation = currentScale.interpretation(scoreResult.percentage);
                    } else if (scaleId === 'vas_pain') {
                        interpretation = currentScale.interpretation(scoreResult.overallAverage);
                    } else {
                        interpretation = currentScale.interpretation(scoreResult.total);
                    }
                }

                // Display results
                displayScaleResults(currentScale, scoreResult, interpretation);

                console.log(`‚úÖ ${currentScale.shortName} calculated:`, scoreResult);

            } catch (error) {
                console.error('‚ùå Error calculating scale:', error);
                alert(`Error calculating scale: ${error.message}. Please try again.`);
            }
        }

        function displayScaleResults(scale, scoreResult, interpretation) {
            const resultsDiv = document.getElementById('scaleResults');
            resultsDiv.style.display = 'block';

            let resultsHTML = `
                <h3 style="margin: 0 0 20px 0; color: #0066CC; display: flex; align-items: center; justify-content: space-between;">
                    ${scale.shortName} Results
                    <span style="background: ${interpretation.color}; color: white; padding: 6px 12px; border-radius: 6px; font-size: 0.9rem;">
                        ${interpretation.severity}
                    </span>
                </h3>
            `;

            // Score display based on scale type
            if (scale.id === 'vas_pain') {
                resultsHTML += `
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid ${interpretation.color};">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Current Pain</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.current !== null ? scoreResult.current : 'N/A'}</div>
                            </div>
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Worst (24h)</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.worst !== null ? scoreResult.worst : 'N/A'}</div>
                            </div>
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Average</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.average !== null ? scoreResult.average : 'N/A'}</div>
                            </div>
                        </div>
                    </div>
                `;
            } else if (scale.id === 'ndi' || scale.id === 'odi') {
                resultsHTML += `
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid ${interpretation.color};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Raw Score</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: #333;">${scoreResult.total} / ${scoreResult.max}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Disability Index</div>
                                <div style="font-size: 2.5rem; font-weight: 600; color: ${interpretation.color};">${scoreResult.percentage}%</div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                resultsHTML += `
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid ${interpretation.color};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Total Score</div>
                                <div style="font-size: 2.5rem; font-weight: 600; color: #333;">${scoreResult.total}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.85rem; color: #666; margin-bottom: 4px;">Range</div>
                                <div style="font-size: 1.2rem; color: #666;">${scale.minScore} - ${scale.maxScore}</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Completion status
            resultsHTML += `
                <div style="background: ${scoreResult.percentage === 100 ? '#d4edda' : '#fff3cd'}; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                    <strong>Completion:</strong> ${scoreResult.answered} / ${scoreResult.totalQuestions} questions answered (${scoreResult.percentage}%)
                    ${scoreResult.percentage < 100 ? '<div style="margin-top: 5px; font-size: 0.9rem; color: #856404;">‚ö†Ô∏è Score may be inaccurate - not all questions answered</div>' : ''}
                </div>
            `;

            // Interpretation
            resultsHTML += `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="font-weight: 600; color: #333; margin-bottom: 8px;">Clinical Interpretation:</div>
                    <div style="color: #555; margin-bottom: 10px;">${interpretation.description}</div>
                    <div style="background: white; padding: 12px; border-radius: 6px; border-left: 4px solid #0066CC;">
                        <strong>Recommendation:</strong> ${interpretation.recommendation}
                    </div>
                </div>
            `;

            // Evidence and references
            if (scale.references && scale.references.length > 0) {
                resultsHTML += `
                    <div style="font-size: 0.85rem; color: #666; padding-top: 12px; border-top: 1px solid #ddd;">
                        <strong>References:</strong><br>
                        ${scale.references.map(ref => `‚Ä¢ ${ref}`).join('<br>')}
                    </div>
                `;
            }

            resultsDiv.innerHTML = resultsHTML;

            // Scroll to results
            resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // Load scales based on selected pathology
        function loadRecommendedScales(pathologyId) {
            if (!pathologyId) return;

            const select = document.getElementById('scaleSelect');

            // Get scales that match this pathology
            const recommendedScales = [];
            for (const scaleId in ClinicalScalesDatabase) {
                const scale = ClinicalScalesDatabase[scaleId];
                if (scale.pathologies.includes(pathologyId)) {
                    recommendedScales.push(scaleId);
                }
            }

            // If we have recommended scales, highlight them or auto-select first one
            if (recommendedScales.length > 0) {
                // Could implement highlighting or auto-selection here
                console.log('Recommended scales for', pathologyId, ':', recommendedScales);
            }
        }

        // ============================================================
        // V10.2: INTERACTIVE VALIDATION RESOLUTION SYSTEM
        // ============================================================

        /**
         * V10.2: Collect validation issues from validation result and transform into interactive issue objects
         * @param {Object} validationResult - Complete validation result object
         * @returns {Array} Array of issue objects ready for interactive resolution
         */
        function collectValidationIssues(validationResult) {
            console.log('üîç [V10.2] Collecting validation issues for interactive resolution...');

            if (!validationResult || !validationResult.success || !validationResult.validation) {
                console.warn('‚ö†Ô∏è [V10.2] No valid validation results to collect issues from');
                return [];
            }

            const issues = [];
            const validation = validationResult.validation;
            let issueCounter = 0;

            // ========================================
            // 1. FABRICATION ISSUES (CRITICAL Priority)
            // ========================================
            // V10.2.3 FIX #2: Use flattened structure from aggregateCompleteValidation() (includes statementIndex and fixOptions)
            const fabricationsArray = validation.fabrication?.fabrications || [];

            console.log(`   [V10.2.3] Found ${fabricationsArray.length} fabrication issues with sentence-level tracking and multiple fix options`);

            // V10.2.3 FIX #5: Log first fabrication to verify data structure
            if (fabricationsArray.length > 0) {
                console.log(`   üîç [V10.2.3 DATA FLOW] First fabrication in collectValidationIssues:`, {
                    statement: fabricationsArray[0].statement?.substring(0, 50) + '...',
                    statementIndex: fabricationsArray[0].statementIndex,
                    fixOptions: fabricationsArray[0].fixOptions?.length || 0,
                    confidence: fabricationsArray[0].confidence
                });
            }

            if (fabricationsArray && Array.isArray(fabricationsArray)) {
                fabricationsArray.forEach(fab => {
                    issueCounter++;
                    issues.push({
                        id: `fab-${issueCounter}`,
                        layer: 'fabrication',
                        severity: fab.confidence >= 0.7 ? 'CRITICAL' : fab.confidence >= 0.5 ? 'HIGH' : 'MEDIUM',
                        type: 'fabrication',
                        statement: fab.statement || fab.text || 'Unknown statement',
                        message: fab.reason || 'Not found in source transcript',
                        confidence: fab.confidence || 0.5,
                        suggestedCorrection: fab.suggestedCorrection || fab.correction || 'Replace with transcript-based statement or remove',
                        fixOptions: fab.fixOptions || [],  // V10.2.3: Multiple fix options
                        selectedOption: null,  // V10.2.3: User's choice
                        resolution: 'pending',
                        correctionText: null,
                        affectedText: fab.statement || fab.text || '',
                        context: fab.statementIndex ? `Sentence ${fab.statementIndex} of ULTRATHINK` : (fab.location || 'Generated output'),  // V10.2.3: Pinpoint sentence location
                        sentenceNumber: fab.statementIndex || null,  // V10.2.3: Store sentence number for UI display
                        sourceQuote: null
                    });
                });
            }

            // ========================================
            // 2. GROUNDING ISSUES (HIGH Priority)
            // ========================================
            // V10.2 FIX: Navigate to nested grounding errors
            const groundingErrors = validation.extractionValidation?.validation?.errors || [];
            const orphanedFields = groundingErrors.filter(err => err.type === 'orphaned_field');

            console.log(`   [V10.2] Found ${orphanedFields.length} grounding issues (orphaned fields)`);

            orphanedFields.forEach(ground => {
                issueCounter++;
                issues.push({
                    id: `ground-${issueCounter}`,
                    layer: 'grounding',
                    severity: ground.severity || 'HIGH',
                    type: 'missing_source',
                    statement: ground.field || ground.path || 'Unknown field',
                    message: ground.message || 'No source quote found in transcript',
                    confidence: 0.8,
                    suggestedCorrection: `Add source quote for "${ground.field || ground.path}" or remove this claim`,
                    fixOptions: [],  // V10.2.3: Future enhancement for multiple fixes
                    selectedOption: null,
                    resolution: 'pending',
                    correctionText: null,
                    affectedText: ground.value || '',
                    context: ground.field || ground.path || 'Extraction field',
                    sourceQuote: null
                });
            });

            // ========================================
            // 3. COMPLETENESS ISSUES (MEDIUM Priority)
            // ========================================
            // V10.2 FIX: Extract from warnings - completeness issues are typically warnings
            const extractionWarnings = validation.extractionValidation?.validation?.warnings || [];
            const completenessWarnings = extractionWarnings.filter(warn =>
                warn.type === 'low_coverage' || warn.type === 'missing_field'
            );

            console.log(`   [V10.2] Found ${completenessWarnings.length} completeness warnings`);

            completenessWarnings.forEach(gap => {
                issueCounter++;
                issues.push({
                    id: `complete-${issueCounter}`,
                    layer: 'completeness',
                    severity: 'MEDIUM',
                    type: 'missing_information',
                    statement: gap.field || gap.missingField || 'Missing information',
                    message: gap.message || 'Expected information not documented',
                    confidence: 0.7,
                    suggestedCorrection: gap.suggestion || 'Consider documenting this information if clinically relevant',
                    fixOptions: [],  // V10.2.3: Future enhancement for multiple fixes
                    selectedOption: null,
                    resolution: 'pending',
                    correctionText: null,
                    affectedText: '',
                    context: gap.section || 'Clinical documentation',
                    sourceQuote: null
                });
            });

            // ========================================
            // 4. CONSISTENCY ISSUES (MEDIUM Priority)
            // ========================================
            // V10.2 FIX: Extract consistency errors from extraction validation
            const consistencyErrors = groundingErrors.filter(err =>
                err.type === 'consistency' || err.category === 'consistency'
            );

            console.log(`   [V10.2] Found ${consistencyErrors.length} consistency issues`);

            consistencyErrors.forEach(consist => {
                issueCounter++;
                issues.push({
                    id: `consist-${issueCounter}`,
                    layer: 'consistency',
                    severity: consist.severity || 'MEDIUM',
                    type: 'inconsistency',
                    statement: consist.conflict || consist.statement || consist.message || 'Inconsistent information',
                    message: consist.message || 'Information conflicts with other parts of note',
                    confidence: 0.6,
                    suggestedCorrection: consist.resolution || 'Reconcile conflicting information',
                    fixOptions: [],  // V10.2.3: Consistency fix options (future enhancement)
                    selectedOption: null,
                    resolution: 'pending',
                    correctionText: null,
                    affectedText: consist.text || '',
                    context: consist.location || consist.field || 'Note content',
                    sourceQuote: null
                });
            });

            // ========================================
            // 5. PROPORTIONALITY ISSUES (LOW Priority)
            // ========================================
            // V10.2 FIX: Extract from output validation warnings
            const outputWarnings = validation.outputValidations?.ultrathink?.validation?.warnings ||
                                   validation.outputValidations?.doap?.validation?.warnings || [];
            const proportionalityWarnings = outputWarnings.filter(warn =>
                warn.type === 'over_elaboration' || warn.type === 'proportionality'
            );

            console.log(`   [V10.2] Found ${proportionalityWarnings.length} proportionality warnings`);

            proportionalityWarnings.forEach(prop => {
                issueCounter++;
                issues.push({
                    id: `prop-${issueCounter}`,
                    layer: 'proportionality',
                    severity: 'LOW',
                    type: 'disproportionate',
                    statement: prop.section || prop.message || 'Content imbalance detected',  // V10.2.3 FIX: Use message instead of details object
                    message: prop.message || 'Section length disproportionate to source',
                    confidence: 0.5,
                    suggestedCorrection: 'Consider condensing overly detailed sections',
                    fixOptions: [],  // V10.2.3: No fix options for proportionality (informational)
                    selectedOption: null,
                    resolution: 'pending',
                    correctionText: null,
                    affectedText: '',
                    context: prop.section || 'Generated output',
                    sourceQuote: null
                });
            });

            // Store globally
            currentValidationIssues = issues;

            console.log(`‚úÖ [V10.2.3] Collected ${issues.length} validation issues:`);
            console.log(`   - Fabrication: ${issues.filter(i => i.layer === 'fabrication').length}`);
            console.log(`   - Grounding: ${issues.filter(i => i.layer === 'grounding').length}`);
            console.log(`   - Completeness: ${issues.filter(i => i.layer === 'completeness').length}`);
            console.log(`   - Consistency: ${issues.filter(i => i.layer === 'consistency').length}`);
            console.log(`   - Proportionality: ${issues.filter(i => i.layer === 'proportionality').length}`);

            // V10.2.3 FIX #5: Log V10.2.3 feature data (sentence numbers and fix options)
            const fabricationIssues = issues.filter(i => i.layer === 'fabrication');
            if (fabricationIssues.length > 0) {
                const withSentenceNumbers = fabricationIssues.filter(i => i.sentenceNumber !== null).length;
                const withFixOptions = fabricationIssues.filter(i => i.fixOptions && i.fixOptions.length > 0).length;
                console.log(`   üéØ [V10.2.3 FEATURES]:`);
                console.log(`      ‚Üí Fabrications with sentence numbers: ${withSentenceNumbers}/${fabricationIssues.length}`);
                console.log(`      ‚Üí Fabrications with multiple fix options: ${withFixOptions}/${fabricationIssues.length}`);
                if (withFixOptions > 0) {
                    const firstWithOptions = fabricationIssues.find(i => i.fixOptions && i.fixOptions.length > 0);
                    console.log(`      ‚Üí Sample fix options for first issue:`, firstWithOptions.fixOptions.map(opt => opt.type));
                }
            }

            return issues;
        }

        /**
         * V10.2: Display interactive validation resolution interface
         * @param {Array} issues - Array of validation issue objects
         */
        function displayValidationResolutionInterface(issues) {
            console.log('üéØ [V10.2.2] Displaying interactive validation resolution interface (layer-grouped)...');

            const container = document.getElementById('validationIssuesList');
            if (!container) {
                console.error('‚ùå [V10.2.2] Validation issues container not found');
                return;
            }

            if (issues.length === 0) {
                container.innerHTML = '<p style="color: #28a745; text-align: center; padding: 20px; font-style: italic;">‚úÖ No validation issues detected. Quality checks passed!</p>';
                document.getElementById('validationIssues').style.display = 'none';
                return;
            }

            // Show issues section
            document.getElementById('validationIssues').style.display = 'block';

            // Group by LAYER (V10.2.2 enhancement)
            const layerGroups = {
                'fabrication': issues.filter(i => i.layer === 'fabrication'),
                'grounding': issues.filter(i => i.layer === 'grounding'),
                'completeness': issues.filter(i => i.layer === 'completeness'),
                'consistency': issues.filter(i => i.layer === 'consistency'),
                'proportionality': issues.filter(i => i.layer === 'proportionality')
            };

            // Count issues per layer for summary
            const layerCounts = Object.entries(layerGroups)
                .filter(([_, layerIssues]) => layerIssues.length > 0)
                .map(([layer, layerIssues]) => {
                    const layerName = layer.charAt(0).toUpperCase() + layer.slice(1);
                    return `${layerName} (${layerIssues.length})`;
                });

            const affectedLayersCount = layerCounts.length;

            let html = `
                <div style="background: #f8f9fa; padding: 16px; border-radius: 6px; margin-bottom: 20px; border-left: 4px solid #4A90E2;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div>
                            <h3 style="margin: 0 0 8px 0; color: #24292e; font-size: 1.1rem;">‚ö†Ô∏è Validation Issues by Layer</h3>
                            <div style="color: #6a737d; font-size: 0.85rem;">
                                <strong>${issues.length} total issues</strong> across <strong>${affectedLayersCount} layer${affectedLayersCount !== 1 ? 's' : ''}</strong>: ${layerCounts.join(', ')}
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="approveAllIssues()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                                ‚úÖ Approve All
                            </button>
                            <button onclick="rejectAllIssues()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                                ‚ùå Reject All
                            </button>
                            <button onclick="applyAllResolutions()" style="padding: 8px 16px; background: #4A90E2; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                                üîÑ Apply Resolutions
                            </button>
                        </div>
                    </div>
                    <p style="margin: 0; color: #6a737d; font-size: 0.9rem;">Review issues organized by validation layer. Approve to fix, reject to keep as-is, or provide custom corrections.</p>
                </div>
            `;

            // Helper to get severity badge
            const getSeverityBadge = (severity) => {
                const badges = {
                    'CRITICAL': '<span style="background: #dc3545; color: white; padding: 3px 8px; border-radius: 3px; font-size: 0.75rem; font-weight: 600;">üî¥ CRITICAL</span>',
                    'HIGH': '<span style="background: #fd7e14; color: white; padding: 3px 8px; border-radius: 3px; font-size: 0.75rem; font-weight: 600;">üü† HIGH</span>',
                    'MEDIUM': '<span style="background: #ffc107; color: #000; padding: 3px 8px; border-radius: 3px; font-size: 0.75rem; font-weight: 600;">üü° MEDIUM</span>',
                    'LOW': '<span style="background: #17a2b8; color: white; padding: 3px 8px; border-radius: 3px; font-size: 0.75rem; font-weight: 600;">üîµ LOW</span>'
                };
                return badges[severity] || badges['MEDIUM'];
            };

            // Helper to get layer icon
            const getLayerIcon = (layer) => {
                const icons = {
                    'fabrication': 'üö®',
                    'grounding': 'üîó',
                    'completeness': 'üìã',
                    'consistency': '‚öñÔ∏è',
                    'proportionality': 'üìä'
                };
                return icons[layer] || '‚ö†Ô∏è';
            };

            // Helper to render issue card
            const renderIssueCard = (issue) => {
                const icon = getLayerIcon(issue.layer);
                const badge = getSeverityBadge(issue.severity);
                const layerName = issue.layer.charAt(0).toUpperCase() + issue.layer.slice(1);

                return `
                    <div id="issue-card-${issue.id}" class="validation-issue-card" style="background: #ffffff; border: 2px solid #e1e4e8; border-radius: 8px; padding: 16px; margin-bottom: 16px; transition: all 0.2s;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                    <span style="font-size: 1.3rem;">${icon}</span>
                                    <strong style="font-size: 1rem; color: #24292e;">${layerName} Issue</strong>
                                    ${badge}
                                    <span style="font-size: 0.75rem; color: #6a737d; background: #f6f8fa; padding: 3px 8px; border-radius: 3px;">
                                        Confidence: ${Math.round((issue.confidence || 0.5) * 100)}%
                                    </span>
                                </div>
                                <div style="color: #586069; font-size: 0.85rem; margin-bottom: 4px;">
                                    üìç Location: ${escapeHtml(issue.context)}
                                    ${issue.sentenceNumber ? `<span style="margin-left: 8px; background: #ddf4ff; color: #0969da; padding: 2px 8px; border-radius: 12px; font-weight: 600;">Sentence #${issue.sentenceNumber}</span>` : ''}
                                </div>
                            </div>
                        </div>

                        <div style="background: #f6f8fa; padding: 12px; border-radius: 4px; border-left: 3px solid #dc3545; margin-bottom: 12px;">
                            <div style="font-weight: 600; color: #24292e; margin-bottom: 6px;">‚ö†Ô∏è Issue:</div>
                            <div style="color: #24292e; font-size: 0.9rem; margin-bottom: 8px;">${escapeHtml(issue.message)}</div>
                            ${issue.statement ? `
                                <div style="font-weight: 600; color: #24292e; margin-bottom: 6px;">Problematic Text:</div>
                                <div style="background: #fff; padding: 10px; border-radius: 4px; border: 1px solid #d1d5da; font-family: monospace; font-size: 0.85rem; color: #d73a49;">
                                    "${escapeHtml(issue.statement)}"
                                </div>
                            ` : ''}
                        </div>

                        ${issue.fixOptions && issue.fixOptions.length > 0 ? `
                            <div style="background: #e7f5ff; padding: 12px; border-radius: 4px; border-left: 3px solid #0969da; margin-bottom: 12px;">
                                <div style="font-weight: 600; color: #0969da; margin-bottom: 10px;">üí° Suggested Fixes (choose one):</div>

                                ${issue.fixOptions.map((option, idx) => `
                                    <div style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 4px; border: 2px solid #d0d7de; cursor: pointer; transition: all 0.2s;"
                                         onclick="selectFixOption('${issue.id}', '${option.id}')"
                                         id="fix-option-${issue.id}-${option.id}">

                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                            <div style="font-weight: 600; color: #24292e;">
                                                <input type="radio"
                                                       name="fix-${issue.id}"
                                                       id="radio-${issue.id}-${option.id}"
                                                       value="${option.id}"
                                                       ${idx === 0 ? 'checked' : ''}
                                                       style="cursor: pointer;">
                                                <label for="radio-${issue.id}-${option.id}"
                                                       style="margin-left: 6px; cursor: pointer;">
                                                    ${escapeHtml(option.label)}
                                                </label>
                                            </div>
                                            <span style="font-size: 0.8rem; color: #57606a; background: #f6f8fa; padding: 2px 8px; border-radius: 12px;">
                                                ${Math.round(option.confidence * 100)}% confidence
                                            </span>
                                        </div>

                                        <div style="color: #24292e; font-size: 0.85rem; margin-bottom: 4px; font-family: monospace; background: #f6f8fa; padding: 6px; border-radius: 3px;">
                                            ${option.text ? `"${escapeHtml(option.text)}"` : '<em style="color: #d73a49;">Remove statement</em>'}
                                        </div>

                                        <div style="color: #57606a; font-size: 0.8rem;">
                                            ${escapeHtml(option.description)}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : (issue.suggestedCorrection ? `
                            <div style="background: #e7f5ff; padding: 12px; border-radius: 4px; border-left: 3px solid #0969da; margin-bottom: 12px;">
                                <div style="font-weight: 600; color: #0969da; margin-bottom: 6px;">üí° AI Suggestion:</div>
                                <div style="color: #24292e; font-size: 0.9rem;">${escapeHtml(issue.suggestedCorrection)}</div>
                            </div>
                        ` : '')}

                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <button onclick="approveIssue('${issue.id}')"
                                    id="btn-approve-${issue.id}"
                                    style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">
                                ‚úÖ Approve (Use AI Fix)
                            </button>
                            <button onclick="rejectIssue('${issue.id}')"
                                    id="btn-reject-${issue.id}"
                                    style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">
                                ‚ùå Reject (Keep As Is)
                            </button>
                            <button onclick="openCustomFix('${issue.id}')"
                                    id="btn-custom-${issue.id}"
                                    style="padding: 8px 16px; background: #6f42c1; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">
                                ‚úèÔ∏è Custom Fix
                            </button>
                            <span id="status-${issue.id}" style="font-size: 0.9rem; color: #6a737d; font-style: italic;"></span>
                        </div>

                        <div id="custom-fix-${issue.id}" style="display: none; margin-top: 12px; padding: 12px; background: #f6f8fa; border-radius: 4px;">
                            <label style="display: block; font-weight: 600; color: #24292e; margin-bottom: 6px;">
                                Enter your custom correction:
                            </label>
                            <textarea id="correction-input-${issue.id}"
                                      style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #d1d5da; border-radius: 4px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; font-size: 0.9rem; resize: vertical;"
                                      placeholder="Type your custom correction here...">${escapeHtml(issue.suggestedCorrection || '')}</textarea>
                            <div style="display: flex; gap: 8px; margin-top: 8px;">
                                <button onclick="saveCustomFix('${issue.id}')"
                                        style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">
                                    üíæ Save Fix
                                </button>
                                <button onclick="cancelCustomFix('${issue.id}')"
                                        style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">
                                    Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            };

            // V10.2.2: Helper function to get layer display info
            const getLayerDisplayInfo = (layer) => {
                const info = {
                    'fabrication': {
                        icon: 'üö®',
                        name: 'Fabrication Detection',
                        color: '#764ba2',
                        description: 'Statements not supported by transcript'
                    },
                    'grounding': {
                        icon: 'üîó',
                        name: 'Source Grounding',
                        color: '#667eea',
                        description: 'Missing or invalid source quotes'
                    },
                    'completeness': {
                        icon: 'üìã',
                        name: 'Completeness Check',
                        color: '#f093fb',
                        description: 'Potentially missing clinical information'
                    },
                    'consistency': {
                        icon: '‚öñÔ∏è',
                        name: 'Consistency Validation',
                        color: '#4facfe',
                        description: 'Internal contradictions or conflicts'
                    },
                    'proportionality': {
                        icon: 'üìä',
                        name: 'Proportionality Analysis',
                        color: '#43e97b',
                        description: 'Output length vs. source data balance'
                    }
                };
                return info[layer] || { icon: '‚ö†Ô∏è', name: 'Unknown', color: '#6c757d', description: '' };
            };

            // V10.2.2: Render issues grouped BY LAYER
            const layerOrder = ['fabrication', 'grounding', 'completeness', 'consistency', 'proportionality'];

            layerOrder.forEach((layer, index) => {
                const layerIssues = layerGroups[layer];
                if (layerIssues.length === 0) return; // Skip layers with no issues

                const layerInfo = getLayerDisplayInfo(layer);

                // Sort issues within layer by severity (Critical > High > Medium > Low)
                const severityOrder = { 'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3 };
                const sortedLayerIssues = layerIssues.sort((a, b) => {
                    return (severityOrder[a.severity] || 99) - (severityOrder[b.severity] || 99);
                });

                // Layer header
                html += `
                    <div style="margin-top: ${index > 0 ? '32px' : '0'}; margin-bottom: 20px;">
                        <div style="background: linear-gradient(135deg, ${layerInfo.color}15 0%, ${layerInfo.color}05 100%); border-left: 4px solid ${layerInfo.color}; padding: 12px 16px; border-radius: 6px; margin-bottom: 16px;">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <span style="font-size: 1.5rem;">${layerInfo.icon}</span>
                                <div style="flex: 1;">
                                    <h4 style="margin: 0 0 4px 0; color: ${layerInfo.color}; font-size: 1.1rem; font-weight: 700;">
                                        ${layerInfo.name} <span style="color: #6a737d; font-weight: 500;">(${layerIssues.length} issue${layerIssues.length !== 1 ? 's' : ''})</span>
                                    </h4>
                                    <div style="color: #6a737d; font-size: 0.85rem;">${layerInfo.description}</div>
                                </div>
                            </div>
                        </div>
                `;

                // Render all issues in this layer
                sortedLayerIssues.forEach(issue => {
                    html += renderIssueCard(issue);
                });

                html += `</div>`; // Close layer group
            });

            // Show layers with no issues (optional)
            const cleanLayers = layerOrder.filter(layer => layerGroups[layer].length === 0);
            if (cleanLayers.length > 0) {
                const cleanLayerNames = cleanLayers.map(layer => {
                    const info = getLayerDisplayInfo(layer);
                    return `${info.icon} ${info.name}`;
                }).join(', ');

                html += `
                    <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 6px; padding: 12px 16px; margin-top: 24px; color: #155724;">
                        <strong>‚úÖ Clean layers (no issues detected):</strong> ${cleanLayerNames}
                    </div>
                `;
            }

            container.innerHTML = html;
            console.log(`‚úÖ [V10.2.2] Interactive resolution interface displayed: ${issues.length} issues across ${affectedLayersCount} layers`);
        }

        /**
         * V10.2: Resolution handler functions
         */

        /**
         * V10.2.3: Select fix option from multiple alternatives
         */
        function selectFixOption(issueId, optionId) {
            const issue = currentValidationIssues.find(i => i.id === issueId);
            if (!issue) {
                console.error(`‚ùå [V10.2.3] Issue ${issueId} not found`);
                return;
            }

            // Find selected option
            const selectedOption = issue.fixOptions.find(opt => opt.id === optionId);
            if (!selectedOption) {
                console.error(`‚ùå [V10.2.3] Option ${optionId} not found for issue ${issueId}`);
                return;
            }

            // Update issue
            issue.selectedOption = optionId;
            issue.correctionText = selectedOption.text;

            // Visual feedback: highlight selected option
            issue.fixOptions.forEach(opt => {
                const optionDiv = document.getElementById(`fix-option-${issueId}-${opt.id}`);
                if (optionDiv) {
                    if (opt.id === optionId) {
                        optionDiv.style.borderColor = '#0969da';
                        optionDiv.style.background = '#ddf4ff';
                    } else {
                        optionDiv.style.borderColor = '#d0d7de';
                        optionDiv.style.background = 'white';
                    }
                }
            });

            console.log(`‚úÖ [V10.2.3] Selected ${selectedOption.label} fix for issue ${issueId}`);
        }

        function approveIssue(issueId) {
            const issue = currentValidationIssues.find(i => i.id === issueId);
            if (!issue) {
                console.error(`‚ùå [V10.2] Issue ${issueId} not found`);
                return;
            }

            issue.resolution = 'approved';

            // V10.2.3: Use selected fix option or default to first option/single suggestion
            if (issue.fixOptions && issue.fixOptions.length > 0) {
                const selectedId = issue.selectedOption || issue.fixOptions[0].id;
                const selectedOption = issue.fixOptions.find(opt => opt.id === selectedId);
                issue.correctionText = selectedOption.text;
            } else {
                issue.correctionText = issue.suggestedCorrection; // Backward compatibility
            }

            // Update UI
            const statusEl = document.getElementById(`status-${issueId}`);
            if (statusEl) {
                statusEl.textContent = '‚úÖ Approved - Will use AI fix';
                statusEl.style.color = '#28a745';
                statusEl.style.fontWeight = '600';
            }

            // Highlight card as approved
            const card = document.getElementById(`issue-card-${issueId}`);
            if (card) {
                card.style.borderColor = '#28a745';
                card.style.background = '#f0fff4';
            }

            console.log(`‚úÖ [V10.2] Issue ${issueId} approved (will use AI fix)`);
        }

        function rejectIssue(issueId) {
            const issue = currentValidationIssues.find(i => i.id === issueId);
            if (!issue) {
                console.error(`‚ùå [V10.2] Issue ${issueId} not found`);
                return;
            }

            issue.resolution = 'rejected';
            issue.correctionText = null; // Keep original text

            // Update UI
            const statusEl = document.getElementById(`status-${issueId}`);
            if (statusEl) {
                statusEl.textContent = '‚ùå Rejected - Will keep as is';
                statusEl.style.color = '#6c757d';
                statusEl.style.fontWeight = '600';
            }

            // Dim card as rejected
            const card = document.getElementById(`issue-card-${issueId}`);
            if (card) {
                card.style.borderColor = '#6c757d';
                card.style.background = '#f8f9fa';
                card.style.opacity = '0.6';
            }

            console.log(`‚ùå [V10.2] Issue ${issueId} rejected (will keep original)`);
        }

        function openCustomFix(issueId) {
            const customFixDiv = document.getElementById(`custom-fix-${issueId}`);
            if (customFixDiv) {
                customFixDiv.style.display = 'block';
            }
            console.log(`‚úèÔ∏è [V10.2] Opened custom fix input for ${issueId}`);
        }

        function cancelCustomFix(issueId) {
            const customFixDiv = document.getElementById(`custom-fix-${issueId}`);
            if (customFixDiv) {
                customFixDiv.style.display = 'none';
            }
            console.log(`üö´ [V10.2] Cancelled custom fix for ${issueId}`);
        }

        function saveCustomFix(issueId) {
            const issue = currentValidationIssues.find(i => i.id === issueId);
            if (!issue) {
                console.error(`‚ùå [V10.2] Issue ${issueId} not found`);
                return;
            }

            const textarea = document.getElementById(`correction-input-${issueId}`);
            if (!textarea) {
                console.error(`‚ùå [V10.2] Correction input not found for ${issueId}`);
                return;
            }

            const customCorrection = textarea.value.trim();
            if (!customCorrection) {
                alert('‚ö†Ô∏è Please enter a correction or cancel.');
                return;
            }

            issue.resolution = 'fixed';
            issue.correctionText = customCorrection;

            // Update UI
            const statusEl = document.getElementById(`status-${issueId}`);
            if (statusEl) {
                statusEl.textContent = '‚úèÔ∏è Custom fix applied';
                statusEl.style.color = '#6f42c1';
                statusEl.style.fontWeight = '600';
            }

            // Highlight card as custom fixed
            const card = document.getElementById(`issue-card-${issueId}`);
            if (card) {
                card.style.borderColor = '#6f42c1';
                card.style.background = '#f8f0ff';
            }

            // Hide custom fix input
            const customFixDiv = document.getElementById(`custom-fix-${issueId}`);
            if (customFixDiv) {
                customFixDiv.style.display = 'none';
            }

            console.log(`‚úèÔ∏è [V10.2] Issue ${issueId} custom fix saved: "${customCorrection.substring(0, 50)}..."`);
        }

        function approveAllIssues() {
            if (currentValidationIssues.length === 0) {
                alert('‚ÑπÔ∏è No issues to approve.');
                return;
            }

            const confirmed = confirm(
                `‚úÖ APPROVE ALL ISSUES?\n\n` +
                `This will mark all ${currentValidationIssues.length} validation issues for automatic correction using AI suggestions.\n\n` +
                `Click OK to approve all, or Cancel to review individually.`
            );

            if (!confirmed) return;

            currentValidationIssues.forEach(issue => {
                if (issue.resolution === 'pending') {
                    approveIssue(issue.id);
                }
            });

            console.log(`‚úÖ [V10.2] All ${currentValidationIssues.length} issues approved`);
        }

        function rejectAllIssues() {
            if (currentValidationIssues.length === 0) {
                alert('‚ÑπÔ∏è No issues to reject.');
                return;
            }

            const confirmed = confirm(
                `‚ùå REJECT ALL ISSUES?\n\n` +
                `This will keep all original text and ignore all ${currentValidationIssues.length} validation warnings.\n\n` +
                `Click OK to reject all, or Cancel to review individually.`
            );

            if (!confirmed) return;

            currentValidationIssues.forEach(issue => {
                if (issue.resolution === 'pending') {
                    rejectIssue(issue.id);
                }
            });

            console.log(`‚ùå [V10.2] All ${currentValidationIssues.length} issues rejected`);
        }

        // ============================================================
        // V10.2.4 PHASE 1.2: Resolution Progress Indicator Functions
        // ============================================================

        /**
         * Show resolution progress indicator
         */
        function showResolutionProgress() {
            const container = document.getElementById('resolution-progress-container');
            if (container) {
                container.style.display = 'block';
                container.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        /**
         * Hide resolution progress indicator
         */
        function hideResolutionProgress() {
            const container = document.getElementById('resolution-progress-container');
            if (container) {
                setTimeout(() => {
                    container.style.display = 'none';
                }, 1000); // Delay hiding to show final state
            }
        }

        /**
         * Update resolution progress
         * @param {number} percent - Progress percentage (0-100)
         * @param {string} text - Progress text
         * @param {string} stage - Current stage description
         * @param {string} icon - Icon to display
         * @param {number} estimatedSeconds - Estimated seconds remaining
         */
        function updateResolutionProgress(percent, text, stage, icon = 'üîÑ', estimatedSeconds = null) {
            // Update progress bar
            const progressBar = document.getElementById('resolution-progress-bar');
            const progressPercent = document.getElementById('resolution-progress-percent');
            if (progressBar && progressPercent) {
                progressBar.style.width = `${percent}%`;
                progressPercent.textContent = `${Math.round(percent)}%`;

                // Change color based on progress
                if (percent >= 100) {
                    progressBar.style.background = 'linear-gradient(90deg, #10b981 0%, #059669 100%)';
                } else if (percent >= 75) {
                    progressBar.style.background = 'linear-gradient(90deg, #4ade80 0%, #22c55e 100%)';
                } else if (percent >= 50) {
                    progressBar.style.background = 'linear-gradient(90deg, #60a5fa 0%, #3b82f6 100%)';
                } else {
                    progressBar.style.background = 'linear-gradient(90deg, #a78bfa 0%, #8b5cf6 100%)';
                }
            }

            // Update text
            const progressText = document.getElementById('resolution-progress-text');
            if (progressText) {
                progressText.textContent = text;
            }

            // Update icon
            const progressIcon = document.getElementById('resolution-progress-icon');
            if (progressIcon) {
                progressIcon.textContent = icon;
            }

            // Update stage
            const progressStage = document.getElementById('resolution-progress-stage');
            if (progressStage) {
                progressStage.textContent = stage;
            }

            // Update ETA
            const progressEta = document.getElementById('resolution-progress-eta');
            if (progressEta && estimatedSeconds !== null) {
                if (estimatedSeconds === 0) {
                    progressEta.textContent = 'Completing...';
                } else {
                    progressEta.textContent = `Estimated time: ~${estimatedSeconds} seconds remaining`;
                }
            }

            console.log(`üìä [V10.2.4 Progress] ${Math.round(percent)}% - ${stage}`);
        }

        async function applyAllResolutions() {
            if (currentValidationIssues.length === 0) {
                alert('‚ÑπÔ∏è No validation issues to apply resolutions for.');
                return;
            }

            // Check if user has made any decisions
            const pendingCount = currentValidationIssues.filter(i => i.resolution === 'pending').length;
            if (pendingCount === currentValidationIssues.length) {
                alert('‚ö†Ô∏è Please review and approve/reject issues first before applying resolutions.');
                return;
            }

            const approvedCount = currentValidationIssues.filter(i => i.resolution === 'approved' || i.resolution === 'fixed').length;
            const rejectedCount = currentValidationIssues.filter(i => i.resolution === 'rejected').length;

            const confirmed = confirm(
                `üîÑ APPLY RESOLUTIONS?\n\n` +
                `‚úÖ Approved/Fixed: ${approvedCount}\n` +
                `‚ùå Rejected: ${rejectedCount}\n` +
                `‚è≥ Pending: ${pendingCount}\n\n` +
                `This will update your clinical note with the approved corrections and regenerate ULTRATHINK.\n\n` +
                `Click OK to proceed, or Cancel to continue reviewing.`
            );

            if (!confirmed) return;

            console.log(`üîÑ [V10.2] Applying ${approvedCount} resolutions...`);

            // V10.2.4 PHASE 1.2: Show progress indicator
            showResolutionProgress();
            updateResolutionProgress(0, 'Starting resolution process...', 'Initializing workflow', 'üöÄ', 10);

            await generateResolvedNote();
        }

        /**
         * V10.2: Generate resolved note with all approved corrections applied
         * This function applies all approved/fixed resolutions to the clinical note and regenerates ULTRATHINK
         */
        async function generateResolvedNote() {
            console.log('üîÑ [V10.2] Starting note resolution process...');

            // Get current clinical note
            const outputTextarea = document.getElementById('output');
            if (!outputTextarea || !outputTextarea.value) {
                alert('‚ùå No clinical note found to resolve. Please generate a note first.');
                return;
            }

            let resolvedNote = outputTextarea.value;
            let appliedCount = 0;
            let skippedCount = 0;

            // Get all issues that need fixing (approved or custom fixed)
            const issuesToFix = currentValidationIssues.filter(i => i.resolution === 'approved' || i.resolution === 'fixed');

            console.log(`   Processing ${issuesToFix.length} approved/fixed issues...`);

            // V10.2.4 PHASE 1.2: Update progress - Stage 1
            updateResolutionProgress(10, 'Applying corrections to clinical note...', `Replacing ${issuesToFix.length} problematic statements with approved fixes`, '‚úèÔ∏è', 8);

            // Apply each resolution
            issuesToFix.forEach(issue => {
                if (!issue.affectedText || !issue.correctionText) {
                    console.warn(`‚ö†Ô∏è [V10.2] Skipping ${issue.id}: missing affectedText or correctionText`);
                    skippedCount++;
                    return;
                }

                // Check if affectedText exists in the note
                if (resolvedNote.includes(issue.affectedText)) {
                    // Replace first occurrence
                    resolvedNote = resolvedNote.replace(issue.affectedText, issue.correctionText);
                    appliedCount++;
                    console.log(`   ‚úÖ Applied fix for ${issue.id}: "${issue.affectedText.substring(0, 40)}..." ‚Üí "${issue.correctionText.substring(0, 40)}..."`);
                } else {
                    // Try case-insensitive search
                    const regex = new RegExp(issue.affectedText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                    if (regex.test(resolvedNote)) {
                        resolvedNote = resolvedNote.replace(regex, issue.correctionText);
                        appliedCount++;
                        console.log(`   ‚úÖ Applied fix (case-insensitive) for ${issue.id}`);
                    } else {
                        console.warn(`‚ö†Ô∏è [V10.2] Could not find text to replace for ${issue.id}`);
                        console.warn(`   Expected: "${issue.affectedText.substring(0, 60)}..."`);
                        skippedCount++;
                    }
                }
            });

            // Update the clinical note textarea
            outputTextarea.value = resolvedNote;
            console.log(`‚úÖ [V10.2] Note updated: ${appliedCount} fixes applied, ${skippedCount} skipped`);

            // Store the resolved note
            currentNoteVersions.full = resolvedNote;

            // V10.2.4 PHASE 1.2: Update progress - Stage 2
            updateResolutionProgress(30, 'Clinical note updated successfully!', `Applied ${appliedCount} corrections, preparing to regenerate ULTRATHINK`, '‚úÖ', 6);

            // Show progress message
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.className = 'status success';
                statusEl.textContent = `üîÑ Regenerating ULTRATHINK with ${appliedCount} corrections...`;
            }

            // Regenerate ULTRATHINK and other compressions
            try {
                // V10.2.4 PHASE 1.2: Update progress - Stage 3
                updateResolutionProgress(40, 'Regenerating ULTRATHINK compression...', 'Calling AI to generate 15-second ultra-compressed handoff from corrected note', 'üß†', 5);

                console.log('   üîÑ Regenerating ULTRATHINK...');
                currentNoteVersions.status.ultra = 'generating';
                updateCompressionStatusBadges();

                const ultraSummary = await generateUltraAttendingSummary(resolvedNote);
                currentNoteVersions.ultra = ultraSummary || '';
                currentNoteVersions.status.ultra = 'ready';
                updateCompressionStatusBadges();

                console.log('‚úÖ [V10.2] ULTRATHINK regenerated successfully');

                // V10.2.4 PHASE 1.2: Update progress - Stage 4
                updateResolutionProgress(65, 'ULTRATHINK regenerated successfully!', 'New 15-second handoff contains all corrections, now updating standard compression', 'üéØ', 3);

                // Also regenerate standard compression
                console.log('   üîÑ Regenerating standard compression...');
                currentNoteVersions.status.standard = 'generating';
                updateCompressionStatusBadges();

                const standardSummary = await generateAttendingSummary(resolvedNote);
                currentNoteVersions.standard = standardSummary || '';
                currentNoteVersions.status.standard = 'ready';
                updateCompressionStatusBadges();

                console.log('‚úÖ [V10.2] Standard compression regenerated successfully');

                // V10.2.4 PHASE 1.2: Update progress - Stage 5
                updateResolutionProgress(85, 'Standard compression regenerated!', 'Updating displays and finalizing changes', 'üìÑ', 1);

                // Update display
                const selectedMode = document.querySelector('input[name="compressionMode"]:checked')?.value || 'standard';
                const summaryToDisplay = selectedMode === 'ultra' ? currentNoteVersions.ultra : currentNoteVersions.standard;

                if (summaryToDisplay) {
                    displayAttendingSummary(summaryToDisplay, selectedMode);
                }

                // V10.2.4 PHASE 1.2: Update progress - Stage 6 (Final)
                updateResolutionProgress(100, 'Resolution complete!', `Successfully applied ${appliedCount} corrections and regenerated all compressions`, '‚ú®', 0);

                // Show success message
                if (statusEl) {
                    statusEl.className = 'status success';
                    statusEl.textContent = `‚úÖ Applied ${appliedCount} corrections and regenerated ULTRATHINK successfully!`;
                }

                // V10.2.4 PHASE 1.2: Hide progress indicator after brief delay
                setTimeout(() => {
                    hideResolutionProgress();
                }, 2000);

                // Show summary alert
                alert(
                    `‚úÖ RESOLUTION COMPLETE!\n\n` +
                    `Applied: ${appliedCount} corrections\n` +
                    `Skipped: ${skippedCount} (text not found)\n\n` +
                    `‚úì Clinical note updated\n` +
                    `‚úì ULTRATHINK regenerated\n` +
                    `‚úì Standard compression regenerated\n\n` +
                    `Your corrected note is ready for use!`
                );

                // Reset validation issues after successful resolution
                currentValidationIssues = [];
                console.log('üîÑ [V10.2] Validation issues cleared - ready for re-validation');

            } catch (error) {
                console.error('‚ùå [V10.2] Error regenerating summaries:', error);

                // V10.2.4 PHASE 1.2: Update progress - Error state
                updateResolutionProgress(100, 'Partial success (error occurred)', `Applied ${appliedCount} corrections, but regeneration failed: ${error.message}`, '‚ö†Ô∏è', 0);

                if (statusEl) {
                    statusEl.className = 'status error';
                    statusEl.textContent = `‚ö†Ô∏è Corrections applied but ULTRATHINK regeneration failed: ${error.message}`;
                }

                // V10.2.4 PHASE 1.2: Hide progress indicator after brief delay
                setTimeout(() => {
                    hideResolutionProgress();
                }, 3000);

                alert(
                    `‚ö†Ô∏è PARTIAL SUCCESS\n\n` +
                    `Applied: ${appliedCount} corrections to clinical note\n` +
                    `Skipped: ${skippedCount}\n\n` +
                    `However, ULTRATHINK regeneration failed:\n${error.message}\n\n` +
                    `Your clinical note has been updated, but you may need to regenerate ULTRATHINK manually.`
                );
            }
        }

        // ============================================================
        // VALIDATION RESULTS DISPLAY (V8)
        // ============================================================

        function displayValidationResults(validationResult) {
            console.log('üìä Displaying validation results in UI...');

            if (!validationResult || !validationResult.success) {
                console.warn('‚ö†Ô∏è No valid validation results to display');
                // Keep placeholder visible
                document.getElementById('validationPlaceholder').style.display = 'block';
                return;
            }

            // Hide placeholder
            document.getElementById('validationPlaceholder').style.display = 'none';

            const validation = validationResult.validation;
            if (!validation) {
                console.warn('‚ö†Ô∏è Validation object missing');
                return;
            }

            // ========================================
            // 1. OVERALL QUALITY SCORE
            // ========================================
            const overallScore = Math.round(validation.overallScore || 0);
            const scoreDisplay = document.getElementById('qualityScoreDisplay');
            const badgeDisplay = document.getElementById('qualityBadgeDisplay');

            if (scoreDisplay) {
                scoreDisplay.textContent = overallScore;

                // Color-code the score
                if (overallScore >= 80) {
                    scoreDisplay.style.color = '#28a745'; // Green
                } else if (overallScore >= 60) {
                    scoreDisplay.style.color = '#ffc107'; // Yellow/Orange
                } else {
                    scoreDisplay.style.color = '#dc3545'; // Red
                }
            }

            // Quality badge
            if (badgeDisplay) {
                if (overallScore >= 80) {
                    badgeDisplay.textContent = 'üü¢ High Quality';
                    badgeDisplay.style.background = '#d4edda';
                    badgeDisplay.style.color = '#155724';
                    badgeDisplay.style.border = '2px solid #28a745';
                } else if (overallScore >= 60) {
                    badgeDisplay.textContent = 'üü° Moderate Quality';
                    badgeDisplay.style.background = '#fff3cd';
                    badgeDisplay.style.color = '#856404';
                    badgeDisplay.style.border = '2px solid #ffc107';
                } else {
                    badgeDisplay.textContent = 'üî¥ Review Needed';
                    badgeDisplay.style.background = '#f8d7da';
                    badgeDisplay.style.color = '#721c24';
                    badgeDisplay.style.border = '2px solid #dc3545';
                }
            }

            // ========================================
            // V10.2.3: SCORE TRANSPARENCY BREAKDOWN
            // ========================================
            // Calculate extraction and output scores for transparency
            const groundingScore = validation.grounding?.score || 0;
            const fabricationScore = validation.fabrication?.score || 0;
            const completenessScore = validation.completeness?.score || 0;
            const consistencyScore = validation.consistency?.score || 0;
            const proportionalityScore = validation.proportionality?.score || 0;

            const extractionScore = (groundingScore + fabricationScore + completenessScore) / 3;
            const outputScore = (consistencyScore + proportionalityScore) / 2;

            const extractionWeighted = extractionScore * 0.6;
            const outputWeighted = outputScore * 0.4;
            const calculatedOverall = extractionWeighted + outputWeighted;

            // Populate breakdown UI elements
            const extractionDetail = document.getElementById('extractionScoreDetail');
            const outputDetail = document.getElementById('outputScoreDetail');
            const formulaDisplay = document.getElementById('calculationFormula');
            const breakdownToggle = document.getElementById('scoreBreakdownToggle');

            if (extractionDetail) {
                extractionDetail.innerHTML = `
                    <strong>${Math.round(extractionScore)}/100</strong><br>
                    <span style="font-size: 0.85rem;">
                        = (Grounding: ${Math.round(groundingScore)} + Fabrication: ${Math.round(fabricationScore)} + Completeness: ${Math.round(completenessScore)}) √∑ 3<br>
                        Weighted: ${Math.round(extractionScore)} √ó 0.6 = <strong>${Math.round(extractionWeighted)}</strong>
                    </span>
                `;
            }

            if (outputDetail) {
                outputDetail.innerHTML = `
                    <strong>${Math.round(outputScore)}/100</strong><br>
                    <span style="font-size: 0.85rem;">
                        = (Consistency: ${Math.round(consistencyScore)} + Proportionality: ${Math.round(proportionalityScore)}) √∑ 2<br>
                        Weighted: ${Math.round(outputScore)} √ó 0.4 = <strong>${Math.round(outputWeighted)}</strong>
                    </span>
                `;
            }

            if (formulaDisplay) {
                formulaDisplay.innerHTML = `
                    Overall Score = (Extraction √ó 0.6) + (Output √ó 0.4)<br>
                    Overall Score = ${Math.round(extractionWeighted)} + ${Math.round(outputWeighted)} = <strong>${Math.round(calculatedOverall)}</strong>
                `;
            }

            // Show breakdown toggle button
            if (breakdownToggle) {
                breakdownToggle.style.display = 'block';
            }

            // ========================================
            // 2. LAYER SCORES & PROGRESS BARS
            // ========================================
            const layers = [
                { id: 'grounding', data: validation.grounding, color: '#667eea' },
                { id: 'fabrication', data: validation.fabrication, color: '#764ba2' },
                { id: 'completeness', data: validation.completeness, color: '#f093fb' },
                { id: 'consistency', data: validation.consistency, color: '#4facfe' },
                { id: 'proportionality', data: validation.proportionality, color: '#43e97b' }
            ];

            layers.forEach(layer => {
                const score = layer.data?.score !== undefined ? Math.round(layer.data.score) : 0;
                const scoreEl = document.getElementById(`${layer.id}-score`);
                const progressBar = document.querySelector(`#${layer.id}-progress div`);

                if (scoreEl) {
                    scoreEl.textContent = score;
                    // Color-code individual scores
                    if (score >= 80) {
                        scoreEl.style.color = '#28a745';
                    } else if (score >= 60) {
                        scoreEl.style.color = '#ffc107';
                    } else {
                        scoreEl.style.color = '#dc3545';
                    }
                }

                if (progressBar) {
                    progressBar.style.width = `${score}%`;
                    progressBar.style.background = layer.color;
                }

                // Show details if available
                const detailsEl = document.getElementById(`${layer.id}-details`);
                if (detailsEl && layer.data) {
                    let detailsHTML = '';

                    if (layer.id === 'grounding' && layer.data.coverage) {
                        detailsHTML = `<strong>Coverage:</strong> ${Math.round(layer.data.coverage * 100)}%`;
                        if (layer.data.quotesFound !== undefined) {
                            detailsHTML += ` | <strong>Quotes:</strong> ${layer.data.quotesFound}`;
                        }
                    } else if (layer.id === 'fabrication') {
                        // V10.2.3: Enhanced fabrication score breakdown
                        const fabrications = layer.data.fabrications || [];

                        // Count by severity
                        const severityCounts = {
                            CRITICAL: fabrications.filter(f => f.severity === 'CRITICAL').length,
                            HIGH: fabrications.filter(f => f.severity === 'HIGH').length,
                            MEDIUM: fabrications.filter(f => f.severity === 'MEDIUM').length,
                            LOW: fabrications.filter(f => f.severity === 'LOW').length
                        };

                        // Deduction values per severity (from scoring algorithm)
                        const deductions = {
                            CRITICAL: 15,
                            HIGH: 10,
                            MEDIUM: 5,
                            LOW: 2
                        };

                        const totalIssues = fabrications.length;
                        const totalDeductions =
                            (severityCounts.CRITICAL * deductions.CRITICAL) +
                            (severityCounts.HIGH * deductions.HIGH) +
                            (severityCounts.MEDIUM * deductions.MEDIUM) +
                            (severityCounts.LOW * deductions.LOW);

                        if (totalIssues > 0) {
                            detailsHTML = `
                                <div style="padding: 10px; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px;">
                                    <strong style="color: #856404;">üìä Fabrication Score Breakdown:</strong><br>
                                    <div style="margin-top: 8px; font-size: 0.85rem;">
                                        ${severityCounts.CRITICAL > 0 ? `
                                            <div style="margin: 4px 0;">
                                                üî¥ <strong>Critical:</strong> ${severityCounts.CRITICAL} issue${severityCounts.CRITICAL > 1 ? 's' : ''}
                                                <span style="color: #dc3545;">(‚àí${severityCounts.CRITICAL * deductions.CRITICAL} points)</span>
                                            </div>
                                        ` : ''}
                                        ${severityCounts.HIGH > 0 ? `
                                            <div style="margin: 4px 0;">
                                                üü† <strong>High:</strong> ${severityCounts.HIGH} issue${severityCounts.HIGH > 1 ? 's' : ''}
                                                <span style="color: #dc3545;">(‚àí${severityCounts.HIGH * deductions.HIGH} points)</span>
                                            </div>
                                        ` : ''}
                                        ${severityCounts.MEDIUM > 0 ? `
                                            <div style="margin: 4px 0;">
                                                üü° <strong>Medium:</strong> ${severityCounts.MEDIUM} issue${severityCounts.MEDIUM > 1 ? 's' : ''}
                                                <span style="color: #dc3545;">(‚àí${severityCounts.MEDIUM * deductions.MEDIUM} points)</span>
                                            </div>
                                        ` : ''}
                                        ${severityCounts.LOW > 0 ? `
                                            <div style="margin: 4px 0;">
                                                üîµ <strong>Low:</strong> ${severityCounts.LOW} issue${severityCounts.LOW > 1 ? 's' : ''}
                                                <span style="color: #dc3545;">(‚àí${severityCounts.LOW * deductions.LOW} points)</span>
                                            </div>
                                        ` : ''}
                                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px dashed #ffc107;">
                                            <strong>Total Deductions:</strong> <span style="color: #dc3545; font-weight: bold;">‚àí${totalDeductions} points</span><br>
                                            <span style="font-size: 0.8rem; color: #666;">
                                                Base Score (100) ‚àí Deductions (${totalDeductions}) = <strong>${Math.round(layer.data.score)}</strong>
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            `;
                        } else {
                            // V10.2.3 FIX #3: Distinguish between clean validation and missing data to avoid contradictory messages
                            if (layer.data.score === 100 || layer.data.score >= 95) {
                                detailsHTML = `<span style="color: #28a745;"><strong>‚úÖ No fabrications detected - Clean validation!</strong></span>`;
                            } else if (layer.data.score === 0 || layer.data.score <= 5) {
                                detailsHTML = `<span style="color: #dc3545;"><strong>‚ö†Ô∏è Fabrication data unavailable (score=${Math.round(layer.data.score)})</strong><br><span style="font-size: 0.85rem;">Check console for data flow issues</span></span>`;
                            } else {
                                detailsHTML = `<strong>Score:</strong> ${Math.round(layer.data.score)}/100 <span style="font-size: 0.85rem; color: #666;">(detailed issues not available)</span>`;
                            }
                        }
                    } else if (layer.id === 'completeness') {
                        if (layer.data.extractionCoverage !== undefined) {
                            detailsHTML = `<strong>Extraction Coverage:</strong> ${Math.round(layer.data.extractionCoverage * 100)}%`;
                        }
                    } else if (layer.id === 'consistency') {
                        if (layer.data.issuesFound !== undefined) {
                            detailsHTML = `<strong>Issues Found:</strong> ${layer.data.issuesFound}`;
                        }
                    } else if (layer.id === 'proportionality') {
                        if (layer.data.ratio !== undefined) {
                            detailsHTML = `<strong>Output/Input Ratio:</strong> ${layer.data.ratio.toFixed(2)}`;
                        }
                    }

                    if (detailsHTML) {
                        detailsEl.innerHTML = detailsHTML;
                        detailsEl.style.display = 'block';
                    }
                }
            });

            // ========================================
            // 3. ERRORS & WARNINGS
            // ========================================
            const allIssues = [];

            // Collect issues from all layers
            layers.forEach(layer => {
                if (layer.data?.errors && layer.data.errors.length > 0) {
                    layer.data.errors.forEach(err => {
                        allIssues.push({
                            layer: layer.id,
                            type: 'error',
                            message: err
                        });
                    });
                }
                if (layer.data?.warnings && layer.data.warnings.length > 0) {
                    layer.data.warnings.forEach(warn => {
                        allIssues.push({
                            layer: layer.id,
                            type: 'warning',
                            message: warn
                        });
                    });
                }
            });

            // ========================================
            // V10.2: INTERACTIVE VALIDATION RESOLUTION
            // ========================================
            // Collect validation issues and display interactive resolution interface
            console.log('üéØ [V10.2] Activating interactive validation resolution system...');

            const validationIssues = collectValidationIssues(validationResult);
            displayValidationResolutionInterface(validationIssues);

            // Display simple issues list as fallback (for reference)
            const issuesDiv = document.getElementById('validationIssues');
            const issuesList = document.getElementById('validationIssuesList');

            // If we have interactive issues, the resolution interface handles display
            // If no interactive issues but simple issues exist, show simple list
            if (validationIssues.length === 0 && allIssues.length > 0 && issuesDiv && issuesList) {
                let issuesHTML = '<ul style="margin: 0; padding-left: 20px;">';
                allIssues.forEach(issue => {
                    const icon = issue.type === 'error' ? '‚ùå' : '‚ö†Ô∏è';
                    const layerName = issue.layer.charAt(0).toUpperCase() + issue.layer.slice(1);
                    issuesHTML += `<li style="margin-bottom: 8px;"><strong>${icon} ${layerName}:</strong> ${issue.message}</li>`;
                });
                issuesHTML += '</ul>';

                issuesList.innerHTML = issuesHTML;
                issuesDiv.style.display = 'block';
            }

            // Show the validation tab button
            const validationTabButton = document.getElementById('validation-tab-button');
            if (validationTabButton) {
                validationTabButton.style.display = 'inline-block';
            }

            // Note: Tab switching is handled by calling code to allow review tab priority

            console.log('‚úÖ Validation results displayed successfully');
            console.log(`üéØ [V10.2] Interactive resolution ready: ${validationIssues.length} issues available for review`);
        }

        // Initialize on load
        // ============================================================
        // APPLICATION INITIALIZATION
        // ============================================================
        window.addEventListener('load', async () => {
            try {
                console.log('üé¨ Starting application initialization...');

                // Run startup validation
                const validationPassed = validateStartup();
                if (!validationPassed) {
                    console.error('‚ùå Startup validation failed!');
                    return;
                }

                console.log('‚úÖ Startup validation passed');

                // Initialize components
                console.log('üîë Loading API key...');
                await loadAPIKey();

                console.log('üé§ Initializing speech recognition...');
                initSpeechRecognition();

                console.log('üìä Updating word count...');
                updateWordCount();

                console.log('üíæ Loading saved scale data...');
                loadScaleResponsesFromStorage();

                console.log('üìö Loading uploaded documents...');
                loadUploadedDocumentsFromStorage();

                console.log('ü§ñ Loading auto-search state...');
                loadState();

                console.log('‚öïÔ∏è  Initializing clinical scales...');
                initializeScales();

                console.log('üîÑ Restoring panel states...');
                restorePanelStates();

                console.log('üíæ Loading autosaved data...');
                loadAutosavedState();

                console.log('üíæ Setting up autosave system...');
                setupAutosaveListeners();

                // Update word count as user types
                const transcriptEl = document.getElementById('transcript');
                if (transcriptEl) {
                    transcriptEl.addEventListener('input', updateWordCount);
                    console.log('‚úÖ Transcript input listener attached');
                } else {
                    console.error('‚ùå Transcript element not found');
                }

                // Add SOAP textarea event listeners for real-time stats
                const soapSubjective = document.getElementById('soapSubjective');
                const soapObjective = document.getElementById('soapObjective');
                const soapAssessment = document.getElementById('soapAssessment');
                const soapPlan = document.getElementById('soapPlan');

                if (soapSubjective && soapObjective && soapAssessment && soapPlan) {
                    soapSubjective.addEventListener('input', updateSOAPStats);
                    soapObjective.addEventListener('input', updateSOAPStats);
                    soapAssessment.addEventListener('input', updateSOAPStats);
                    soapPlan.addEventListener('input', updateSOAPStats);
                    console.log('‚úÖ SOAP Quick-Entry input listeners attached');
                } else {
                    console.error('‚ùå One or more SOAP textarea elements not found');
                }

                // Attach event listener to attending summary textarea for live stats
                const attendingSummaryText = document.getElementById('attendingSummaryText');
                if (attendingSummaryText) {
                    attendingSummaryText.addEventListener('input', function() {
                        updateSummaryStats(this.value);
                    });
                    console.log('‚úÖ Attending summary stats listener attached');
                } else {
                    console.error('‚ùå Attending summary textarea not found');
                }

                // Initialize enhancement toggles state
                updateEnhancementToggles();
                console.log('‚úÖ Enhancement toggles initialized');

                console.log('üéâ Application initialization complete!');
                console.log('‚ïê'.repeat(60));

            } catch (error) {
                console.error('üö® CRITICAL ERROR during initialization:', error);
                console.error('Stack trace:', error.stack);
                alert(`Critical error during startup: ${error.message}\n\nPlease refresh the page. If the problem persists, check the browser console (F12).`);
            }
        });
    </script>
</body>
</html>
